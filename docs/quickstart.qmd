---
jupyter: python3
title: "Using `ez_zarr` to explore Fractal outputs"
author: Silvia Barbiero, Michael Stadler
# format:
#   html:
#     toc: true
#     toc-location: left
#     code-copy: true
#     embed-resources: true
#     keep-md: true
#     link-external-icon: true
---

# Goal
The aim of `ez_zarr` is to provide easy, high-level access to high content screening microscopy data, stored as OME-Zarr filesets according to the [NGFF](https://ngff.openmicroscopy.org/latest/) specifications with additional metadata fields, for example the ones generated by the [Fractal](https://fractal-analytics-platform.github.io/fractal-tasks-core/) platform.

The goal is that users can write simple scripts working with plates, wells and fields of view, without having to understand how these are represented within an OME-Zarr fileset.

# Installation
`ez_zarr` is hosted on GitHub at [github.com/fmicompbio/ez_zarr](https://github.com/fmicompbio/ez_zarr) and the documentation of can be found at [fmicompbio.github.io/ez_zarr](https://fmicompbio.github.io/ez_zarr/).

To install it, activate a `conda` environment, or create a new one (using `python 3.9` or newer), and install `ez_zarr` from GitHub using:
```{.bash}
pip install git+ssh://git@github.com/fmicompbio/ez_zarr.git
```

# Quickstart
Here are some examples of how you can use `ez_zarr`:

## Download example data
To run the code below, you will first need to download some Fractal output data.
You can do this for example by running the following from a terminal:
```{.bash}
# Download small Fractal output from Zenodo
curl -o temp.zip https://zenodo.org/records/10257149/files/20200812-CardiomyocyteDifferentiation14-Cycle1.zarr.zip

# Unzip and remove the temporary zip file
unzip temp.zip
rm temp.zip
```

or directly from within a python notebook or session using:
```{python}
import requests
import zipfile
import os

# for info on data see: https://zenodo.org/records/10257149
url = 'https://zenodo.org/records/10257149/files/20200812-CardiomyocyteDifferentiation14-Cycle1.zarr.zip'

# download
response = requests.get(url)
with open('temp.zip', 'wb') as temp_zip:
    temp_zip.write(response.content)

# unzip to current directory
with zipfile.ZipFile('temp.zip', 'r') as zip_ref:
    zip_ref.extractall('.')

# clean up
os.remove('temp.zip')
```

## Load packages
```{python}
import matplotlib.pyplot as plt
import matplotlib.patches as patches

from ez_zarr import hcs_wrappers
```

## Open OME-Zarr file set
We open a single OME-Zarr directory, typically representing a single plate:
```{python}
zarr_directory = '20200812-CardiomyocyteDifferentiation14-Cycle1.zarr'
plate = hcs_wrappers.FractalZarr(zarr_directory, name = 'cardio-d14')
plate
```

`plate` represents an acquisition of 1 wells with 4 channels.

There are 5 `pyramid_levels` available (0 to 4), meaning that in addition to the full resolution data (level 0), we have four more levels that provide the data in 2-fold lower resolutions (see `pyramid_zyx_scalefactor`), for example for faster plotting.

This OME-Zarr fileset does not contain any segmentations, but some tables, such as `FOV_ROI_table`, which contains the coordinates of the fields of view.

## Get information from `plate`
You can obtain information on the content available in the fileset:
```{python}
# path to the OME-Zarr fileset
plate.get_path()
```
```{python}
# available channels
plate.get_channels()
```
```{python}
# available wells
plate.get_wells()
plate.get_wells(simplify=True)
```
```{python}
# available tables
plate.get_table_names()
```
```{python}
# zyx pixel spacing in micrometers for pyramid levels
plate.level_zyx_spacing
```

## Extract a table from the OME-Zarr fileset
The tables are stored within the fileset as describe in the [Fractal documentation](https://fractal-analytics-platform.github.io/fractal-tasks-core/tables/).

As mentioned the goal of `ez_zarr` is to abstract the internal structure and make it simple to obtain these tables, if necessary accumulated over many wells, as a `pandas.DataFrame` :
```{python}
#| output: false
df = plate.get_table(table_name='FOV_ROI_table')
df
```
```{python}
#| echo: false
#| output: asis

# output table as md (instead of html to better play with mkdocs)
print(df.to_markdown())
```

or `anndata.AnnData` object:
```{python}
ann = plate.get_table(table_name='FOV_ROI_table', as_AnnData=True)
ann
```

## Get an overview of a full well
`get_image_ROI()` extracts a rectangular region of interest (ROI)
from a well image by coordinates. If no coordinates or
other arguments are given, it returns the whole well at the
lowest available resolution:
```{python}
my_well = plate.get_wells(simplify=True)[0]
print(my_well)

img = plate.get_image_ROI()
print(img.shape) # (ch, z, y, x)

with plt.style.context('dark_background'):
    fig = plt.figure(figsize=(4, 4))
    fig.set_dpi(100)

    plt.imshow(img[0,0], cmap='gray', vmin=100, vmax=600)
    plt.title(plate.name + ' ' + my_well)
    plt.show()
    plt.close()
```

## Get salient regions at higher resolution
`get_image_grid_ROIs()` allows you to split the well image into a rectangular
grid of `num_x`-by-`num_y` regions, and automatically select the `num_select`
top regions based on a given property (`sample_method`).

Here, we pick three regions with the highest signal in channel zero (DAPI):
```{python}
coord_list, img_list = plate.get_image_grid_ROIs(well = my_well,
                                                 pyramid_level=1,
                                                 num_x=10, num_y=5, num_select=3,
                                                 sample_method='sum',
                                                 channel=0)
coord_list # (y_start, y_end, x_start, x_end)
len(img_list)

with plt.style.context('dark_background'):
    fig = plt.figure(figsize=(9,3))
    fig.set_dpi(100)
    for i in range(len(img_list)):
        plt.subplot(1, 3, i + 1)
        plt.imshow(img_list[i][0,0], cmap='gray', vmin=100, vmax=600)
        plt.axis('off')
        plt.title(my_well + ' ' + str(coord_list[i]))
    plt.show()
    plt.close()
```

## Zoom in
Alternatively, we can zoom in by coordinates:
```{python}
img = plate.get_image_ROI(well=my_well,
                          upper_left_yx=(50, 40),
                          lower_right_yx=(120, 90))
print(img.shape)

with plt.style.context('dark_background'):
    fig = plt.figure(figsize=(4, 4))
    fig.set_dpi(100)

    plt.imshow(img[0,0], cmap='gray', vmin=100, vmax=600)
    plt.title(plate.name + ' B03')
    plt.show()
    plt.close()
```

The above automatically uses the lowest resolution (highest pyramid level)
version of the data, and the pixel coordinates refer to that space.

If we want to get the same image at a higher resolution (`pyramid_level=1`),
we need to convert them using the `convert_pixel_to_pixel()` function:
```{python}
# convert coordinates from lowest-resolution (None, here: 4) to
#   highest-resolution (0) pyramid level
# remark: coordinates are (z,y,x)
new_upper_left = plate.convert_pixel_to_pixel(zyx = (0, 50, 40),
                                              pyramid_level_from = None,
                                              pyramid_level_to=1)
new_lower_right = plate.convert_pixel_to_pixel(zyx = (0, 120, 90),
                                               pyramid_level_from = None,
                                               pyramid_level_to=1)

# extract image
img = plate.get_image_ROI(well=my_well,
                          upper_left_yx=new_upper_left[1:],
                          lower_right_yx=new_lower_right[1:],
                          pyramid_level=1)
print(img.shape)

with plt.style.context('dark_background'):
    fig = plt.figure(figsize=(4, 4))
    fig.set_dpi(100)

    plt.imshow(img[0,0], cmap='gray', vmin=100, vmax=600)
    plt.title(plate.name + ' ' + my_well)
    plt.show()
    plt.close()
```

## Coordinate conversions
As mentioned the pixel coordinates depend on the `pyramid_level`, but as
the scaling factor between pyramid levels and also the pixel sizes in
micrometers are known, it's easy to convert between them:
```{python}
zyx = (1, 230, 180) # highest pyramid level (4)
print('starting coordinates (pyramid_level=4): ' + str(zyx))

# convert from pixel to micrometers
zyx_um = plate.convert_pixel_to_micrometer(zyx, pyramid_level=4)
print('in micrometer: ' + str(zyx_um))

# convert from micrometers to pixels
zyx_px = plate.convert_micrometer_to_pixel(zyx_um, pyramid_level=4)
print('back in pixel: ' + str(zyx_px))

# convert pixels between pyramid levels
zyx_px_0 = plate.convert_pixel_to_pixel(zyx_px, pyramid_level_from=4, pyramid_level_to=0)
print('in pixel (pyramid_level=0): ' + str(zyx_px_0))
```

This makes it quite easy to add a scalebar to an image:
```{python}
# calculate the pixel length of a scalebar
scalebar_micrometer = 30
scalebar_pixels = plate.convert_micrometer_to_pixel(zyx = (0, 0, scalebar_micrometer),
                                                    pyramid_level=1)[2]
print(str(scalebar_micrometer) + ' µm correspond to ' + str(scalebar_pixels) + ' pixel in x')

with plt.style.context('dark_background'):
    fig = plt.figure(figsize=(4, 4))
    fig.set_dpi(100)

    plt.imshow(img[0,0], cmap='gray', vmin=100, vmax=600)
    plt.title(plate.name + ' ' + my_well)
    # add scalebar
    # patches.Rectangle((x, y), width, height, edgecolor, facecolor)
    rect = patches.Rectangle((30, 30), scalebar_pixels, 6, edgecolor='yellow', facecolor='yellow')
    ax = plt.gca() # get current axes
    ax.add_patch(rect) # add the patch to the Axes
    # plt.text(x, y, 'Your text', color, ha='center')
    plt.text(30 + scalebar_pixels / 2, 45, str(scalebar_micrometer) + ' µm', color='yellow', ha='center', va='top')
    # show image
    plt.show()
    plt.close()
```

## Calculate on the image data
To save memory, images are stored on disk and only loaded when needed (for implementation details see the [`dask` Array documentation](https://docs.dask.org/en/stable/array.html)).

This can be demonstrated by `type(img)`. To force loading of the data, you can call `.compute()`:
```{python}
print(type(img)) # note that the image is an 'on-disk' array
print(type(img.compute())) # ... and can be loaded into memory using .compute()
```

In general, you can use `dask` arrays like `numpy` arrays.
For example, we can threshold the image: 
```{python}
# threshold
img_mask = img[0,0]>300
# ... and compute to numpy array
img_mask = img_mask.compute()

# plot 
with plt.style.context('dark_background'):
    fig = plt.figure(figsize=(12, 6))
    fig.set_dpi(100)

    # ... channel for segmentation mask
    plt.subplot(1, 4, 1)
    plt.title('Zoom-in image (DAPI)')
    plt.imshow(img[0,0], vmin=100, vmax=600, cmap='gray')
    plt.axis('off')
    
    # ... threshold mask
    plt.subplot(1, 4, 2)
    plt.title('Mask (threshold on DAPI)')
    # define a custom colormap for segmentation
    my_cmap = plt.cm.colors.ListedColormap(['black', 'red'])
    plt.imshow(img_mask, cmap=my_cmap)
    plt.axis('off')

    plt.show()
    plt.close()
```

This is of course not a recommended way to segment this image, but rather meant
to demonstrate that the `dask` arrays can be used just like `numpy` arrays.

# Session info
```{python}
import session_info
session_info.show()
```