{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-ez_zarr","title":"Welcome to ez_zarr","text":""},{"location":"#goals","title":"Goals","text":"<p>The aim of <code>ez_zarr</code> is to provide easy, high-level access to OME-Zarr filesets (high content screening microscopy data, stored according to the NGFF specifications in OME-Zarr with additional metadata fields, for example the ones generated by the Fractal platform).</p> <p>The goal is that users can write simple scripts working with plates, wells and fields of view, without having to understand how these are represented within an OME-Zarr fileset.</p> <p>In addition to the python package, we also provide an R package that automatically generates and wraps a python environment with <code>ez_zarr</code> and all dependencies, available at https://github.com/fmicompbio/ezzarr.</p>"},{"location":"#example","title":"Example","text":"<p>You can use <code>ez_zarr</code> from the command line to get information about an OME-Zarr fileset: <pre><code>ez_zarr tests/example_data/plate_ones.zarr\n</code></pre></p> <p>or from within python to get access to all its functionality: <pre><code>## import module\nfrom ez_zarr import ome_zarr\n\n## open an Image\nimg = ome_zarr.Image('tests/example_data/plate_ones_mip.zarr/B/03/0')\nimg\n# Image 0\n#   path: tests/example_data/plate_ones_mip.zarr/B/03/0\n#   n_channels: 2 (some-label-1, some-label-2)\n#   n_pyramid_levels: 3\n#   pyramid_zyx_scalefactor: [1. 2. 2.]\n#   full_resolution_zyx_spacing (micrometer): [1.0, 0.1625, 0.1625]\n#   segmentations: organoids\n#   tables (measurements): FOV_ROI_table\n\n## legacy objects from `hcs_wrappers`\nfrom ez_zarr import hcs_wrappers\n\nplate_3d = hcs_wrappers.FractalZarr('tests/example_data/plate_ones.zarr')\nplate_3d\n# FractalZarr plate_ones.zarr\n#   path: tests/example_data/plate_ones.zarr\n#   n_wells: 1\n#   n_channels: 2 (some-label-1, some-label-2)\n#   n_pyramid_levels: 3\n#   pyramid_zyx_scalefactor: {'0': array([1. 2. 2.])}\n#   full_resolution_zyx_spacing: [1.0, 0.1625, 0.1625]\n#   segmentations: \n#   tables (measurements): FOV_ROI_table\n</code></pre></p> <p>A more extensive example is available from here, also available as an ipynb notebook.</p>"},{"location":"#install","title":"Install","text":"<p><code>ez_zarr</code> is available for all major platforms (macOS, Linux and Windows) and modern versions of python. It can be installed using <code>pip</code> or <code>conda</code>:</p>"},{"location":"#using-pip","title":"Using <code>pip</code>","text":"<p>The release version of <code>ez_zarr</code> can be installed using pip: <pre><code>pip install ez-zarr\n</code></pre></p> <p>To install also the dependencies required for running unit tests or to download the example data and run the examples given in the documentation, install <code>ez_zarr</code> with the <code>dev</code> and <code>doc</code> extras, respectively: <pre><code>pip install \"ez-zarr[dev,doc]\"\n</code></pre></p> <p>The current (development) version of <code>ez_zarr</code> can be installed from github.com using: <pre><code>pip install git+ssh://git@github.com/fmicompbio/ez_zarr.git\n</code></pre></p>"},{"location":"#using-conda","title":"Using <code>conda</code>","text":"<p>Alternatively, you can install <code>ez-zarr</code> from the <code>conda-forge</code> channel using: <pre><code>conda install -c conda-forge --override-channels ez-zarr\n</code></pre></p>"},{"location":"#software-status","title":"Software status","text":""},{"location":"#supported-versions-of-zarr","title":"Supported versions of <code>zarr</code>","text":"<p><code>ez-zarr</code> currently supports OME-Zarr v0.4 and v0.5 (corresponding to version 2 and 3 of the <code>zarr</code> format, and thus version 2 and 3 of the <code>zarr</code> python package). OME-Zarr v0.5 support was introduced in <code>ez-zarr</code> v0.4.0.</p>"},{"location":"#contributors-and-license","title":"Contributors and License","text":"<p><code>ez_zarr</code> is released under the MIT License, and the copyright is with the Friedrich Miescher Insitute for Biomedical Research (see LICENSE).</p> <p><code>ez_zarr</code> is being developed at the Friedrich Miescher Institute for Biomedical Research by @silvbarb, @csoneson and @mbstadler.</p>"},{"location":"#need-help","title":"Need help?","text":"<p>If you run into problems when using <code>ez_zarr</code>, please first check whether the  answer is available in the help pages for the individual functions underneath 'Documentation' or in  the 'Getting started' vignette. If not, please open an issue  and explain your problem. Try to provide a reproducible example, and always  include the code you used, that will make it much easier for us to help.</p>"},{"location":"#contributions","title":"Contributions","text":"<p>If you would like to contribute to <code>ez_zarr</code>, you can do so by sending a pull  request to this repository. If the contribution involves changes in the  functionality provided by <code>ez_zarr</code>, we encourage you to first open an issue  to discuss the intended contribution. </p>"},{"location":"getting_started_Image/","title":"Using <code>ez_zarr</code> to explore individual OME-Zarr images","text":"<p>Silvia Barbiero, Michael Stadler, Charlotte Soneson</p> <ul> <li>Goal</li> <li>Using <code>ome_zarr.Image</code> objects<ul> <li>Download example data</li> <li>Load packages</li> <li>Open OME-Zarr file set</li> <li>Get information from <code>img</code></li> <li>Extract a table from the OME-Zarr     image</li> <li>Visualize the image</li> <li>Zoom in</li> <li>Coordinate conversions (usually done     internally)</li> <li>Working with segmentation     masks</li> <li>Calculations on the image     data</li> </ul> </li> <li>Working with images with time     dimension</li> <li>Working with multiple images</li> <li>Session info</li> </ul>"},{"location":"getting_started_Image/#goal","title":"Goal","text":"<p>The aim of <code>ez_zarr</code> is to provide easy, high-level access to microscopy data, stored in OME-Zarr format according to the NGFF specifications.</p> <p>In addition to the python package, we also provide an R package that automatically generates and wraps a python environment with <code>ez_zarr</code> and all dependencies, available at https://github.com/fmicompbio/ezzarr.</p> <p>The <code>ome_zarr.Image</code> class represents an individual image and provides methods to obtain metadata, extract image or label arrays and visualize these. Below we illustrate the use of <code>ome_zarr.Image</code> objects by examples.</p>"},{"location":"getting_started_Image/#using-ome_zarrimage-objects","title":"Using <code>ome_zarr.Image</code> objects","text":"<p>Note: If you prefer to run these examples interactively, you can also download them as an ipynb notebook.</p> <p>Here are some examples of how you can use <code>ome_zarr.Image</code> objects defined in <code>ez_zarr</code>:</p>"},{"location":"getting_started_Image/#download-example-data","title":"Download example data","text":"<p>To run the code below, you will first need to download some image data. You can do this for example by running the following from a terminal:</p> <pre><code># Download small Fractal output from Zenodo\ncurl -o temp.zip https://zenodo.org/records/10519143/files/20200812-CardiomyocyteDifferentiation14-Cycle1_mip.zarr.zip\n\n# Unzip and remove the temporary zip file\nunzip temp.zip\nrm temp.zip\n</code></pre> <p>or directly from within a python notebook or session using:</p> <pre><code>import pandas as pd\nimport requests\nimport zipfile\nimport tempfile\nimport shutil\nimport os\nimport sys\n# for info on data see: https://zenodo.org/records/10257149\nurl = 'https://zenodo.org/records/10519143/files/20200812-CardiomyocyteDifferentiation14-Cycle1_mip.zarr.zip'\n# download\nresponse = requests.get(url)\nwith open('temp.zip', 'wb') as temp_zip:\ntemp_zip.write(response.content)\n# unzip to current directory\nwith zipfile.ZipFile('temp.zip', 'r') as zip_ref:\nzip_ref.extractall('.')\n# clean up\nos.remove('temp.zip')\n</code></pre>"},{"location":"getting_started_Image/#load-packages","title":"Load packages","text":"<pre><code>import matplotlib.pyplot as plt\nfrom matplotlib.colors import ListedColormap\nimport numpy as np\nfrom skimage import color\nfrom ez_zarr import ome_zarr, plotting, utils\n</code></pre>"},{"location":"getting_started_Image/#open-ome-zarr-file-set","title":"Open OME-Zarr file set","text":"<p>We open a single OME-Zarr image:</p> <pre><code>img_directory = '20200812-CardiomyocyteDifferentiation14-Cycle1_mip.zarr/B/03/0'\nimg = ome_zarr.Image(path = img_directory, name = 'cardio-d14')\nimg\n</code></pre> <pre><code>/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/zarr/core/group.py:3530: ZarrUserWarning: Object at .DS_Store is not recognized as a component of a Zarr hierarchy.\n  warnings.warn(\n/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/zarr/core/group.py:3530: ZarrUserWarning: Object at empty_well_ROI_table_1_True_0_0 is not recognized as a component of a Zarr hierarchy.\n  warnings.warn(\n/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/zarr/core/group.py:3530: ZarrUserWarning: Object at empty_well_ROI_table_0_True_0_0 is not recognized as a component of a Zarr hierarchy.\n  warnings.warn(\n/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/zarr/core/group.py:3530: ZarrUserWarning: Object at table_well_ROI_table_3_False_0_0 is not recognized as a component of a Zarr hierarchy.\n  warnings.warn(\n/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/zarr/core/group.py:3530: ZarrUserWarning: Object at empty_well_ROI_table_1_False_0_0 is not recognized as a component of a Zarr hierarchy.\n  warnings.warn(\n/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/zarr/core/group.py:3530: ZarrUserWarning: Object at table_overwrite_True is not recognized as a component of a Zarr hierarchy.\n  warnings.warn(\n/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/zarr/core/group.py:3530: ZarrUserWarning: Object at table_FOV_ROI_table_1_False_0_0 is not recognized as a component of a Zarr hierarchy.\n  warnings.warn(\n/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/zarr/core/group.py:3530: ZarrUserWarning: Object at table_masked_nuclei_ROI_table_0_True_0_0 is not recognized as a component of a Zarr hierarchy.\n  warnings.warn(\n/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/zarr/core/group.py:3530: ZarrUserWarning: Object at table_well_ROI_table_3_True_0_0 is not recognized as a component of a Zarr hierarchy.\n  warnings.warn(\n/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/zarr/core/group.py:3530: ZarrUserWarning: Object at empty_well_ROI_table_0_False_0_0 is not recognized as a component of a Zarr hierarchy.\n  warnings.warn(\n/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/zarr/core/group.py:3530: ZarrUserWarning: Object at table_FOV_ROI_table_1_True_0_0 is not recognized as a component of a Zarr hierarchy.\n  warnings.warn(\n/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/zarr/core/group.py:3530: ZarrUserWarning: Object at table_masked_nuclei_ROI_table_1_True_0_0 is not recognized as a component of a Zarr hierarchy.\n  warnings.warn(\n/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/zarr/core/group.py:3530: ZarrUserWarning: Object at table_overwrite_False is not recognized as a component of a Zarr hierarchy.\n  warnings.warn(\n/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/zarr/core/group.py:3530: ZarrUserWarning: Object at table_well_ROI_table_0_True_0_0 is not recognized as a component of a Zarr hierarchy.\n  warnings.warn(\n\nImage cardio-d14\n  path: 20200812-CardiomyocyteDifferentiation14-Cycle1_mip.zarr/B/03/0\n  n_channels: 1 (DAPI)\n  n_pyramid_levels: 5\n  pyramid_zyx_scalefactor: [1. 2. 2.]\n  full_resolution_zyx_spacing (micrometer): [1.0, 0.1625, 0.1625]\n  segmentations: nuclei, empty\n  tables (measurements): expected_table_well_ROI_table_0_True_0_0, well_ROI_table, expected_table_well_ROI_table_3_False_0_0, expected_table_masked_nuclei_ROI_table_0_True_0_0, FOV_ROI_table, expected_table_masked_nuclei_ROI_table_1_True_0_0, expected_table_well_ROI_table_3_True_0_0, expected_table_FOV_ROI_table_1_False_0_0, nuclei_ROI_table, nuclei, expected_table_FOV_ROI_table_1_True_0_0\n</code></pre> <p><code>img</code> represents a maximum intensity projection of one well from a high-content screening plate, processed using Fractal. In addition to such images with two spatial dimensions, <code>ez-zarr</code> supports OME-Zarr images with any number of dimensions, automatically projecting images with more than two spatial dimensions for plotting.</p> <p>In <code>img</code>, there are 5 <code>pyramid_levels</code> available (0 to 4), meaning that in addition to the full resolution data (level 0), we have four more levels that provide the data in 2-fold lower resolutions (see <code>pyramid_zyx_scalefactor</code>), for example for faster plotting.</p> <p>This OME-Zarr image also contains two segmentations (<code>empty</code> and <code>nuclei</code>), and for one measurements have been extracted and saved in the table <code>nuclei</code>. In addition, there are some further tables, such as <code>FOV_ROI_table</code>, which contains the coordinates of the fields of view, or <code>nuclei_ROI_table</code>, which contains the bounding box coordinates for the segmented nuclei.</p>"},{"location":"getting_started_Image/#get-information-from-img","title":"Get information from <code>img</code>","text":"<p>You can obtain specific information on the content available in the image:</p> <pre><code># path to the OME-Zarr image\nimg.get_path()\n</code></pre> <pre><code>'20200812-CardiomyocyteDifferentiation14-Cycle1_mip.zarr/B/03/0'\n</code></pre> <pre><code># available channels\nimg.get_channels()\n</code></pre> <pre><code>[{'color': '00FFFF',\n  'label': 'DAPI',\n  'wavelength_id': 'A01_C01',\n  'window': {'end': 800, 'max': 65535, 'min': 0, 'start': 110}}]\n</code></pre> <pre><code># available labels\nimg.get_label_names()\n</code></pre> <pre><code>['nuclei', 'empty']\n</code></pre> <pre><code># available tables\nimg.get_table_names()\n</code></pre> <pre><code>['expected_table_well_ROI_table_0_True_0_0',\n 'well_ROI_table',\n 'expected_table_well_ROI_table_3_False_0_0',\n 'expected_table_masked_nuclei_ROI_table_0_True_0_0',\n 'FOV_ROI_table',\n 'expected_table_masked_nuclei_ROI_table_1_True_0_0',\n 'expected_table_well_ROI_table_3_True_0_0',\n 'expected_table_FOV_ROI_table_1_False_0_0',\n 'nuclei_ROI_table',\n 'nuclei',\n 'expected_table_FOV_ROI_table_1_True_0_0']\n</code></pre> <pre><code># zyx pixel spacing in micrometers for pyramid levels\n# ... for images (channels, z, y, x)\nimg.get_scale(pyramid_level='0')\n</code></pre> <pre><code>[1, 1.0, 0.1625, 0.1625]\n</code></pre> <pre><code># ... for labels (z, y, x)\nimg.get_scale(pyramid_level='0', label_name='nuclei')\n</code></pre> <pre><code>[1.0, 0.65, 0.65]\n</code></pre> <pre><code># tree of folder and file structure in the zarr group\nprint(img.tree(level=3))\n</code></pre> <pre>/\n\u251c\u2500\u2500 0 (1, 1, 2160, 5120) uint16\n\u251c\u2500\u2500 1 (1, 1, 1080, 2560) uint16\n\u251c\u2500\u2500 2 (1, 1, 540, 1280) uint16\n\u251c\u2500\u2500 3 (1, 1, 270, 640) uint16\n\u251c\u2500\u2500 4 (1, 1, 135, 320) uint16\n\u251c\u2500\u2500 labels\n\u2502   \u251c\u2500\u2500 empty\n\u2502   \u2502   \u251c\u2500\u2500 0 (1, 540, 1280) uint32\n\u2502   \u2502   \u251c\u2500\u2500 1 (1, 270, 640) uint32\n\u2502   \u2502   \u251c\u2500\u2500 2 (1, 135, 320) uint32\n\u2502   \u2502   \u251c\u2500\u2500 3 (1, 67, 160) uint32\n\u2502   \u2502   \u2514\u2500\u2500 4 (1, 33, 80) uint32\n\u2502   \u2514\u2500\u2500 nuclei\n\u2502       \u251c\u2500\u2500 0 (1, 540, 1280) uint32\n\u2502       \u251c\u2500\u2500 1 (1, 270, 640) uint32\n\u2502       \u251c\u2500\u2500 2 (1, 135, 320) uint32\n\u2502       \u251c\u2500\u2500 3 (1, 67, 160) uint32\n\u2502       \u2514\u2500\u2500 4 (1, 33, 80) uint32\n\u2514\u2500\u2500 tables\n    \u251c\u2500\u2500 FOV_ROI_table\n    \u2502   \u251c\u2500\u2500 X (2, 8) float32\n    \u2502   \u251c\u2500\u2500 layers\n    \u2502   \u251c\u2500\u2500 obs\n    \u2502   \u2502   \u2514\u2500\u2500 FieldIndex (2,) object\n    \u2502   \u251c\u2500\u2500 obsm\n    \u2502   \u251c\u2500\u2500 obsp\n    \u2502   \u251c\u2500\u2500 uns\n    \u2502   \u251c\u2500\u2500 var\n    \u2502   \u2502   \u2514\u2500\u2500 _index (8,) object\n    \u2502   \u251c\u2500\u2500 varm\n    \u2502   \u2514\u2500\u2500 varp\n    \u251c\u2500\u2500 expected_table_FOV_ROI_table_1_False_0_0\n    \u2502   \u251c\u2500\u2500 X (1504, 18) float32\n    \u2502   \u251c\u2500\u2500 layers\n    \u2502   \u251c\u2500\u2500 obs\n    \u2502   \u2502   \u251c\u2500\u2500 ROI_name (1504,) object\n    \u2502   \u2502   \u251c\u2500\u2500 ROI_table_name (1504,) object\n    \u2502   \u2502   \u251c\u2500\u2500 _index (1504,) int64\n    \u2502   \u2502   \u2514\u2500\u2500 label (1504,) int64\n    \u2502   \u251c\u2500\u2500 obsm\n    \u2502   \u251c\u2500\u2500 obsp\n    \u2502   \u251c\u2500\u2500 uns\n    \u2502   \u251c\u2500\u2500 var\n    \u2502   \u2502   \u2514\u2500\u2500 _index (18,) object\n    \u2502   \u251c\u2500\u2500 varm\n    \u2502   \u2514\u2500\u2500 varp\n    \u251c\u2500\u2500 expected_table_FOV_ROI_table_1_True_0_0\n    \u2502   \u251c\u2500\u2500 X (1504, 38) float32\n    \u2502   \u251c\u2500\u2500 layers\n    \u2502   \u251c\u2500\u2500 obs\n    \u2502   \u2502   \u251c\u2500\u2500 ROI_name (1504,) object\n    \u2502   \u2502   \u251c\u2500\u2500 ROI_table_name (1504,) object\n    \u2502   \u2502   \u251c\u2500\u2500 _index (1504,) int64\n    \u2502   \u2502   \u2514\u2500\u2500 label (1504,) int64\n    \u2502   \u251c\u2500\u2500 obsm\n    \u2502   \u251c\u2500\u2500 obsp\n    \u2502   \u251c\u2500\u2500 uns\n    \u2502   \u251c\u2500\u2500 var\n    \u2502   \u2502   \u2514\u2500\u2500 _index (38,) object\n    \u2502   \u251c\u2500\u2500 varm\n    \u2502   \u2514\u2500\u2500 varp\n    \u251c\u2500\u2500 expected_table_masked_nuclei_ROI_table_0_True_0_0\n    \u2502   \u251c\u2500\u2500 X (1493, 22) float32\n    \u2502   \u251c\u2500\u2500 layers\n    \u2502   \u251c\u2500\u2500 obs\n    \u2502   \u2502   \u251c\u2500\u2500 ROI_label (1493,) int64\n    \u2502   \u2502   \u251c\u2500\u2500 ROI_name (1493,) object\n    \u2502   \u2502   \u251c\u2500\u2500 ROI_table_name (1493,) object\n    \u2502   \u2502   \u251c\u2500\u2500 _index (1493,) int64\n    \u2502   \u2502   \u2514\u2500\u2500 label (1493,) int64\n    \u2502   \u251c\u2500\u2500 obsm\n    \u2502   \u251c\u2500\u2500 obsp\n    \u2502   \u251c\u2500\u2500 uns\n    \u2502   \u251c\u2500\u2500 var\n    \u2502   \u2502   \u2514\u2500\u2500 _index (22,) object\n    \u2502   \u251c\u2500\u2500 varm\n    \u2502   \u2514\u2500\u2500 varp\n    \u251c\u2500\u2500 expected_table_masked_nuclei_ROI_table_1_True_0_0\n    \u2502   \u251c\u2500\u2500 X (1493, 38) float32\n    \u2502   \u251c\u2500\u2500 layers\n    \u2502   \u251c\u2500\u2500 obs\n    \u2502   \u2502   \u251c\u2500\u2500 ROI_label (1493,) int64\n    \u2502   \u2502   \u251c\u2500\u2500 ROI_name (1493,) object\n    \u2502   \u2502   \u251c\u2500\u2500 ROI_table_name (1493,) object\n    \u2502   \u2502   \u251c\u2500\u2500 _index (1493,) int64\n    \u2502   \u2502   \u2514\u2500\u2500 label (1493,) int64\n    \u2502   \u251c\u2500\u2500 obsm\n    \u2502   \u251c\u2500\u2500 obsp\n    \u2502   \u251c\u2500\u2500 uns\n    \u2502   \u251c\u2500\u2500 var\n    \u2502   \u2502   \u2514\u2500\u2500 _index (38,) object\n    \u2502   \u251c\u2500\u2500 varm\n    \u2502   \u2514\u2500\u2500 varp\n    \u251c\u2500\u2500 expected_table_well_ROI_table_0_True_0_0\n    \u2502   \u251c\u2500\u2500 X (1493, 22) float32\n    \u2502   \u251c\u2500\u2500 layers\n    \u2502   \u251c\u2500\u2500 obs\n    \u2502   \u2502   \u251c\u2500\u2500 ROI_name (1493,) object\n    \u2502   \u2502   \u251c\u2500\u2500 ROI_table_name (1493,) object\n    \u2502   \u2502   \u251c\u2500\u2500 _index (1493,) int64\n    \u2502   \u2502   \u2514\u2500\u2500 label (1493,) int64\n    \u2502   \u251c\u2500\u2500 obsm\n    \u2502   \u251c\u2500\u2500 obsp\n    \u2502   \u251c\u2500\u2500 uns\n    \u2502   \u251c\u2500\u2500 var\n    \u2502   \u2502   \u2514\u2500\u2500 _index (22,) object\n    \u2502   \u251c\u2500\u2500 varm\n    \u2502   \u2514\u2500\u2500 varp\n    \u251c\u2500\u2500 expected_table_well_ROI_table_3_False_0_0\n    \u2502   \u251c\u2500\u2500 X (1493, 50) float32\n    \u2502   \u251c\u2500\u2500 layers\n    \u2502   \u251c\u2500\u2500 obs\n    \u2502   \u2502   \u251c\u2500\u2500 ROI_name (1493,) object\n    \u2502   \u2502   \u251c\u2500\u2500 ROI_table_name (1493,) object\n    \u2502   \u2502   \u251c\u2500\u2500 _index (1493,) int64\n    \u2502   \u2502   \u2514\u2500\u2500 label (1493,) int64\n    \u2502   \u251c\u2500\u2500 obsm\n    \u2502   \u251c\u2500\u2500 obsp\n    \u2502   \u251c\u2500\u2500 uns\n    \u2502   \u251c\u2500\u2500 var\n    \u2502   \u2502   \u2514\u2500\u2500 _index (50,) object\n    \u2502   \u251c\u2500\u2500 varm\n    \u2502   \u2514\u2500\u2500 varp\n    \u251c\u2500\u2500 expected_table_well_ROI_table_3_True_0_0\n    \u2502   \u251c\u2500\u2500 X (1493, 70) float32\n    \u2502   \u251c\u2500\u2500 layers\n    \u2502   \u251c\u2500\u2500 obs\n    \u2502   \u2502   \u251c\u2500\u2500 ROI_name (1493,) object\n    \u2502   \u2502   \u251c\u2500\u2500 ROI_table_name (1493,) object\n    \u2502   \u2502   \u251c\u2500\u2500 _index (1493,) int64\n    \u2502   \u2502   \u2514\u2500\u2500 label (1493,) int64\n    \u2502   \u251c\u2500\u2500 obsm\n    \u2502   \u251c\u2500\u2500 obsp\n    \u2502   \u251c\u2500\u2500 uns\n    \u2502   \u251c\u2500\u2500 var\n    \u2502   \u2502   \u2514\u2500\u2500 _index (70,) object\n    \u2502   \u251c\u2500\u2500 varm\n    \u2502   \u2514\u2500\u2500 varp\n    \u251c\u2500\u2500 nuclei\n    \u2502   \u251c\u2500\u2500 X (1493, 7) float32\n    \u2502   \u251c\u2500\u2500 layers\n    \u2502   \u251c\u2500\u2500 obs\n    \u2502   \u2502   \u251c\u2500\u2500 _index (1493,) int64\n    \u2502   \u2502   \u2514\u2500\u2500 label (1493,) object\n    \u2502   \u251c\u2500\u2500 obsm\n    \u2502   \u251c\u2500\u2500 obsp\n    \u2502   \u251c\u2500\u2500 uns\n    \u2502   \u251c\u2500\u2500 var\n    \u2502   \u2502   \u2514\u2500\u2500 _index (7,) object\n    \u2502   \u251c\u2500\u2500 varm\n    \u2502   \u2514\u2500\u2500 varp\n    \u251c\u2500\u2500 nuclei_ROI_table\n    \u2502   \u251c\u2500\u2500 X (1493, 6) float32\n    \u2502   \u251c\u2500\u2500 layers\n    \u2502   \u251c\u2500\u2500 obs\n    \u2502   \u2502   \u251c\u2500\u2500 _index (1493,) object\n    \u2502   \u2502   \u2514\u2500\u2500 label (1493,) object\n    \u2502   \u251c\u2500\u2500 obsm\n    \u2502   \u251c\u2500\u2500 obsp\n    \u2502   \u251c\u2500\u2500 uns\n    \u2502   \u251c\u2500\u2500 var\n    \u2502   \u2502   \u2514\u2500\u2500 _index (6,) object\n    \u2502   \u251c\u2500\u2500 varm\n    \u2502   \u2514\u2500\u2500 varp\n    \u2514\u2500\u2500 well_ROI_table\n        \u251c\u2500\u2500 X (1, 6) float32\n        \u251c\u2500\u2500 layers\n        \u251c\u2500\u2500 obs\n        \u2502   \u2514\u2500\u2500 FieldIndex (1,) object\n        \u251c\u2500\u2500 obsm\n        \u251c\u2500\u2500 obsp\n        \u251c\u2500\u2500 uns\n        \u251c\u2500\u2500 var\n        \u2502   \u2514\u2500\u2500 _index (6,) object\n        \u251c\u2500\u2500 varm\n        \u2514\u2500\u2500 varp\n</pre>"},{"location":"getting_started_Image/#extract-a-table-from-the-ome-zarr-image","title":"Extract a table from the OME-Zarr image","text":"<p>At the time of writing, tabular data is not yet covered in the NGFF standard. The tables stored within this OME-Zarr image are formatted as described in the Fractal documentation.</p> <p>As mentioned the goal of <code>ez_zarr</code> is to abstract the internal structure and make it simple to obtain these tables as a <code>pandas.DataFrame</code> :</p> <pre><code>df = img.get_table(table_name='FOV_ROI_table')\ndf\n</code></pre> FieldIndex x_micrometer y_micrometer z_micrometer len_x_micrometer len_y_micrometer len_z_micrometer x_micrometer_original y_micrometer_original FOV_1 0 0 0 416 351 1 -1448.3 -1517.7 FOV_2 416 0 0 416 351 1 -1032.3 -1517.7 <p>or <code>anndata.AnnData</code> object:</p> <pre><code>ann = img.get_table(table_name='FOV_ROI_table', as_AnnData=True)\nann\n</code></pre> <pre><code>AnnData object with n_obs \u00d7 n_vars = 2 \u00d7 8\n</code></pre>"},{"location":"getting_started_Image/#visualize-the-image","title":"Visualize the image","text":"<p><code>get_array_by_coordinate()</code> extracts a rectangular region of interest from an image by coordinates. If no coordinates or other arguments are given, it returns the whole image at the lowest available resolution:</p> <pre><code>arr = img.get_array_by_coordinate()\nprint(arr.shape) # (ch, z, y, x)\n</code></pre> <pre><code>(1, 1, 135, 320)\n</code></pre> <p>Such an image array can be easily plotted using <code>matplotlib.pyplot.imshow</code>:</p> <pre><code>with plt.style.context('dark_background'):\nfig = plt.figure(figsize=(4, 4))\nfig.set_dpi(100)\nplt.imshow(arr[0,0], cmap='gray', vmin=100, vmax=600)\nplt.title(img.name)\nplt.show()\nplt.close()\n</code></pre> <p></p> <p>With <code>plot()</code>, <code>ome_zarr.Image</code> provides a convenient function for this that automatically extracts the well image and plots it. Because it has access to the image metadata, it can also add for example a scale bar:</p> <pre><code>img.plot(channels=[0],\nchannel_colors=['white'],\nchannel_ranges=[[100, 600]],\ntitle=img.name,\nscalebar_micrometer=150,\nscalebar_color='yellow',\nscalebar_position='topleft',\nscalebar_label=True,\nfig_width_inch=5,\nfig_height_inch=4,\nfig_dpi=100)\n</code></pre> <p></p> <p><code>plot()</code> uses internally <code>ez_zarr.plotting.plot_image()</code> which is a convenient wrapper around <code>matplotlib.pyplot.imshow</code>. <code>plot_image()</code> can also be used directly if you want to work with image arrays (for examples, see section \u201cWorking with segmentation masks\u201d below).</p>"},{"location":"getting_started_Image/#zoom-in","title":"Zoom in","text":"<p>Let\u2019s first show the coordinate axes for our image:</p> <pre><code>img.plot(axis_style='micrometer',\nfig_width_inch=5,\nfig_height_inch=4,\nfig_dpi=100)\n</code></pre> <p></p> <p>Now we can zoom in by coordinates:</p> <pre><code>img.plot(upper_left_yx=(130, 140),\nlower_right_yx=(300, 310),\nscalebar_micrometer=30,\nscalebar_color='magenta',\nfig_width_inch=5,\nfig_height_inch=5,\nfig_dpi=100)\n</code></pre> <p></p> <p>So far, we have been automatically using the lowest resolution pyramid level version of the data, and the micrometer coordinates above have been automatically converted to the corresponding pixel coordinates.</p> <p>If we want to get the same image region at a higher resolution, we can use the <code>pyramid_level</code> argument:</p> <pre><code>img.plot(pyramid_level=0,\nupper_left_yx=(130, 140),\nlower_right_yx=(300, 310),\nscalebar_micrometer=30,\nscalebar_color='magenta',\nfig_width_inch=5,\nfig_height_inch=5,\nfig_dpi=100)\n</code></pre> <p></p> <p>You can see from the scale bar that again conversion from micrometer to pixel coordinates are performed automatically.</p> <p>If you prefer to work with pixel coordinates, for example for slicing numpy arrays, <code>get_array_by_coordinate</code> or <code>plot</code> also support that.</p> <p>Let\u2019s first look at the full image at low resolution again, now using pixel coordinates for the axes:</p> <pre><code>img.plot(axis_style='pixel',\nfig_width_inch=5,\nfig_height_inch=4,\nfig_dpi=100)\n</code></pre> <p></p> <p>Now we zoom in using pixel coordinates (<code>coordinate_unit='pixel'</code>):</p> <pre><code>img.plot(coordinate_unit='pixel',\nupper_left_yx=(50, 56),\nlower_right_yx=(115, 121),\nscalebar_micrometer=30,\nscalebar_color='magenta',\nfig_width_inch=5,\nfig_height_inch=5,\nfig_dpi=100)\n</code></pre> <p></p> <p>Again, we were automatically using the lowest resolution of the image, and we can use <code>pyramid_level</code> to select a higher resolution. When working with pixel coordinates, we will need to specify that our coordinates still refer to the currently selected <code>pyramid_level</code> (4), in order to obtain the same region of the image. This can be done using the <code>pyramid_level_coord</code> argument:</p> <pre><code>img.plot(coordinate_unit='pixel',\npyramid_level=0,       # extract image from this level\npyramid_level_coord=4, # coordinates refer to this level\nupper_left_yx=(50, 56),\nlower_right_yx=(115, 121),\nscalebar_micrometer=30,\nscalebar_color='magenta',\nfig_width_inch=5,\nfig_height_inch=5,\nfig_dpi=100)\n</code></pre> <p></p>"},{"location":"getting_started_Image/#coordinate-conversions-usually-done-internally","title":"Coordinate conversions (usually done internally)","text":"<p>As mentioned the pixel coordinates depend on the <code>pyramid_level</code>. The image metadata makes it easy to convert between pixel coordinates and micrometer coordinates, or pixel coordinates referring to different pyramid levels. The <code>get_array_by_coordinate</code> and <code>plot</code> methods do this automatically.</p> <p>You can do it also manually by using <code>get_scale</code> to obtain the pixel sizes (in micrometer) from the image metadata, and <code>ez_zarr.utils.convert_coordinates</code> to do the actual conversion:</p> <pre><code># let's define some pixel coordinates referring to pyramid level 4\nzyx_4 = (1, 230, 180)\nprint(f'starting coordinates (pixels in pyramid level 4): {zyx_4}')\n# get pixel scale at pyramid level 4 (z, y, x)\ns_4 = img.get_scale(pyramid_level=4, spatial_axes_only=True)\nprint(f'pixel scale (pyramid level 4, micrometer): {s_4}')\n# convert from pyramid level 4 to 2\ns_2 = img.get_scale(pyramid_level=2, spatial_axes_only=True)\nprint(f'pixel scale (pyramid level 2, micrometer): {s_2}')\nzyx_2 = utils.convert_coordinates(coords_from=zyx_4,\nscale_from=s_4,\nscale_to=s_2)\nprint(f'starting coordinates converted to pyramid level 2 (pixel): {zyx_2}')\n# convert from pixel to micrometers\n# remark: scales are in micrometer -&gt; the target scale is 1.0 for each axis\nzyx_um = utils.convert_coordinates(coords_from=zyx_4,\nscale_from=s_4,\nscale_to=[1.0, 1.0, 1.0])\nprint(f'starting coordinates converted to micrometer: {zyx_um}')\n# convert back from micrometers to pixels\nzyx_px = utils.convert_coordinates(coords_from=zyx_um,\nscale_from=[1.0, 1.0, 1.0],\nscale_to=s_4)\nprint(f'starting coordinates converted back to pixel (pyramid level 4): {zyx_px}')\n</code></pre> <pre><code>starting coordinates (pixels in pyramid level 4): (1, 230, 180)\npixel scale (pyramid level 4, micrometer): [1.0, 2.6, 2.6]\npixel scale (pyramid level 2, micrometer): [1.0, 0.65, 0.65]\nstarting coordinates converted to pyramid level 2 (pixel): (1.0, 920.0, 720.0)\nstarting coordinates converted to micrometer: (1.0, 598.0, 468.0)\nstarting coordinates converted back to pixel (pyramid level 4): (1.0, 230.0, 180.0)\n</code></pre> <p>These functions are also used by <code>plot()</code> internally to add a scale bar to the image plot, as we have seen above.</p>"},{"location":"getting_started_Image/#working-with-segmentation-masks","title":"Working with segmentation masks","text":"<p>When segmentation masks (labels) are available, we can for example plot them with transparency on top of the image, by selecting the desired label using <code>label_name</code>:</p> <pre><code>img.plot(label_name='nuclei',\npyramid_level=0,\nupper_left_yx=(130, 140),\nlower_right_yx=(300, 310),\nscalebar_micrometer=30,\nscalebar_color='white',\nfig_width_inch=5,\nfig_height_inch=5,\nfig_dpi=100)\n</code></pre> <pre><code>/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/ez_zarr/ome_zarr.py:944: UserWarning: For the requested pyramid level (0) of the intensity image, no matching label ('nuclei') is available. Up-scaling the label using factor(s) [1. 4. 4.]\n  warnings.warn(f\"For the requested pyramid level ({pyramid_level}) of the intensity image, no matching label ('{lname}') is available. Up-scaling the label using factor(s) {scalefact_yx}\")\n</code></pre> <p></p> <p>You may notice that the above will warn about no labels being available for the requested intensity image pyramid level. The <code>plot</code> method will automatically use the label with the closest resolution and scale it to match the intensity image.</p> <p>For your convenience, it is also possible to specify multiple label names using a <code>list</code> (for example to reuse the same label name list when working with multiple images that have different labels). <code>plot()</code> will still only display a single label mask, namely the first one in the provided list that is available for the image (so the order of label names matters):</p> <pre><code>img.plot(label_name=['whole_cells', 'nuclei', 'mitochondria'],\npyramid_level=0,\nupper_left_yx=(130, 140),\nlower_right_yx=(300, 310),\nscalebar_micrometer=30,\nscalebar_color='white',\nfig_width_inch=5,\nfig_height_inch=5,\nfig_dpi=100)\n</code></pre> <pre><code>Using label_name='nuclei' for image cardio-d14\n\n/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/ez_zarr/ome_zarr.py:944: UserWarning: For the requested pyramid level (0) of the intensity image, no matching label ('nuclei') is available. Up-scaling the label using factor(s) [1. 4. 4.]\n  warnings.warn(f\"For the requested pyramid level ({pyramid_level}) of the intensity image, no matching label ('{lname}') is available. Up-scaling the label using factor(s) {scalefact_yx}\")\n</code></pre> <p></p> <p>Using the <code>show_label_values</code> argument of <code>plotting.plot_image</code>, the label values can be added (optionally also using the <code>label_fontsize</code> and <code>label_text_colour</code> argument to ):</p> <pre><code>img.plot(show_label_values=True,\nlabel_fontsize='small',\nlabel_text_colour='white',\nlabel_name='nuclei',\npyramid_level=0,\nupper_left_yx=(130, 140),\nlower_right_yx=(300, 310),\nfig_width_inch=5,\nfig_height_inch=5,\nfig_dpi=100)\n</code></pre> <pre><code>/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/ez_zarr/ome_zarr.py:944: UserWarning: For the requested pyramid level (0) of the intensity image, no matching label ('nuclei') is available. Up-scaling the label using factor(s) [1. 4. 4.]\n  warnings.warn(f\"For the requested pyramid level ({pyramid_level}) of the intensity image, no matching label ('{lname}') is available. Up-scaling the label using factor(s) {scalefact_yx}\")\n</code></pre> <p></p> <p>If you are interested in a specific object, you can pass its value to the <code>label_value</code> argument (and optionally use the <code>extend_pixels</code> and <code>msk_alpha</code> arguments), to automatically select appropriate coordinates:</p> <pre><code>img.plot(label_value=877,\nextend_pixels=10,\nmsk_alpha=0.15,\nshow_label_values=True,\nlabel_fontsize='xx-large',\nlabel_text_colour='black',\nlabel_name='nuclei',\npyramid_level=0,\nfig_width_inch=5,\nfig_height_inch=5,\nfig_dpi=100)\n</code></pre> <pre><code>/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/ez_zarr/ome_zarr.py:944: UserWarning: For the requested pyramid level (0) of the intensity image, no matching label ('nuclei') is available. Up-scaling the label using factor(s) [1. 4. 4.]\n  warnings.warn(f\"For the requested pyramid level ({pyramid_level}) of the intensity image, no matching label ('{lname}') is available. Up-scaling the label using factor(s) {scalefact_yx}\")\n</code></pre> <p></p> <p>For performance reasons, the bounding box for an object given by <code>label_value</code> is calculated on the lowest-resolution label image by default. This may lead to imprecise results, as here where the lower part of object 877 is truncated. To improve the precision of the bounding box calculation, you can manually select the pyramid level to be used, using the argument <code>label_pyramid_level</code>:</p> <pre><code>img.plot(label_value=877,\nlabel_pyramid_level='2',\nextend_pixels=10,\nmsk_alpha=0.15,\nshow_label_values=True,\nlabel_fontsize='xx-large',\nlabel_text_colour='black',\nlabel_name='nuclei',\npyramid_level=0,\nfig_width_inch=5,\nfig_height_inch=5,\nfig_dpi=100)\n</code></pre> <pre><code>/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/ez_zarr/ome_zarr.py:944: UserWarning: For the requested pyramid level (0) of the intensity image, no matching label ('nuclei') is available. Up-scaling the label using factor(s) [1. 4. 4.]\n  warnings.warn(f\"For the requested pyramid level ({pyramid_level}) of the intensity image, no matching label ('{lname}') is available. Up-scaling the label using factor(s) {scalefact_yx}\")\n</code></pre> <p></p> <p>If you want to restrict the plot to the exact are within that specific object (or objects), you can use the <code>restrict_to_label_values</code> argument and provide a list of values:</p> <pre><code>img.plot(label_value=877,\nlabel_pyramid_level='2',\nrestrict_to_label_values=[877,914],\nextend_pixels=10,\nmsk_alpha=0.15,\nshow_label_values=True,\nlabel_fontsize='xx-large',\nlabel_text_colour='black',\nlabel_name='nuclei',\npyramid_level=0,\nfig_width_inch=5,\nfig_height_inch=5,\nfig_dpi=100)\n</code></pre> <pre><code>/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/ez_zarr/ome_zarr.py:944: UserWarning: For the requested pyramid level (0) of the intensity image, no matching label ('nuclei') is available. Up-scaling the label using factor(s) [1. 4. 4.]\n  warnings.warn(f\"For the requested pyramid level ({pyramid_level}) of the intensity image, no matching label ('{lname}') is available. Up-scaling the label using factor(s) {scalefact_yx}\")\n</code></pre> <p></p>"},{"location":"getting_started_Image/#calculations-on-the-image-data","title":"Calculations on the image data","text":"<p>Let\u2019s obtain again the intensity image data in the form of an array:</p> <pre><code>arr = img.get_array_by_coordinate()\n</code></pre> <p>To save memory, images are stored on disk and only loaded when needed (for implementation details see the <code>dask</code> Array documentation).</p> <p>This can be demonstrated by <code>type(arr)</code> and <code>sys.getsizeof(arr)</code>:</p> <pre><code># note that the image is an 'on-disk' array\ntype(arr)\n</code></pre> <pre><code>zarr.core.array.Array\n</code></pre> <pre><code>sys.getsizeof(arr)\n</code></pre> <pre><code>56\n</code></pre> <p>To force loading of the data into memory as a <code>numpy</code> array, you can call <code>np.array(arr)</code>:</p> <pre><code>ndarr = np.array(arr) # triggers loading it into memory\ntype(np.array(ndarr))\n</code></pre> <pre><code>numpy.ndarray\n</code></pre> <pre><code>sys.getsizeof(ndarr)\n</code></pre> <pre><code>86560\n</code></pre> <p>In general, you can use <code>dask</code> arrays like <code>numpy</code> arrays. For example, we can threshold the image:</p> <pre><code># threshold (will also trigger loading into memory)\narr_mask = arr[0,0]&gt;300\ntype(arr_mask)\n</code></pre> <pre><code>numpy.ndarray\n</code></pre> <pre><code># plot \nplotting.plot_image(im=arr[:,0], msk=arr_mask, msk_alpha=0.5,\nfig_width_inch=6, fig_height_inch=6, fig_dpi=100)\n</code></pre> <p></p> <p>This is of course not a recommended way to segment this image, but rather meant to demonstrate that the <code>dask</code> arrays can be used just like <code>numpy</code> arrays.</p> <p>Extracting arrays and plotting them directly with <code>plotting.plot_image</code> is also the recommended way to do more complex tasks that are not directly supported by the arguments in <code>Image.plot</code>. For example, you could subset a 3D image to select just one or several z-planes of interest, instead of using the automated projection (<code>z_projection_method</code> argument of <code>plotting.plot_image</code>).</p>"},{"location":"getting_started_Image/#working-with-images-with-time-dimension","title":"Working with images with time dimension","text":"<p>Images that include a time dimension can also be handled using <code>ez_zarr</code>. For plotting such images, you have to specify which time index to plot.</p> <p>For illustration, we first download a small example image (showing a tubulin histone GFP coexpressing C. elegans embryo) that is part of the <code>ez_zarr</code> GitHub repository. The original data set was acquired on a multiphoton workstation by Josh Bembenek, and is freely available from openmicroscopy.org. The data set included in <code>ez_zarr</code> is a subset of the original image (2 timepoints, 1 channel, 2 z-planes). In addition, a manual segmentation label was added for illustration purposes.</p> <pre><code># download an image with a time axis\nurl = \"https://github.com/fmicompbio/ez_zarr/archive/refs/heads/main.zip\"\nwith tempfile.TemporaryDirectory() as temp_dir:\nresponse = requests.get(url)\nresponse.raise_for_status()  # raise an error if the request fails\n# download\ntemp_zip_file = os.path.join(temp_dir, 'temp.zip')\nwith open(temp_zip_file, 'wb') as temp_zip:\ntemp_zip.write(response.content)\n# unzip to current directory\nwith zipfile.ZipFile(temp_zip_file, 'r') as zip_ref:\nzip_ref.extractall(temp_dir)\n# locate the extracted folder\nextracted_folder = os.path.join(temp_dir, \"ez_zarr-main\", \"tests\",\n\"example_data_5d\")\n# move the image to current working directory\nif os.path.exists(extracted_folder):\nshutil.copytree(extracted_folder, \".\", dirs_exist_ok=True)\n</code></pre> <p>Now we open the image:</p> <pre><code>img5d = ome_zarr.Image(\"tubhiswt4D_sub.zarr\")\nimg5d.channel_info_image\n</code></pre> <pre><code>'tczyx'\n</code></pre> <p>The time axis contains three entries:</p> <pre><code>print(img5d.tree(level=3))\n</code></pre> <pre>/\n\u251c\u2500\u2500 0 (3, 1, 2, 512, 512) uint8\n\u251c\u2500\u2500 1 (3, 1, 2, 256, 256) uint8\n\u251c\u2500\u2500 2 (3, 1, 2, 128, 128) uint8\n\u2514\u2500\u2500 labels\n    \u2514\u2500\u2500 embryo\n        \u251c\u2500\u2500 0 (3, 2, 512, 512) uint8\n        \u251c\u2500\u2500 1 (3, 2, 256, 256) uint8\n        \u2514\u2500\u2500 2 (3, 2, 128, 128) uint8\n</pre> <p>We can plot selected timepoints by specifying the <code>time_index</code> argument of <code>Image.plot()</code>:</p> <pre><code>img5d.plot(time_index=0,\npyramid_level=0,\nlabel_name=\"embryo\",\nfig_width_inch=6,\nfig_height_inch=6,\nfig_dpi=100)\n</code></pre> <p></p>"},{"location":"getting_started_Image/#working-with-multiple-images","title":"Working with multiple images","text":"<p>In some cases, you may want to handle a set of images, such as images corresponding to the well of an high-content screening plate. Such data is represented in <code>ez_zarr</code> by <code>ome_zarr.ImageList</code> objects, and can be created from a folder containing multiple images using the <code>ome_zarr.import_plate</code> function:</p> <pre><code>img_directory = '20200812-CardiomyocyteDifferentiation14-Cycle1_mip.zarr'\nimgL = ome_zarr.import_plate(img_directory)\nimgL\n</code></pre> <pre><code>/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/zarr/core/group.py:3530: ZarrUserWarning: Object at .DS_Store is not recognized as a component of a Zarr hierarchy.\n  warnings.warn(\n/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/zarr/core/group.py:3530: ZarrUserWarning: Object at empty_well_ROI_table_0_True_0_0 is not recognized as a component of a Zarr hierarchy.\n  warnings.warn(\n/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/zarr/core/group.py:3530: ZarrUserWarning: Object at empty_well_ROI_table_1_True_0_0 is not recognized as a component of a Zarr hierarchy.\n  warnings.warn(\n/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/zarr/core/group.py:3530: ZarrUserWarning: Object at empty_well_ROI_table_1_False_0_0 is not recognized as a component of a Zarr hierarchy.\n  warnings.warn(\n/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/zarr/core/group.py:3530: ZarrUserWarning: Object at table_overwrite_True is not recognized as a component of a Zarr hierarchy.\n  warnings.warn(\n/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/zarr/core/group.py:3530: ZarrUserWarning: Object at table_well_ROI_table_3_False_0_0 is not recognized as a component of a Zarr hierarchy.\n  warnings.warn(\n/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/zarr/core/group.py:3530: ZarrUserWarning: Object at table_FOV_ROI_table_1_False_0_0 is not recognized as a component of a Zarr hierarchy.\n  warnings.warn(\n/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/zarr/core/group.py:3530: ZarrUserWarning: Object at table_well_ROI_table_3_True_0_0 is not recognized as a component of a Zarr hierarchy.\n  warnings.warn(\n/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/zarr/core/group.py:3530: ZarrUserWarning: Object at table_masked_nuclei_ROI_table_0_True_0_0 is not recognized as a component of a Zarr hierarchy.\n  warnings.warn(\n/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/zarr/core/group.py:3530: ZarrUserWarning: Object at table_masked_nuclei_ROI_table_1_True_0_0 is not recognized as a component of a Zarr hierarchy.\n  warnings.warn(\n/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/zarr/core/group.py:3530: ZarrUserWarning: Object at empty_well_ROI_table_0_False_0_0 is not recognized as a component of a Zarr hierarchy.\n  warnings.warn(\n/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/zarr/core/group.py:3530: ZarrUserWarning: Object at table_FOV_ROI_table_1_True_0_0 is not recognized as a component of a Zarr hierarchy.\n  warnings.warn(\n/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/zarr/core/group.py:3530: ZarrUserWarning: Object at table_overwrite_False is not recognized as a component of a Zarr hierarchy.\n  warnings.warn(\n/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/zarr/core/group.py:3530: ZarrUserWarning: Object at table_well_ROI_table_0_True_0_0 is not recognized as a component of a Zarr hierarchy.\n  warnings.warn(\n\nImageList of 1 images\n  paths: 20200812-CardiomyocyteDifferentiation14-Cycle1_mip.zarr/B/03/0\n  names: B03\n</code></pre> <p>Note that as our example data only contains a single well, this image list contains only a single image.</p> <pre><code>len(imgL)\n</code></pre> <pre><code>1\n</code></pre> <p>All methods available to <code>ome_zarr.Image</code> can also be used for <code>ome_zarr.ImageList</code> objects, and some have special behavior, for example the plot method that arranges the wells in plate layout (automatically determined to be compatible with the observed wells):</p> <pre><code>imgL.plot()\n</code></pre> <p></p> <p>The detected layout can be returned as a <code>pandas.DataFrame</code>:</p> <pre><code>imgL.get_layout()\n</code></pre> row_index column_index 0 2 3 <p>\u2026 and also set manually:</p> <pre><code>layout_df = pd.DataFrame.from_dict({'row_index': [1], 'column_index': [1]})\nimgL.set_layout(layout_df)\nimgL.plot()\n</code></pre> <p></p>"},{"location":"getting_started_Image/#session-info","title":"Session info","text":"<pre><code>import session_info\nsession_info.show()\n</code></pre> <pre><code>/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/session_info/main.py:213: UserWarning: The '__version__' attribute is deprecated and will be removed in MarkupSafe 3.1. Use feature detection, or `importlib.metadata.version(\"markupsafe\")`, instead.\n  mod_version = _find_version(mod.__version__)\n</code></pre> Click to view session information <pre>\n-----\nanndata             0.12.2\nez_zarr             0.4.2\nmatplotlib          3.8.2\nnumpy               1.26.4\npandas              2.3.2\nrequests            2.32.5\nsession_info        1.0.0\nskimage             0.22.0\nzarr                3.1.3\n-----\n</pre> Click to view modules imported as dependencies <pre>\nPIL                         11.3.0\nanyio                       NA\narrow                       1.3.0\nasttokens                   NA\nattr                        25.3.0\nattrs                       25.3.0\nbabel                       2.17.0\ncertifi                     2025.08.03\ncharset_normalizer          3.4.3\ncloudpickle                 3.1.1\ncomm                        0.2.3\ncrc32c                      NA\ncycler                      0.12.1\ncython_runtime              NA\ndask                        2025.9.1\ndateutil                    2.9.0.post0\ndebugpy                     1.8.17\ndecorator                   5.2.1\ndefusedxml                  0.7.1\ndonfig                      0.8.1.post1\nexecuting                   2.2.1\nfastjsonschema              NA\nfqdn                        NA\nfsspec                      2025.9.0\nh5py                        3.14.0\nidna                        3.10\nimportlib_metadata          NA\nipykernel                   6.30.1\nisoduration                 NA\njedi                        0.19.2\njinja2                      3.1.6\njson5                       0.12.1\njsonpointer                 3.0.0\njsonschema                  4.25.1\njsonschema_specifications   NA\njupyter_events              0.12.0\njupyter_server              2.17.0\njupyterlab_server           2.27.3\nkiwisolver                  1.4.9\nlark                        1.2.2\nlazy_loader                 0.4\nlegacy_api_wrap             NA\nmarkupsafe                  3.0.2\nmatplotlib_inline           0.1.7\nmpl_toolkits                NA\nnatsort                     8.4.0\nnbformat                    5.10.4\nnumcodecs                   0.16.3\noverrides                   NA\npackaging                   25.0\nparso                       0.8.5\nplatformdirs                4.4.0\nprometheus_client           NA\nprompt_toolkit              3.0.52\npsutil                      7.1.0\npure_eval                   0.2.3\npydev_ipython               NA\npydevconsole                NA\npydevd                      3.2.3\npydevd_file_utils           NA\npydevd_plugins              NA\npydevd_tracing              NA\npygments                    2.19.2\npyparsing                   3.2.5\npythonjsonlogger            NA\npytz                        2025.2\nreferencing                 NA\nrfc3339_validator           0.1.4\nrfc3986_validator           0.1.1\nrfc3987_syntax              NA\nrich                        NA\nrpds                        NA\nscipy                       1.16.2\nsend2trash                  NA\nsix                         1.17.0\nsniffio                     1.3.1\nstack_data                  0.6.3\ntabulate                    0.9.0\ntesting                     NA\ntlz                         1.0.0\ntoolz                       1.0.0\ntornado                     6.5.2\ntraitlets                   5.14.3\ntyping_extensions           NA\nuri_template                NA\nurllib3                     2.5.0\nwcwidth                     0.2.13\nwebcolors                   NA\nwebsocket                   1.8.0\nyaml                        6.0.2\nzipp                        NA\nzmq                         27.1.0\nzoneinfo                    NA\n</pre> <pre>\n-----\nIPython             9.5.0\njupyter_client      8.6.3\njupyter_core        5.8.1\njupyterlab          4.4.7\nnotebook            7.4.5\n-----\nPython 3.11.13 (main, Jun  4 2025, 04:12:12) [GCC 13.3.0]\nLinux-6.11.0-1018-azure-x86_64-with-glibc2.39\n-----\nSession information updated at 2025-09-22 12:38\n</pre>"},{"location":"getting_started_hcs_wrappers/","title":"Using <code>ez_zarr</code> to explore Fractal outputs","text":"<p>Silvia Barbiero, Michael Stadler</p> <ul> <li>Disclaimer</li> <li>Goal</li> <li>Installation</li> <li>Quickstart<ul> <li>Download example data</li> <li>Load packages</li> <li>Open OME-Zarr file set</li> <li>Get information from <code>plate</code></li> <li>Extract a table from the OME-Zarr     fileset</li> <li>Get an overview of a full     well</li> <li>Get salient regions at higher     resolution</li> <li>Zoom in</li> <li>Coordinate conversions</li> <li>Working with segmentation     masks</li> <li>Calculations on the image     data</li> </ul> </li> <li>Session info</li> </ul>"},{"location":"getting_started_hcs_wrappers/#disclaimer","title":"Disclaimer","text":"<p>The <code>hcs_wrappers</code> module described here is only provided for legacy reasons and not being further developed. For new projects, we recommend to use the <code>ome_zarr</code> module instead (see getting started with individual images).</p>"},{"location":"getting_started_hcs_wrappers/#goal","title":"Goal","text":"<p>The aim of <code>ez_zarr</code> is to provide easy, high-level access to high content screening microscopy data, stored as OME-Zarr filesets according to the NGFF specifications with additional metadata fields, for example the ones generated by the Fractal platform.</p> <p>The goal is that users can write simple scripts working with plates, wells and fields of view, without having to understand how these are represented within an OME-Zarr fileset.</p>"},{"location":"getting_started_hcs_wrappers/#installation","title":"Installation","text":"<p><code>ez_zarr</code> is hosted on GitHub at github.com/fmicompbio/ez_zarr and the documentation can be found at fmicompbio.github.io/ez_zarr.</p> <p>The release version of <code>ez_zarr</code> can be installed using:</p> <pre><code>pip install ez-zarr\n</code></pre> <p>The current (development) version of <code>ez_zarr</code> can be installed from github.com using:</p> <pre><code>pip install git+ssh://git@github.com/fmicompbio/ez_zarr.git\n</code></pre>"},{"location":"getting_started_hcs_wrappers/#quickstart","title":"Quickstart","text":"<p>Note: If you prefer to run these examples interactively, you can also download them as an ipynb notebook.</p> <p>Here are some examples of how you can use <code>ez_zarr</code>:</p>"},{"location":"getting_started_hcs_wrappers/#download-example-data","title":"Download example data","text":"<p>To run the code below, you will first need to download some Fractal output data. You can do this for example by running the following from a terminal:</p> <pre><code># Download small Fractal output from Zenodo\ncurl -o temp.zip https://zenodo.org/records/10519143/files/20200812-CardiomyocyteDifferentiation14-Cycle1_mip.zarr.zip\n\n# Unzip and remove the temporary zip file\nunzip temp.zip\nrm temp.zip\n</code></pre> <p>or directly from within a python notebook or session using:</p> <pre><code>import requests\nimport zipfile\nimport os\n# for info on data see: https://zenodo.org/records/10257149\nurl = 'https://zenodo.org/records/10519143/files/20200812-CardiomyocyteDifferentiation14-Cycle1_mip.zarr.zip'\n# download\nresponse = requests.get(url)\nwith open('temp.zip', 'wb') as temp_zip:\ntemp_zip.write(response.content)\n# unzip to current directory\nwith zipfile.ZipFile('temp.zip', 'r') as zip_ref:\nzip_ref.extractall('.')\n# clean up\nos.remove('temp.zip')\n</code></pre>"},{"location":"getting_started_hcs_wrappers/#load-packages","title":"Load packages","text":"<pre><code>import matplotlib.pyplot as plt\nfrom matplotlib.colors import ListedColormap\nimport numpy as np\nfrom skimage import color\nfrom ez_zarr import hcs_wrappers, plotting\n</code></pre>"},{"location":"getting_started_hcs_wrappers/#open-ome-zarr-file-set","title":"Open OME-Zarr file set","text":"<p>We open a single OME-Zarr directory, typically representing a single plate:</p> <pre><code>zarr_directory = '20200812-CardiomyocyteDifferentiation14-Cycle1_mip.zarr'\nplate = hcs_wrappers.FractalZarr(zarr_directory, name = 'cardio-d14')\nplate\n</code></pre> <pre><code>FractalZarr cardio-d14\n  path: 20200812-CardiomyocyteDifferentiation14-Cycle1_mip.zarr\n  n_wells: 1\n  n_channels: 1 (DAPI)\n  n_pyramid_levels: 5\n  pyramid_zyx_scalefactor: {'0': array([1., 2., 2.])}\n  full_resolution_zyx_spacing (\u00b5m): [1.0, 0.1625, 0.1625]\n  segmentations: nuclei, empty\n  tables (measurements): FOV_ROI_table, well_ROI_table, nuclei_ROI_table, nuclei, expected_table_well_ROI_table_False_0_0, expected_table_well_ROI_table_True_0_0, expected_table_FOV_ROI_table_False_0_0, expected_table_FOV_ROI_table_True_0_0, expected_table_well_ROI_table_0_True_0_0, expected_table_masked_nuclei_ROI_table_0_True_0_0, expected_table_masked_nuclei_ROI_table_1_True_0_0\n</code></pre> <p><code>plate</code> represents a maximum intensity projection of an acquisition with 1 well and 1 channel.</p> <p>There are 5 <code>pyramid_levels</code> available (0 to 4), meaning that in addition to the full resolution data (level 0), we have four more levels that provide the data in 2-fold lower resolutions (see <code>pyramid_zyx_scalefactor</code>), for example for faster plotting.</p> <p>This OME-Zarr fileset also contains a segmentation (<code>nuclei</code>), for which measurements have been extracted and saved in the table <code>nuclei</code>. In addition, there are some further tables, such as <code>FOV_ROI_table</code>, which contains the coordinates of the fields of view, or <code>nuclei_ROI_table</code>, which contains the bounding box coordinates for the segmented nuclei.</p>"},{"location":"getting_started_hcs_wrappers/#get-information-from-plate","title":"Get information from <code>plate</code>","text":"<p>You can obtain information on the content available in the fileset:</p> <pre><code># path to the OME-Zarr fileset\nplate.get_path()\n</code></pre> <pre><code>'20200812-CardiomyocyteDifferentiation14-Cycle1_mip.zarr'\n</code></pre> <pre><code># available channels\nplate.get_channels()\n</code></pre> <pre><code>[{'color': '00FFFF',\n  'label': 'DAPI',\n  'wavelength_id': 'A01_C01',\n  'window': {'end': 800, 'max': 65535, 'min': 0, 'start': 110}}]\n</code></pre> <pre><code># available wells\nplate.get_wells()\nplate.get_wells(simplify=True)\n</code></pre> <pre><code>['B03']\n</code></pre> <pre><code># available labels\nplate.get_label_names()\n</code></pre> <pre><code>['nuclei', 'empty']\n</code></pre> <pre><code># available tables\nplate.get_table_names()\n</code></pre> <pre><code>['FOV_ROI_table',\n 'well_ROI_table',\n 'nuclei_ROI_table',\n 'nuclei',\n 'expected_table_well_ROI_table_False_0_0',\n 'expected_table_well_ROI_table_True_0_0',\n 'expected_table_FOV_ROI_table_False_0_0',\n 'expected_table_FOV_ROI_table_True_0_0',\n 'expected_table_well_ROI_table_0_True_0_0',\n 'expected_table_masked_nuclei_ROI_table_0_True_0_0',\n 'expected_table_masked_nuclei_ROI_table_1_True_0_0']\n</code></pre> <pre><code># zyx pixel spacing in micrometers for pyramid levels\n# ... for images\nplate.level_zyx_spacing_images\n</code></pre> <pre><code>{'0': [[1.0, 0.1625, 0.1625],\n  [1.0, 0.325, 0.325],\n  [1.0, 0.65, 0.65],\n  [1.0, 1.3, 1.3],\n  [1.0, 2.6, 2.6]]}\n</code></pre> <pre><code># ... for labels\nplate.level_zyx_spacing_labels\n</code></pre> <pre><code>{'nuclei': [[1.0, 0.65, 0.65],\n  [1.0, 1.3, 1.3],\n  [1.0, 2.6, 2.6],\n  [1.0, 5.2, 5.2],\n  [1.0, 10.4, 10.4]],\n 'empty': [[1.0, 0.65, 0.65],\n  [1.0, 1.3, 1.3],\n  [1.0, 2.6, 2.6],\n  [1.0, 5.2, 5.2],\n  [1.0, 10.4, 10.4]]}\n</code></pre>"},{"location":"getting_started_hcs_wrappers/#extract-a-table-from-the-ome-zarr-fileset","title":"Extract a table from the OME-Zarr fileset","text":"<p>The tables are stored within the fileset as described in the Fractal documentation.</p> <p>As mentioned the goal of <code>ez_zarr</code> is to abstract the internal structure and make it simple to obtain these tables, if necessary accumulated over many wells, as a <code>pandas.DataFrame</code> :</p> <pre><code>df = plate.get_table(table_name='FOV_ROI_table')\ndf\n</code></pre> FieldIndex well x_micrometer y_micrometer z_micrometer len_x_micrometer len_y_micrometer len_z_micrometer x_micrometer_original y_micrometer_original FOV_1 B03 0 0 0 416 351 1 -1448.3 -1517.7 FOV_2 B03 416 0 0 416 351 1 -1032.3 -1517.7 <p>or <code>anndata.AnnData</code> object:</p> <pre><code>ann = plate.get_table(table_name='FOV_ROI_table', as_AnnData=True)\nann\n</code></pre> <pre><code>AnnData object with n_obs \u00d7 n_vars = 2 \u00d7 8\n    obs: 'well'\n</code></pre>"},{"location":"getting_started_hcs_wrappers/#get-an-overview-of-a-full-well","title":"Get an overview of a full well","text":"<p><code>get_image_ROI()</code> extracts a rectangular region of interest (ROI) from a well image by coordinates. If no coordinates or other arguments are given, it returns the whole well at the lowest available resolution:</p> <pre><code>my_well = plate.get_wells(simplify=True)[0]\nprint(my_well)\nimg = plate.get_image_ROI()\nprint(img.shape) # (ch, z, y, x)\n</code></pre> <pre><code>B03\n(1, 1, 135, 320)\n</code></pre> <p>Such an image array can be easily plotted using <code>matplotlib.pyplot.imshow</code>:</p> <pre><code>with plt.style.context('dark_background'):\nfig = plt.figure(figsize=(4, 4))\nfig.set_dpi(100)\nplt.imshow(img[0,0], cmap='gray', vmin=100, vmax=600)\nplt.title(plate.name + ' ' + my_well)\nplt.show()\nplt.close()\n</code></pre> <p></p> <p>With <code>plot_well()</code>, <code>ez_zarr</code> provides a convenient function for this use case that automatically extracts the well image and plots it. Because it has access to the image metadata, it can also add for example a scale bar:</p> <pre><code>plate.plot_well(well=my_well,\nchannels=[0],\nchannel_colors=['white'],\nchannel_ranges=[[100, 600]],\ntitle=plate.name + ' ' + my_well,\nscalebar_micrometer=150,\nscalebar_color='yellow',\nscalebar_position='topleft',\nscalebar_label=True,\nfig_width_inch=5,\nfig_height_inch=4,\nfig_dpi=100)\n</code></pre> <p></p> <p><code>plot_well()</code> and also <code>plot_plate()</code> use internally <code>ez_zarr.plotting.plot_image()</code> which is a convenient wrapper around <code>matplotlib.pyplot.imshow</code>. <code>plot_image()</code> can also be used directly if you want to work with image arrays (for examples, see section \u201cWorking with segmentation masks\u201d below).</p>"},{"location":"getting_started_hcs_wrappers/#get-salient-regions-at-higher-resolution","title":"Get salient regions at higher resolution","text":"<p><code>get_image_grid_ROIs()</code> allows you to split the well image into a rectangular grid of <code>num_x</code>-by-<code>num_y</code> regions, and automatically select the <code>num_select</code> top regions based on a given property (<code>sample_method</code>).</p> <p>Here, we pick three regions with the highest signal in channel zero (DAPI):</p> <pre><code>coord_list, img_list = plate.get_image_grid_ROIs(well = my_well,\npyramid_level=1,\nnum_x=10, num_y=5, num_select=3,\nsample_method='sum',\nchannel=0)\nprint(coord_list) # list of (y_start, y_end, x_start, x_end)\nprint(len(img_list))\nwith plt.style.context('dark_background'):\nfig = plt.figure(figsize=(9,3))\nfig.set_dpi(100)\nfor i in range(len(img_list)):\nplt.subplot(1, 3, i + 1)\nplt.imshow(img_list[i][0,0], cmap='gray', vmin=100, vmax=600)\nplt.axis('off')\nplt.title(my_well + ' ' + str(coord_list[i]))\nplt.show()\nplt.close()\n</code></pre> <pre><code>[(216, 432, 768, 1024), (432, 648, 2048, 2304), (432, 648, 768, 1024)]\n3\n</code></pre> <p></p>"},{"location":"getting_started_hcs_wrappers/#zoom-in","title":"Zoom in","text":"<p>Alternatively, we can zoom in by coordinates:</p> <pre><code>img = plate.get_image_ROI(well=my_well,\nupper_left_yx=(50, 40),\nlower_right_yx=(120, 90))\nprint(img.shape)\nwith plt.style.context('dark_background'):\nfig = plt.figure(figsize=(4, 4))\nfig.set_dpi(100)\nplt.imshow(img[0,0], cmap='gray', vmin=100, vmax=600)\nplt.title(plate.name + ' B03')\nplt.show()\nplt.close()\n</code></pre> <pre><code>(1, 1, 71, 51)\n</code></pre> <p></p> <p>So far, we have been automatically using the lowest resolution (highest) pyramid level version of the data, and the pixel coordinates above refer to that space.</p> <p>If we want to get the same image region at a higher resolution (for example <code>pyramid_level=1</code>), we need to adjust these coordinates. For this, we have two options:</p> <ul> <li>Convert the coordinates manually using the     <code>convert_pixel_to_pixel()</code> function. We then use these new     coordinates with <code>get_image_ROI()</code> to extract the same region from     the higher resolution pyramid level:</li> </ul> <pre><code># convert coordinates manually from lowest-resolution (None, here: 4)\n#   to a higher resolution (1) pyramid level\n# remark: coordinates are (z,y,x)\nnew_upper_left = plate.convert_pixel_to_pixel(zyx = (0, 50, 40),\npyramid_level_from = None,\npyramid_level_to=1)\nnew_lower_right = plate.convert_pixel_to_pixel(zyx = (0, 120, 90),\npyramid_level_from = None,\npyramid_level_to=1)\n# extract image\nimg = plate.get_image_ROI(well=my_well,\nupper_left_yx=new_upper_left[1:],\nlower_right_yx=new_lower_right[1:],\npyramid_level=1)\nwith plt.style.context('dark_background'):\nfig = plt.figure(figsize=(4, 4))\nfig.set_dpi(100)\nplt.imshow(img[0,0], cmap='gray', vmin=100, vmax=600)\nplt.title(plate.name + ' ' + my_well)\nplt.show()\nplt.close()\n</code></pre> <p></p> <ul> <li>Convert the coordinates automatically inside <code>plot_well()</code>. The     function <code>plot_well()</code> is flexible and can also plot just a     sub-region of a well, defined by coordinates. The parameter     <code>pyramid_level_coord</code> can be used to define the reference pyramid     level that these coordinates refer to. This can be a different     pyramid level than the one from which the image is extracted     (defined by <code>pyramid_level</code>):</li> </ul> <pre><code>plate.plot_well(well=my_well,\npyramid_level=1,       # extract image from this level\npyramid_level_coord=4, # coordinates refer to this level\nupper_left_yx=(50,40),\nlower_right_yx=(120,90),\nchannels=[0],\nchannel_colors=['white'],\nchannel_ranges=[[100, 600]],\ntitle=plate.name + ' ' + my_well,\nscalebar_micrometer=30,\nscalebar_color='yellow',\nscalebar_position='bottomright',\nscalebar_label=True,\nfig_width_inch=4,\nfig_height_inch=4,\nfig_dpi=100)\n</code></pre> <p></p>"},{"location":"getting_started_hcs_wrappers/#coordinate-conversions","title":"Coordinate conversions","text":"<p>As mentioned the pixel coordinates depend on the <code>pyramid_level</code>. The image metadata makes it easy to convert between pixel coordinates and micrometer coordinates, or pixel coordinates referring to different pyramid levels:</p> <pre><code>zyx = (1, 230, 180) # highest pyramid level (4)\nprint('starting coordinates (pyramid_level=4): ' + str(zyx))\n# convert from pixel to micrometers\nzyx_um = plate.convert_pixel_to_micrometer(zyx, pyramid_level=4)\nprint('in micrometer: ' + str(zyx_um))\n# convert from micrometers to pixels\nzyx_px = plate.convert_micrometer_to_pixel(zyx_um, pyramid_level=4)\nprint('back in pixel: ' + str(zyx_px))\n# convert pixels between pyramid levels\nzyx_px_0 = plate.convert_pixel_to_pixel(zyx_px, pyramid_level_from=4, pyramid_level_to=0)\nprint('in pixel (pyramid_level=0): ' + str(zyx_px_0))\n</code></pre> <pre><code>starting coordinates (pyramid_level=4): (1, 230, 180)\nin micrometer: (1.0, 598.0, 468.0)\nback in pixel: (1, 230, 180)\nin pixel (pyramid_level=0): (1, 3680, 2880)\n</code></pre> <p>These functions are also used by <code>plot_well()</code> internally to add a scale bar to the image plot, as we have seen above.</p>"},{"location":"getting_started_hcs_wrappers/#working-with-segmentation-masks","title":"Working with segmentation masks","text":"<p>When segmentation masks (labels) are available, we can also extract them. For example, we can plot the labels with transparency on top of the image:</p> <pre><code># select which object to plot\nlabel = 'nuclei'\nimg_pl = 2  # image pyramid level\n# find corresponding mask pyramid level\nimg_name = plate.image_names[0]\npl_match = [plate.level_zyx_spacing_images[img_name][img_pl] == x for x in plate.level_zyx_spacing_labels[label]]\nassert sum(pl_match) == 1\nmsk_pl = pl_match.index(True)\n# load image and corresponding mask\nimg = plate.get_image_ROI(well=my_well, pyramid_level=img_pl,\nupper_left_yx=(200, 160), lower_right_yx=(480, 360))\nmsk = plate.get_label_ROI(label_name=label, well=my_well, pyramid_level=msk_pl,\nupper_left_yx=(200, 160), lower_right_yx=(480, 360))\nassert img[0].shape == msk.shape\n# plot image and mask\nplotting.plot_image(im=img, msk=msk, msk_alpha=0.3,\nchannels=[0], channel_colors=['white'], channel_ranges=[[100,600]],\nfig_width_inch=6, fig_height_inch=6, fig_dpi=100)\n</code></pre> <p></p> <p>Using the tables, we can get the bounding box coordinates in micrometers from <code>nuclei_ROI_table</code> (here just showing the rows 100 to 110):</p> <pre><code>nucl = plate.get_table('nuclei_ROI_table')\nnucl.iloc[100:111]\n</code></pre> well x_micrometer y_micrometer z_micrometer len_x_micrometer len_y_micrometer len_z_micrometer 0 B03 105.95 0 0 8.45 5.2 1 1 B03 121.55 0 0 11.05 7.15 1 2 B03 141.7 0 0 13.65 5.2 1 3 B03 180.7 0 0 13 13 1 4 B03 196.95 0 0 7.15 1.3 1 5 B03 209.3 0 0 9.75 3.9 1 6 B03 230.75 0 0 11.7 11.7 1 7 B03 242.45 0 0 9.75 15.6 1 8 B03 276.25 0 0 16.9 9.1 1 9 B03 300.95 0 0 12.35 4.55 1 <p>We can plot the image region corresponding to a single segmented object, for example the nucleus at index 106:</p> <pre><code># select which object to plot\nidx = 106 # index of the object in `nucl`\nimg_nucl = plate.get_image_table_idx(table_name='nuclei_ROI_table',\ntable_idx=idx,\nwell=my_well,\npyramid_level=img_pl,\nas_NumPy=True)\nmsk_nucl = plate.get_label_table_idx(label_name='nuclei',\ntable_name='nuclei_ROI_table',\ntable_idx=idx,\nwell=my_well,\npyramid_level=msk_pl,\nas_NumPy=True)\nassert img_nucl.shape[1:] == msk_nucl.shape\n# plot \nplotting.plot_image(im=img_nucl, msk=msk_nucl, msk_alpha=0.3,\nchannels=[0], channel_colors=['white'], channel_ranges=[[100,600]],\nfig_width_inch=4, fig_height_inch=4, fig_dpi=100)\n</code></pre> <p></p>"},{"location":"getting_started_hcs_wrappers/#calculations-on-the-image-data","title":"Calculations on the image data","text":"<p>To save memory, images are stored on disk and only loaded when needed (for implementation details see the <code>dask</code> Array documentation).</p> <p>This can be demonstrated by <code>type(img)</code>:</p> <pre><code>type(img) # note that the image is an 'on-disk' array\n</code></pre> <pre><code>dask.array.core.Array\n</code></pre> <p>To force loading of the data into memory, you can call <code>.compute()</code>:</p> <pre><code>type(img.compute()) # .compute() triggers loading it into memory\n</code></pre> <pre><code>numpy.ndarray\n</code></pre> <p>In general, you can use <code>dask</code> arrays like <code>numpy</code> arrays. For example, we can threshold the image:</p> <pre><code># threshold\nimg_mask = img[0,0]&gt;300\n# ... and compute to numpy array\nimg_mask = img_mask.compute()\n# plot \nplotting.plot_image(im=img[:,0], msk=img_mask, msk_alpha=0.5,\nfig_width_inch=6, fig_height_inch=6, fig_dpi=100)\n</code></pre> <p></p> <p>This is of course not a recommended way to segment this image, but rather meant to demonstrate that the <code>dask</code> arrays can be used just like <code>numpy</code> arrays.</p>"},{"location":"getting_started_hcs_wrappers/#session-info","title":"Session info","text":"<pre><code>import session_info\nsession_info.show()\n</code></pre> <pre><code>/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/session_info/main.py:213: UserWarning: The '__version__' attribute is deprecated and will be removed in MarkupSafe 3.1. Use feature detection, or `importlib.metadata.version(\"markupsafe\")`, instead.\n  mod_version = _find_version(mod.__version__)\n</code></pre> Click to view session information <pre>\n-----\nanndata             0.12.2\ndask                2025.9.1\nez_zarr             0.4.2\nmatplotlib          3.8.2\nnumpy               1.26.4\npandas              2.3.2\nrequests            2.32.5\nsession_info        1.0.0\nskimage             0.22.0\n-----\n</pre> Click to view modules imported as dependencies <pre>\nPIL                         11.3.0\nanyio                       NA\narrow                       1.3.0\nasttokens                   NA\nattr                        25.3.0\nattrs                       25.3.0\nbabel                       2.17.0\ncertifi                     2025.08.03\ncharset_normalizer          3.4.3\ncloudpickle                 3.1.1\ncomm                        0.2.3\ncrc32c                      NA\ncycler                      0.12.1\ncython_runtime              NA\ndateutil                    2.9.0.post0\ndebugpy                     1.8.17\ndecorator                   5.2.1\ndefusedxml                  0.7.1\ndonfig                      0.8.1.post1\nexecuting                   2.2.1\nfastjsonschema              NA\nfqdn                        NA\nfsspec                      2025.9.0\nh5py                        3.14.0\nidna                        3.10\nimportlib_metadata          NA\nipykernel                   6.30.1\nisoduration                 NA\njedi                        0.19.2\njinja2                      3.1.6\njson5                       0.12.1\njsonpointer                 3.0.0\njsonschema                  4.25.1\njsonschema_specifications   NA\njupyter_events              0.12.0\njupyter_server              2.17.0\njupyterlab_server           2.27.3\nkiwisolver                  1.4.9\nlark                        1.2.2\nlazy_loader                 0.4\nlegacy_api_wrap             NA\nmarkupsafe                  3.0.2\nmatplotlib_inline           0.1.7\nmpl_toolkits                NA\nnatsort                     8.4.0\nnbformat                    5.10.4\nnumcodecs                   0.16.3\noverrides                   NA\npackaging                   25.0\nparso                       0.8.5\nplatformdirs                4.4.0\nprometheus_client           NA\nprompt_toolkit              3.0.52\npsutil                      7.1.0\npure_eval                   0.2.3\npydev_ipython               NA\npydevconsole                NA\npydevd                      3.2.3\npydevd_file_utils           NA\npydevd_plugins              NA\npydevd_tracing              NA\npygments                    2.19.2\npyparsing                   3.2.5\npythonjsonlogger            NA\npytz                        2025.2\nreferencing                 NA\nrfc3339_validator           0.1.4\nrfc3986_validator           0.1.1\nrfc3987_syntax              NA\nrpds                        NA\nscipy                       1.16.2\nsend2trash                  NA\nsix                         1.17.0\nsniffio                     1.3.1\nstack_data                  0.6.3\ntabulate                    0.9.0\ntesting                     NA\ntlz                         1.0.0\ntoolz                       1.0.0\ntornado                     6.5.2\ntraitlets                   5.14.3\ntyping_extensions           NA\nuri_template                NA\nurllib3                     2.5.0\nwcwidth                     0.2.13\nwebcolors                   NA\nwebsocket                   1.8.0\nyaml                        6.0.2\nzarr                        3.1.3\nzipp                        NA\nzmq                         27.1.0\nzoneinfo                    NA\n</pre> <pre>\n-----\nIPython             9.5.0\njupyter_client      8.6.3\njupyter_core        5.8.1\njupyterlab          4.4.7\nnotebook            7.4.5\n-----\nPython 3.11.13 (main, Jun  4 2025, 04:12:12) [GCC 13.3.0]\nLinux-6.11.0-1018-azure-x86_64-with-glibc2.39\n-----\nSession information updated at 2025-09-22 12:39\n</pre>"},{"location":"hcs_wrappers/","title":"Classes that wrap ome-zarr filesets","text":"<p>Wrap OME-Zarr filesets in a class.</p> <p>Disclaimer: The <code>hcs_wrappers</code> module described here is only provided for legacy reasons and not being further developed. For new projects, we recommend to use the <code>ome_zarr</code> module instead.</p> <p>Represent an OME-Zarr fileset as a class to give high-level access to its contents.</p> <p>Classes:</p> Name Description <code>FractalZarr</code> <p>Contains a single <code>.zarr</code> fileset, typically a plate.</p> <code>FractalZarrSet</code> <p>Contains one or several <code>.zarr</code> filesets, typically a plate (4 dimensional data) and a maximum-intensity projection derived from it.</p>"},{"location":"hcs_wrappers/#src.ez_zarr.hcs_wrappers.FractalZarr","title":"<code>FractalZarr</code>","text":"<p>Represents an OME-Zarr fileset.</p> Source code in <code>src/ez_zarr/hcs_wrappers.py</code> <pre><code>class FractalZarr:\n\"\"\"Represents an OME-Zarr fileset.\"\"\"\n# constructor and helper functions ----------------------------------------\ndef __init__(self, zarr_path: str, name: Optional[str]=None) -&gt; None:\n\"\"\"\n        Initializes an OME-Zarr fileset (.zarr) from its path.\n        Typically, the fileset represents a single assay plate, and \n        we assume that the structures (pyramid levels, labels, tables, etc.)\n        are consistent across wells.\n        Parameters:\n            zarr_path (str): Path containing the plate ome-zarr fileset.\n            name (str, optional): Optional name for the plate.\n        Examples:\n            Get an object corresponding to a plate.\n            &gt;&gt;&gt; from ez_zarr import hcs_wrappers\n            &gt;&gt;&gt; plateA = hcs_wrappers.FractalZarr('path/to/plate.zarr')\n            &gt;&gt;&gt; plateA\n            This will print information about the plate.\n        \"\"\"\nself.path: str = zarr_path\nself.name: str = ''\nif name:\nself.name = name\nelse:\nself.name = os.path.basename(self.path)\nself.__top: zarr.Group = zarr.open(store=self.path, mode='r')\nif not 'plate' in self.__top.attrs:\nraise ValueError(f\"{self.name} does not contain a zarr fileset with a 'plate'\")\nself.acquisitions: list = self.__top.attrs['plate']['acquisitions']\nself.columns: list[dict] = self.__top.attrs['plate']['columns']\nself.rows: list[dict] = self.__top.attrs['plate']['rows']\nself.wells: list[dict] = self.__top.attrs['plate']['wells']\n# images\nself.image_names: list[str] = self._load_image_names()\nself.channels: list[dict] = self._load_channel_info()\nself.multiscales_images: dict[str, Any] = self._load_multiscale_info('images')\nself.level_paths_images: dict[str, list[str]] = {im: [x['path'] for x in self.multiscales_images[im]['datasets']] for im in self.image_names}\nself.level_zyx_spacing_images: dict[str, list[list[float]]] = {im: [x['coordinateTransformations'][0]['scale'][1:] for x in self.multiscales_images[im]['datasets']] for im in self.image_names} # convention: unit is micrometer\nself.level_zyx_scalefactor: dict[str, np.ndarray] = {im: np.divide(self.level_zyx_spacing_images[im][1], self.level_zyx_spacing_images[im][0]) for im in self.image_names}\n# labels\nself.label_names: list[str] = self._load_label_names()\nself.multiscales_labels: dict[str, Any] = self._load_multiscale_info('labels')\nself.level_paths_labels: dict[str, list[str]] = {lab: [x['path'] for x in self.multiscales_labels[lab]['datasets']] for lab in self.label_names}\nself.level_zyx_spacing_labels: dict[str, list[list[float]]] = {lab: [x['coordinateTransformations'][0]['scale'] for x in self.multiscales_labels[lab]['datasets']] for lab in self.label_names} # convention: unit is micrometer\n# tables\nself.table_names: list[str] = self._load_table_names()\ndef _load_channel_info(self) -&gt; list:\n\"\"\"[internal] Load info about available channels.\"\"\"\nwell_path = self.wells[0]['path']\nwell_group = self.__top[os.path.join(well_path, self.image_names[0])]\nif not 'omero' in well_group.attrs or not 'channels' in well_group.attrs['omero']:\nraise ValueError(f\"no channel info found in well {well_path}, image {self.image_names[0]}\")\nreturn well_group.attrs['omero']['channels']\ndef _load_multiscale_info(self, target: str) -&gt; dict[str, Any]:\n\"\"\"[internal] Load info about available scales in target (images or labels).\"\"\"\nwell_path = self.wells[0]['path']\nif target == 'images':\npre = ''\nels = self.image_names\nelse:\npre = os.path.join(self.image_names[0], 'labels')\nels = self.label_names\ninfo = {}\nfor el in els:\nel_group = self.__top[os.path.join(well_path, pre, el)]\nif not 'multiscales' in el_group.attrs:\nraise ValueError(f\"no multiscale info found in {target} {el}\")\ninfo[el] = el_group.attrs['multiscales'][0]\nreturn info\ndef _load_image_names(self) -&gt; list[str]:\n\"\"\"[internal] Load image names (available images).\"\"\"\nwell_path = self.wells[0]['path']\nims = [im for im in os.listdir(os.path.join(self.path, well_path)) if not im.startswith('.')]\nreturn ims\ndef _load_label_names(self) -&gt; list[str]:\n\"\"\"[internal] Load label names (available segmentations).\"\"\"\nwell = self.wells[0]['path']\nlabel_path = os.path.join(well, '0', 'labels')\nif label_path in self.__top:\nreturn self.__top[label_path].attrs['labels']\nelse:\nreturn []\ndef _load_table_names(self) -&gt; list[str]:\n\"\"\"[internal] Load table names (can be extracted using .get_table()).\"\"\"\nwell = self.wells[0]['path']\ntable_path = os.path.join(well, '0', 'tables')\nif table_path in self.__top:\nreturn self.__top[table_path].attrs['tables']\nelse:\nreturn []\n# utility functions -------------------------------------------------------\ndef _digest_well_argument(self, well=None, as_path=True):\n\"\"\"[internal] Interpret a single `well` argument in the context of a given FractalZarr object.\"\"\"\nif not well:\n# no well given -&gt; pick first one\nreturn self.wells[0]['path']\nelif as_path:\nreturn os.path.join(well[:1].upper(), well[1:]).replace(\"\\\\\", \"/\")\nelse:\nreturn well\ndef _digest_include_wells_argument(self, include_wells: Union[str, list[str]]=[]) -&gt; list[str]:\n\"\"\"[internal] Interpret an `include_wells` argument in the context of a given FractalZarr object.\"\"\"\nif isinstance(include_wells, str):\ninclude_wells = [include_wells]\nif len(include_wells) == 0: \n# no wells given -&gt; include all wells\ninclude_wells = [x['path'].replace(\"\\\\\", \"/\") for x in self.wells]\nelse:\n# transform well names from 'B03' format to path format 'B/03'\ninclude_wells = [self._digest_well_argument(w) for w in include_wells]\nreturn include_wells\ndef _digest_pyramid_level_argument(self, pyramid_level=None, pyramid_ref=None) -&gt; int:\n\"\"\"\n        [internal] Interpret a `pyramid_level` argument in the context of a given FractalZarr object.\n        Parameters:\n            pyramid_level (int, str or None): pyramid level, coerced to str. If None, the\n                last pyramid level (typically the lowest-resolution one) will be returned.\n            pyramid_ref (tuple(str, str)): defines what `pyramid_level` refers to. If None,\n                the first image is used: `('image', '0')` (assuming that the name of the\n                first image is '0'). To select the 'nuclei' labels, the arugment would be\n                set to `('label', 'nuclei')`.\n        Returns:\n            Integer index of the pyramid level.\n        \"\"\"\nif pyramid_ref == None:\n# no pyramid reference given -&gt; pick the first image\npyramid_ref = ('image', self.image_names[0])\nif pyramid_level == None: \n# no pyramid level given -&gt; pick lowest resolution one\nif pyramid_ref[0] == 'image':\npyramid_level = int(self.level_paths_images[pyramid_ref[1]][-1])\nelse:\npyramid_level = int(self.level_paths_labels[pyramid_ref[1]][-1])\nelse:\n# make sure it is an integer\npyramid_level = int(pyramid_level)\nreturn pyramid_level\ndef _calculate_regular_grid_coordinates(self, y, x, num_y=10, num_x=10):\n\"\"\"\n        [internal] Calculate the cell coordinates for a regular rectangular grid of total size (y, x)\n        by splitting the dimensions into num_y and num_x cells.\n        Returns a list of (y_start, y_end, x_start, x_end) tuples. The coordinates are\n        inclusive at the start and exclusive at the end.\n        All returned grid cells are guaranteed to be of equal size, but a few pixels in the\n        last row or column may not be included if y or x is not divisible by `num_y` or `num_x`.\n        \"\"\"\ny_step = y // num_y\nx_step = x // num_x\ngrid_coords = [] # list of (y_start, y_end, x_start, x_end)\nfor i in range(num_y):\nfor j in range(num_x):\ny_start = i * y_step\n# y_end = (i + 1) * y_step if i != num_y - 1 else y\ny_end = (i + 1) * y_step # possibly miss some at the highest i\nx_start = j * x_step\n# x_end = (j + 1) * x_step if j != num_x - 1 else x\nx_end = (j + 1) * x_step # possibly miss some at the highest i\ngrid_coords.append((y_start, y_end, x_start, x_end))\nreturn grid_coords\n# string representation ---------------------------------------------------\ndef __str__(self):\nnwells = len(self.wells)\nnch = len(self.channels)\nchlabs = ', '.join([x['label'] for x in self.channels])\nnpl = len(self.multiscales_images[self.image_names[0]]['datasets'])\nsegnames = ', '.join(self.label_names)\ntabnames = ', '.join(self.table_names)\nreturn f\"FractalZarr {self.name}\\n  path: {self.path}\\n  n_wells: {nwells}\\n  n_channels: {nch} ({chlabs})\\n  n_pyramid_levels: {npl}\\n  pyramid_zyx_scalefactor: {self.level_zyx_scalefactor}\\n  full_resolution_zyx_spacing (\u00b5m): {self.level_zyx_spacing_images[self.image_names[0]][0]}\\n  segmentations: {segnames}\\n  tables (measurements): {tabnames}\\n\"\ndef __repr__(self):\nreturn str(self)\n# accessors ---------------------------------------------------------------\ndef get_path(self) -&gt; str:\n\"\"\"Get the path of an OME-Zarr fileset.\n        Returns:\n            The path to the OME-Zarr fileset.\n        \"\"\"\nreturn self.path\ndef get_wells(self, simplify: bool=False) -&gt; Union[list[dict[str, Any]], list[str]]:\n\"\"\"Get info on wells in an OME-Zarr fileset.\n        Parameters:\n            simplify (bool): If `True`, the well names are returned in human readable form (e.g. 'B03').\n        Returns:\n            A list of wells in the plate, either name strings (if `simplify=True`) or dicts with well attributes.\n        \"\"\"\nif simplify:\nreturn [w['path'].replace('/', '') for w in self.wells]\nelse:\nreturn self.wells\ndef get_channels(self) -&gt; list:\n\"\"\"Get info on channels in an OME-Zarr fileset.\n        Returns:\n            A list of dicts with information on channels.\n        \"\"\"\nreturn self.channels\ndef get_label_names(self) -&gt; list:\n\"\"\"Get list of label names in an OME-Zarr fileset.\n        Returns:\n            A list of label names (str) available in the plate.\n        \"\"\"\nreturn self.label_names\ndef get_table_names(self) -&gt; list:\n\"\"\"Get list of table names in an OME-Zarr fileset.\n        Returns:\n            A list of table names (str) available in the plate.\n        \"\"\"\nreturn self.table_names\n# query methods -----------------------------------------------------------\ndef get_table(self,\ntable_name: str,\ninclude_wells: Union[str, list[str]]=[],\nas_AnnData: bool=False) -&gt; Any:\n\"\"\"Extract table for wells in an OME-Zarr fileset.\n        Parameters:\n            table_name (str): The name of the table to extract.\n            include_wells (str or list): List of well names to include. If empty `[]`, all wells are included.\n            as_AnnData (bool): If `True`, the table is returned as an `AnnData` object, otherwise it is converted to a `pandas.DataFrame`.\n        Returns:\n            The extracted table, either as an `anndata.AnnData` object if `as_AnnData=True`, and as a `pandas.DataFrame` otherwise.\n        Examples:\n            Get a table with coordinates of fields of view:\n            &gt;&gt;&gt; plateA.get_table(table_name='FOV_ROI_table')\n        \"\"\"\ninclude_wells = self._digest_include_wells_argument(include_wells)\ntable_paths = [os.path.join(w, '0', 'tables', table_name) for w in include_wells]\n# remark: warn if not all well have the table?\ntable_paths = [p for p in table_paths if p in self.__top]\nif len(table_paths) == 0:\nreturn None\nwith warnings.catch_warnings():\nwarnings.filterwarnings(\"ignore\")\nad = importlib.import_module('anndata')\nanndata_list = [ad.read_zarr(os.path.join(self.path, p)) for p in table_paths]\n# ... retain well information when combining anndata objects\nfor ann, w in zip(anndata_list, include_wells):\nann.obs['well'] = w.replace('/', '')\nanndata_combined = ad.concat(anndata_list, index_unique=None, keys=[w.replace('/', '') for w in include_wells])\nif as_AnnData:\nreturn anndata_combined\nelse:\ndf_combined = pd.concat([anndata_combined.obs['well'],\nanndata_combined.to_df()],\naxis=1)\nreturn df_combined\ndef get_image_ROI(self,\nupper_left_yx: Optional[tuple[int]]=None,\nlower_right_yx: Optional[tuple[int]]=None,\nsize_yx: Optional[tuple[int]]=None,\nwell: Optional[str]=None,\nimage_name: str='0',\npyramid_level: Optional[int]=None,\npyramid_level_coord: Optional[int]=None,\nas_NumPy: bool=False) -&gt; Union[dask.array.Array, np.ndarray]:\n\"\"\"\n        Extract a region of interest from a well image by coordinates.\n        None or exactly two of `upper_left_yx`, `lower_right_yx` and `size_yx` need to be given.\n        If none are given, it will return the full image (the whole well).\n        Otherwise, `upper_left_yx` contains the lower indices than `lower_right_yx`\n        (origin on the top-left, zero-based coordinates), and each of them is\n        a tuple of (y, x). No z coordinate needs to be given, all z planes are returned\n        if there are several ones.\n        Parameters:\n            upper_left_yx (tuple): Tuple of (y, x) coordinates for the upper-left (lower) coordinates\n                defining the region of interest.\n            lower_right_yx (tuple): Tuple of (y, x) coordinates for the lower-right (higher) coordinates defining the region of interest.\n            size_yx (tuple): Tuple of (size_y, size_x) defining the size of the region of interest.\n            well (str): The well (e.g. 'B03') from which an image should be extracted.\n            image_name (str): The name of the image in `well` to extract from. Default: '0'.\n            pyramid_level (int): The pyramid level (resolution level), from which the image\n                should be extracted. If `None`, the lowest-resolution (highest) pyramid level\n                will be selected.\n            pyramid_level_coord (int): An optional integer scalar giving the image pyramid level\n                to which the coordinates (`upper_left_yx`, `lower_right_yx` and `size_yx`)\n                refer to. By default, this is `None`, which will use `pyramid_level`.\n            as_NumPy (bool): If `True`, return the image as 4D `numpy.ndarray` object (c,z,y,x).\n                Otherwise, return the (on-disk) `dask` array of the same dimensions.\n        Returns:\n            The extracted image, either as a `dask.array.Array` on-disk array, or as an in-memory `numpy.ndarray` if `as_NumPy=True`.\n        Examples:\n            Obtain the image of the lowest-resolution for the full well 'A02':\n            &gt;&gt;&gt; plateA.get_image_ROI(well='A02')\n        \"\"\"\n# digest arguments\nwell = self._digest_well_argument(well)\npyramid_level = self._digest_pyramid_level_argument(pyramid_level, ('image', image_name))\n# load image\nimg_path = os.path.join(self.path, well, image_name, str(pyramid_level))\nimg = dask.array.from_zarr(img_path)\n# calculate corner coordinates and subset if needed\n# (images are always of 4D shape c,z,y,x)\nnum_unknowns = sum([x == None for x in [upper_left_yx, lower_right_yx, size_yx]])\nif num_unknowns == 1:\nif size_yx:\nassert all([x &gt; 0 for x in size_yx]), 'size_yx values need to be positive'\nif not upper_left_yx:\nupper_left_yx = tuple(lower_right_yx[i] - size_yx[i] for i in range(2))\nelif not lower_right_yx:\nlower_right_yx = tuple(upper_left_yx[i] + size_yx[i] for i in range(2))\nassert all([upper_left_yx[i] &lt; lower_right_yx[i] for i in range(len(upper_left_yx))]), 'upper_left_yx needs to be less than lower_right_yx'\n# convert coordinates if needed\nif pyramid_level_coord != None and pyramid_level != pyramid_level_coord:\nupper_left_yx = self.convert_pixel_to_pixel(zyx=((0,) + upper_left_yx),\npyramid_level_from=pyramid_level_coord,\npyramid_level_to=pyramid_level,\npyramid_ref_from=('image', image_name),\npyramid_ref_to=('image', image_name))[1:]\nlower_right_yx = self.convert_pixel_to_pixel(zyx=((0,) + lower_right_yx),\npyramid_level_from=pyramid_level_coord,\npyramid_level_to=pyramid_level,\npyramid_ref_from=('image', image_name),\npyramid_ref_to=('image', image_name))[1:]\nimg = img[:,\n:,\nslice(upper_left_yx[0], lower_right_yx[0] + 1),\nslice(upper_left_yx[1], lower_right_yx[1] + 1)]\nelif num_unknowns != 3:\nraise ValueError(\"Either none or two of `upper_left_yx`, `lower_right_yx` and `size_yx` have to be given\")\n# convert if needed and return\nif as_NumPy:\nimg = np.array(img)\nreturn img\ndef get_image_table_idx(self,\ntable_name: str,\ntable_idx: int,\nwell: Optional[str]=None,\npyramid_level: Optional[int]=None,\nas_NumPy: bool=False) -&gt; Union[dask.array.Array, np.ndarray]:\n\"\"\"\n        Extract a region of interest from a well image by table name and row index.\n        Bounding box coordinates will be automatically obtained from the table\n        `table_name` and row `row_idx` (zero-based row index).\n        All z planes are returned if there are several ones.\n        Parameters:\n            table_name (str): The name of the table containing object coordinates in columns\n                `x_micrometer`, `y_micrometer`, `len_x_micrometer` and `len_y_micrometer`.\n            table_idx (int): The zero-based row index for the object to be extracted.\n            well (str): The well (e.g. 'B03') from which an image should be extracted.\n            pyramid_level (int): The pyramid level (resolution level), from which the image\n                should be extracted. If `None`, the lowest-resolution (highest) pyramid level\n                will be selected.\n            as_NumPy (bool): If `True`, return the image as 4D `numpy.ndarray` object (c,z,y,x).\n                Otherwise, return the (on-disk) `dask` array of the same dimensions.\n        Returns:\n            The extracted image, either as a `dask.array.Array` on-disk array, or as an in-memory `numpy.ndarray` if `as_NumPy=True`.\n        Examples:\n            Obtain the image of the first object in table `nuclei_ROI_table` in well 'A02':\n            &gt;&gt;&gt; plateA.get_image_table_idx(table_name='nuclei_ROI_table', table_idx=0, well='A02')\n        \"\"\"\n# digest arguments\nassert table_name in self.table_names, f\"Unknown table {table_name}, should be one of \" + ', '.join(self.table_names)\nwell = self._digest_well_argument(well, as_path=False)\npyramid_level = self._digest_pyramid_level_argument(pyramid_level)\n# extract table\ndf = self.get_table(table_name=table_name, include_wells=well, as_AnnData=False)\nrequired_columns = ['x_micrometer', 'y_micrometer', 'len_x_micrometer', 'len_y_micrometer']\nassert all(column in set(df.columns) for column in required_columns), f\"Missing columns: {set(required_columns) - set(df.columns)}\"\nassert table_idx &lt; len(df), f\"table_idx ({table_idx}) needs to be less than \" + str(len(df))\n# get bounding box coordinates\nul = self.convert_micrometer_to_pixel((0,\ndf['y_micrometer'].iloc[table_idx],\ndf['x_micrometer'].iloc[table_idx]),\npyramid_level=pyramid_level,\npyramid_ref=('image', '0'))\nhw = self.convert_micrometer_to_pixel((0,\ndf['len_y_micrometer'].iloc[table_idx],\ndf['len_x_micrometer'].iloc[table_idx]),\npyramid_level=pyramid_level,\npyramid_ref=('image', '0'))\n# load image\nimg = self.get_image_ROI(upper_left_yx=ul[1:],\nsize_yx=hw[1:],\nwell=well,\npyramid_level=pyramid_level,\nas_NumPy=as_NumPy)\nreturn img\ndef get_image_grid_ROIs(self,\nwell: Optional[str]=None,\npyramid_level: Optional[int]=None,\nlowres_level: Optional[int]=None,\nnum_y: int=10,\nnum_x: int=10,\nnum_select: int=9,\nsample_method: str='sum',\nchannel: int=0,\nseed: int=42,\nas_NumPy: bool=False) -&gt; Union[tuple[list[tuple[int]], list[dask.array.Array]], tuple[list[tuple[int]], list[np.ndarray]]]:\n\"\"\"\n        Split a well image into a regular grid and extract a subset of grid cells (all z planes if several).\n        `num_y` and `num_x` define the grid by specifying the number of cells in y and x.\n        `num_select` grid cells are picked from the total number and returned as a list.\n        All returned grid cells are guaranteed to be of equal size, but a few pixels from the image\n        may not be included in grid cells of the last row or column if the image shape\n        is not divisible by `num_y` or `num_x`.\n        Parameters:\n            well (str):  The well (e.g. 'B03') from which an image should be extracted.\n            pyramid_level (int): The pyramid level (resolution level), from which the\n                selected image grid cells should be returned. If `None`, the lowest-resolution\n                (highest) pyramid level will be selected.\n            lowres_level (int): Similar to `pyramid_level`, but defining the resolution\n                for calculating the `sample_method`. Calculations on low-resolution\n                images are faster and often result in identical ordering of grid cells,\n                so that high-resolution images can be returned by `pyramid_level` without making\n                their sampling slower.\n            num_y (int): The size of the grid in y.\n            num_x (int): The size of the grid in x.\n            num_select (int): The number of grid cells to return as images.\n            sample_method (str): Defines how the `num_select` cells are selected. Possible values are:\n                - 'sum': order grid cells decreasingly by the sum of `channel` (working on `lowres_level`)\n                - 'var': order grid cells decreasingly by the variance of `channel` (working on `lowres_level`)\n                - 'random': order grid cells randomly (use `seed`)\n            channel (int): Selects the channel on which `sample_method` is calculated.\n            seed (int): Used in `random.seed()` to make sampling for `sample_method='random'` reproducible.\n            as_NumPy (bool): If `True`, return the grid cell image as `numpy.ndarray` objects with\n                shapes (c,z,y,x). Otherwise, return the (on-disk) `dask` arrays of the same dimensions.\n        Returns:\n            A tuple of two lists (coord_list, img_list), each with `num_select` elements \n                corresponding to the coordinates and images of selected grid cells. \n                The coordinates are tuples of the form  (y_start, y_end, x_start, x_end).\n        Examples:\n            Obtain grid cells with highest signal sum in channel 0 from well 'A02':\n            &gt;&gt;&gt; plateA.get_image_grid_ROIs(well='A02')\n        \"\"\"\n# digest arguments\nwell = self._digest_well_argument(well)\npyramid_level = self._digest_pyramid_level_argument(pyramid_level)\nlowres_level = self._digest_pyramid_level_argument(lowres_level)\nassert num_select &lt;= num_x * num_y, f\"num_select ({num_select}) needs to be less or equal to num_x * num_y\" + str(num_x * num_y)\n# load image (convention: single field of view per well -&gt; '0')\nimg_path = os.path.join(self.path, well, '0', str(pyramid_level))\nimg = dask.array.from_zarr(img_path)\nimg_path_lowres = os.path.join(self.path, well, '0', str(lowres_level))\nimg_lowres = dask.array.from_zarr(img_path_lowres)\n# calculate grid coordinates as a list of (y_start, y_end, x_start, x_end)\n# (images are always of 4D shape c,z,y,x)\nch, z, y, x = img.shape\ngrid = self._calculate_regular_grid_coordinates(y=y, x=x,\nnum_y=num_y,\nnum_x=num_x)\nch_lr, z_lr, y_lr, x_lr = img_lowres.shape\ngrid_lowres = self._calculate_regular_grid_coordinates(y=y_lr, x=x_lr,\nnum_y=num_y,\nnum_x=num_x)\n# select and extract grid cells\nsel_coords = []\nsel_img_cells = []\nif sample_method == 'sum':\ngrid_values = [\ndask.array.sum(\nimg_lowres[slice(channel, channel + 1),\n:,\nslice(grid_lowres[i][0], grid_lowres[i][1]),\nslice(grid_lowres[i][2], grid_lowres[i][3])]\n) for i in range(len(grid_lowres))\n]\nidx_sorted = list(np.argsort(np.array(grid_values)))\nsel_coords = [grid[i] for i in idx_sorted[-num_select:]]\nelif sample_method == 'var':\ngrid_values = [\ndask.array.var(\nimg_lowres[slice(channel, channel + 1),\n:,\nslice(grid_lowres[i][0], grid_lowres[i][1]),\nslice(grid_lowres[i][2], grid_lowres[i][3])]\n) for i in range(len(grid_lowres))\n]\nidx_sorted = list(np.argsort(np.array(grid_values)))\nsel_coords = [grid[i] for i in idx_sorted[-num_select:]]\nelif sample_method == 'random':\nrandom.seed(seed)\nsel_coords = random.sample(grid, num_select)\nelse:\nraise ValueError(\"'sample_method' must be one of 'sum', 'var' or 'random'\")\nfor i in range(num_select):\nimg_cell = img[:,\n:,\nslice(sel_coords[i][0], sel_coords[i][1]),\nslice(sel_coords[i][2], sel_coords[i][3])]\nif as_NumPy:\nimg_cell = np.array(img_cell)\nsel_img_cells.append(img_cell)\nreturn (sel_coords, sel_img_cells)\ndef get_label_ROI(self,\nlabel_name: str,\nwell: Optional[str]=None,\nimage_name: str='0',\npyramid_level: Optional[int]=None,\npyramid_level_coord: Optional[int]=None,\nupper_left_yx: Optional[tuple[int]]=None,\nlower_right_yx: Optional[tuple[int]]=None,\nsize_yx: Optional[tuple[int]]=None,\nas_NumPy: bool=False) -&gt; Union[dask.array.Array, np.ndarray]:\n\"\"\"\n        Extract a region of interest from a label mask (segmentation) by coordinates.\n        None or exactly two of `upper_left_yx`, `lower_right_yx` and `size_yx` need to be given.\n        If none are given, it will return the full image (the whole well).\n        Otherwise, `upper_left_yx` contains the lower indices than `lower_right_yx`\n        (origin on the top-left, zero-based coordinates), and each of them is\n        a tuple of (y, x). No z coordinate needs to be given, all z planes are returned\n        if there are several ones.\n        Parameters:\n            label_name (str): The name of the segmentation\n            well (str): The well (e.g. 'B03') from which an image should be extracted.\n            image_name (str): The name of the image in `well` to extract labels from. Default: '0'.\n            pyramid_level (int): The pyramid level (resolution level), from which the image\n                should be extracted. If `None`, the lowest-resolution (highest) pyramid level\n                will be selected.\n            pyramid_level_coord (int): An optional integer scalar giving the image pyramid level\n                to which the coordinates (`upper_left_yx`, `lower_right_yx` and `size_yx`)\n                refer to. By default, this is `None`, which will use `pyramid_level`.\n            upper_left_yx (tuple): Tuple of (y, x) coordinates for the upper-left (lower) coordinates\n                defining the region of interest.\n            lower_right_yx (tuple): Tuple of (y, x) coordinates for the lower-right (higher) coordinates defining the region of interest.\n            size_yx (tuple): Tuple of (size_y, size_x) defining the size of the region of interest.\n            as_NumPy (bool): If `True`, return the image as 4D `numpy.ndarray` object (c,z,y,x).\n                Otherwise, return the (on-disk) `dask` array of the same dimensions.\n        Returns:\n            The extracted label mask, either as a `dask.array.Array` on-disk array, or as an in-memory `numpy.ndarray` if `as_NumPy=True`.\n        Examples:\n            Obtain the label mask of the lowest-resolution pyramid level for the full well 'A02':\n            &gt;&gt;&gt; plateA.get_label_ROI(well='A02')\n        \"\"\"\n# digest arguments\nwell = self._digest_well_argument(well)\nassert label_name in self.label_names, f\"Unknown label_name {label_name}, should be one of \" + ', '.join(self.label_names)\npyramid_level = self._digest_pyramid_level_argument(pyramid_level, ('image', image_name))\n# load image\nmsk_path = os.path.join(self.path, well, image_name, 'labels', label_name, str(pyramid_level))\nmsk = dask.array.from_zarr(msk_path)\n# calculate corner coordinates and subset if needed\n# (images are always of 4D shape c,z,y,x)\nnum_unknowns = sum([x == None for x in [upper_left_yx, lower_right_yx, size_yx]])\nif num_unknowns == 1:\nif size_yx:\nassert all([x &gt; 0 for x in size_yx]), 'size_yx values need to be positive'\nif not upper_left_yx:\nupper_left_yx = tuple(lower_right_yx[i] - size_yx[i] for i in range(2))\nelif not lower_right_yx:\nlower_right_yx = tuple(upper_left_yx[i] + size_yx[i] for i in range(2))\nassert all([upper_left_yx[i] &lt; lower_right_yx[i] for i in range(len(upper_left_yx))]), 'upper_left_yx needs to be less than lower_right_yx'\n# convert coordinates if needed\nif pyramid_level_coord != None and pyramid_level != pyramid_level_coord:\nupper_left_yx = self.convert_pixel_to_pixel(zyx=((0,) + upper_left_yx),\npyramid_level_from=pyramid_level_coord,\npyramid_level_to=pyramid_level,\npyramid_ref_from=('image', image_name),\npyramid_ref_to=('image', image_name))[1:]\nlower_right_yx = self.convert_pixel_to_pixel(zyx=((0,) + lower_right_yx),\npyramid_level_from=pyramid_level_coord,\npyramid_level_to=pyramid_level,\npyramid_ref_from=('image', image_name),\npyramid_ref_to=('image', image_name))[1:]\nmsk = msk[:,\nslice(upper_left_yx[0], lower_right_yx[0] + 1),\nslice(upper_left_yx[1], lower_right_yx[1] + 1)]\nelif num_unknowns != 3:\nraise ValueError(\"Either none or two of `upper_left_yx`, `lower_right_yx` and `size_yx` have to be given\")\n# convert if needed and return\nif as_NumPy:\nmsk = np.array(msk)\nreturn msk\ndef get_label_table_idx(self,\nlabel_name: str,\ntable_name: str,\ntable_idx: int,\nwell: Optional[str]=None,\npyramid_level: Optional[int]=None,\nas_NumPy: bool=False) -&gt; Union[dask.array.Array, np.ndarray]:\n\"\"\"\n        Extract a region of interest from a label mask (segmentation) by table name and row index.\n        Bounding box coordinates will be automatically obtained from the table\n        `table_name` and row `row_idx` (zero-based row index).\n        All z planes are returned if there are several ones.\n        Parameters:\n            label_name (str): The name of the segmentation\n            table_name (str): The name of the table containing object coordinates in columns\n                `x_micrometer`, `y_micrometer`, `len_x_micrometer` and `len_y_micrometer`.\n            table_idx (int): The zero-based row index for the object to be extracted.\n            well (str): The well (e.g. 'B03') from which an image should be extracted.\n            pyramid_level (int): The pyramid level (resolution level), from which the image\n                should be extracted. If `None`, the lowest-resolution (highest) pyramid level\n                will be selected.\n            as_NumPy (bool): If `True`, return the image as 4D `numpy.ndarray` object (c,z,y,x).\n                Otherwise, return the (on-disk) `dask` array of the same dimensions.\n        Returns:\n            The extracted label mask, either as a `dask.array.Array` on-disk array, or as an in-memory `numpy.ndarray` if `as_NumPy=True`.\n        Examples:\n            Obtain the label mask in 'nuclei' of the first object in table `nuclei_ROI_table` in well 'A02':\n            &gt;&gt;&gt; plateA.get_label_table_idx(label_name='nuclei',\n                                           table_name='nuclei_ROI_table',\n                                           table_idx=0, well='A02')\n        \"\"\"\n# digest arguments\nassert label_name in self.label_names, f\"Unknown label_name {label_name}, should be one of \" + ', '.join(self.label_names)\nassert table_name in self.table_names, f\"Unknown table_name {table_name}, should be one of \" + ', '.join(self.table_names)\nwell = self._digest_well_argument(well, as_path=False)\npyramid_level = self._digest_pyramid_level_argument(pyramid_level)\n# extract table\ndf = self.get_table(table_name=table_name, include_wells=well, as_AnnData=False)\nrequired_columns = ['x_micrometer', 'y_micrometer', 'len_x_micrometer', 'len_y_micrometer']\nassert all(column in set(df.columns) for column in required_columns), f\"Missing columns: {set(required_columns) - set(df.columns)}\"\nassert table_idx &lt; len(df), f\"table_idx ({table_idx}) needs to be less than \" + str(len(df))\n# get bounding box coordinates\nul = self.convert_micrometer_to_pixel((0,\ndf['y_micrometer'].iloc[table_idx],\ndf['x_micrometer'].iloc[table_idx]),\npyramid_level=pyramid_level,\npyramid_ref=('label', label_name))\nhw = self.convert_micrometer_to_pixel((0,\ndf['len_y_micrometer'].iloc[table_idx],\ndf['len_x_micrometer'].iloc[table_idx]),\npyramid_level=pyramid_level,\npyramid_ref=('label', label_name))\n# load image\nimg = self.get_label_ROI(label_name=label_name,\nwell=well,\nupper_left_yx=ul[1:],\nsize_yx=hw[1:],\npyramid_level=pyramid_level,\nas_NumPy=as_NumPy)\nreturn img\ndef convert_micrometer_to_pixel(self,\nzyx: tuple[float],\npyramid_level: Optional[int]=None,\npyramid_ref: tuple[str]=('image', '0')) -&gt; tuple[int]:\n\"\"\"\n        Convert micrometers to pixels for a given pyramid level.\n        Parameters:\n            zyx (tuple): The micrometer coordinates in the form (z, y, x) to be converted\n                to pixels.\n            pyramid_level (int): The pyramid level (resolution), which the output\n                pixel coordinates will refer to.  If `None`, the lowest-resolution\n                (highest) pyramid level will be selected.\n            pyramid_ref (tuple(str, str)): The reference that the `pyramid_level` refers\n                to. It is given as a tuple with two `str` elements, the first being\n                either 'image' or 'label', and the second being the name of the\n                image or label. The default is ('image', '0').\n        Returns:\n            A tuple (z, y, x) with pixel coordinates.\n        Examples:\n            Obtain the x-length (x_px) of a scale bar corresopnding to 10 micrometer for\n            pyramid level 0:\n            &gt;&gt;&gt; z_px, y_px, x_px = plateA.convert_micrometer_to_pixel(zyx=(0,0,10), pyramid_level=0)\n        \"\"\"\n# digest arguments\nassert isinstance(zyx, tuple), \"zyx needs to be a tuple of the form (z,y,x)\"\npyramid_level = self._digest_pyramid_level_argument(pyramid_level)\n# convert\nif pyramid_ref[0] == 'image':\npyramid_spacing = self.level_zyx_spacing_images[pyramid_ref[1]][pyramid_level]\nelse:\npyramid_spacing = self.level_zyx_spacing_labels[pyramid_ref[1]][pyramid_level]\nzyx_px = np.round(np.divide(zyx, pyramid_spacing)).astype(int)\n# return as tuple\nreturn(tuple(zyx_px))\ndef convert_pixel_to_micrometer(self,\nzyx: tuple[int],\npyramid_level: Optional[int]=None,\npyramid_ref: tuple[str]=('image', '0')) -&gt; tuple[float]:\n\"\"\"\n        Convert pixels to micrometers for a given pyramid level.\n        Parameters:\n            zyx (tuple): The pixel coordinates in the form (z, y, x) to be converted\n                to micrometers.\n            pyramid_level (int): The pyramid level (resolution), which the input\n                pixel coordinates refer to. If `None`, the lowest-resolution\n                (highest) pyramid level will be selected.\n            pyramid_ref (tuple(str, str)): The reference that the `pyramid_level` refers\n                to. It is given as a tuple with two `str` elements, the first being\n                either 'image' or 'label', and the second being the name of the\n                image or label. The default is ('image', '0').\n        Returns:\n            A tuple (z, y, x) with micrometer coordinates.\n        Examples:\n            Obtain the micrometer dimensions of a cube with 10 pixel sides for pyramid level 0:\n            &gt;&gt;&gt; z_um, y_um, x_um = plateA.convert_pixel_to_micrometer(zyx=(10,10,10), pyramid_level=0)\n        \"\"\"\n# digest arguments\npyramid_level = self._digest_pyramid_level_argument(pyramid_level)\n# convert\nif pyramid_ref[0] == 'image':\npyramid_spacing = self.level_zyx_spacing_images[pyramid_ref[1]][pyramid_level]\nelse:\npyramid_spacing = self.level_zyx_spacing_labels[pyramid_ref[1]][pyramid_level]\nzyx_um = np.round(np.multiply(zyx, pyramid_spacing)).astype(float)\n# return as tuple\nreturn(tuple(zyx_um))\ndef convert_pixel_to_pixel(self,\nzyx: tuple[int],\npyramid_level_from: Optional[int]=None,\npyramid_level_to: Optional[int]=None,\npyramid_ref_from: tuple[str]=('image', '0'),\npyramid_ref_to: tuple[str]=('image', '0')) -&gt; tuple[int]:\n\"\"\"\n        Convert pixel coordinates between pyramid levels.\n        Parameters:\n            zyx (tuple): The pixel coordinates in the form (z, y, x) to be converted.\n            pyramid_level_from (int): The pyramid level (resolution), which the input\n                pixel coordinates refer to. If `None`, the lowest-resolution\n                (highest) pyramid level will be selected.\n            pyramid_level_to (int): The pyramid level (resolution), which the output\n                pixel coordinates will refer to. If `None`, the lowest-resolution\n                (highest) pyramid level will be selected.\n            pyramid_ref_from (tuple(str, str)): The reference that the `pyramid_level_from` refers\n                to. It is given as a tuple with two `str` elements, the first being\n                either 'image' or 'label', and the second being the name of the\n                image or label. The default is ('image', '0').\n            pyramid_ref_to (tuple(str, str)): The reference that the `pyramid_level_to` refers\n                to. It is given as a tuple with two `str` elements, the first being\n                either 'image' or 'label', and the second being the name of the\n                image or label. The default is ('image', '0').\n        Returns:\n            A tuple (z, y, x) with pixel coordinates in the new pyramid level.\n        Examples:\n            Convert a point (0, 10, 30) from pyramid level 3 to 0:\n            &gt;&gt;&gt; z0, y0, x0 = plateA.convert_pixel_to_pixel(zyx=(0,10,30), pyramid_level_from=3, pyramid_level_to=0)\n        \"\"\"\n# digest arguments\npyramid_level_from = self._digest_pyramid_level_argument(pyramid_level_from)\npyramid_level_to = self._digest_pyramid_level_argument(pyramid_level_to)\n# convert\nif pyramid_ref_from[0] == 'image':\npyramid_spacing_from = self.level_zyx_spacing_images[pyramid_ref_from[1]][pyramid_level_from]\nelse:\npyramid_spacing_from = self.level_zyx_spacing_labels[pyramid_ref_from[1]][pyramid_level_from]\nif pyramid_ref_to[0] == 'image':\npyramid_spacing_to = self.level_zyx_spacing_images[pyramid_ref_to[1]][pyramid_level_to]\nelse:\npyramid_spacing_to = self.level_zyx_spacing_labels[pyramid_ref_to[1]][pyramid_level_to]\nzyx_scale = np.divide(pyramid_spacing_from, pyramid_spacing_to)\nzyx_new = np.round(np.multiply(zyx, zyx_scale)).astype(int)\n# return as tuple\nreturn(tuple(zyx_new))\n# analysis methods --------------------------------------------------------\ndef calc_average_FOV(self,\ninclude_wells: Union[str, list[str]]=[],\npyramid_level: Optional[int]=None,\nchannel: int=0) -&gt; np.ndarray:\n\"\"\"\n        Calculate the average field of view.\n        Using the coordinates stored in table 'FOV_ROI_table', calculate the averaged\n        field of view for wells in `include_wells`, for `channel` at resolution `pyramid_level`.\n        Parameters:\n            include_wells (str or list): List of well names to include. If empty `[]`, all wells are included.\n            pyramid_level (int): The pyramid level (resolution level), from which the image\n                should be extracted. If `None`, the lowest-resolution (highest) pyramid level\n                will be selected.\n            channel (int): The channel for which the fields of view should be averaged.\n        Returns:\n            The averaged field of view, as an array of shape (z,y,x).\n        Examples:\n            Calculate the averaged field of view for channel zero over all wells\n            for pyramid level 1.\n            &gt;&gt;&gt; avg_fov = plateA.calc_average_FOV(pyramid_level=1, channel=0)\n        \"\"\"\n# check if required data is available\nif not 'FOV_ROI_table' in self.table_names:\nraise ValueError(\"`FOV_ROI_table` not found - cannot calculate average FOV\")\n# digest arguments\ninclude_wells = self._digest_include_wells_argument(include_wells)\npyramid_level = self._digest_pyramid_level_argument(pyramid_level)\n# extract FOV table and scaling information\nfov_tab = self.get_table('FOV_ROI_table')\npyramid_spacing = self.level_zyx_spacing_images['0'][pyramid_level]\nassert len(pyramid_spacing) == 3\npyramid_spacing = pyramid_spacing[1:] # scale is (z, y, x), just keep y, x\n# sum FOVs\navg_fov = np.zeros((0))\nn = 0\nfor well, group in fov_tab.groupby('well'):\nwell = self._digest_well_argument(well)\nif well in include_wells:\n# load full well image\nimg_path = os.path.join(self.path, well, '0', str(pyramid_level))\nimg = dask.array.from_zarr(img_path)\n# calculate coordinates for `pyramid_level` that correspond to fields of view\nfov_yx_start_um = group[['y_micrometer', 'x_micrometer']].values\nfov_yx_end_um = fov_yx_start_um + group[['len_y_micrometer', 'len_x_micrometer']].values\nfov_yx_start_px = np.round(np.divide(fov_yx_start_um, pyramid_spacing)).astype(int)\nfov_yx_end_px = np.round(np.divide(fov_yx_end_um, pyramid_spacing)).astype(int)\nif len(avg_fov) == 0:\navg_fov = np.zeros((img.shape[1],\nfov_yx_end_px[0,0] - fov_yx_start_px[0,0],\nfov_yx_end_px[0,1] - fov_yx_start_px[0,1]))\n# add fields of view to `avg_fov`\nfor i in range(group.shape[0]):\nfov_img = img[:,\n:,\nslice(fov_yx_start_px[i,0], fov_yx_end_px[i,0]),\nslice(fov_yx_start_px[i,1], fov_yx_end_px[i,1])]\nn += 1\navg_fov += fov_img[channel].compute()\n# calculate mean\navg_fov /= n\nreturn(avg_fov)\n# plotting methods -----------------------------------------------------------\ndef plot_well(self,\nwell: str,\nupper_left_yx: Optional[tuple[int]]=None,\nlower_right_yx: Optional[tuple[int]]=None,\nsize_yx: Optional[tuple[int]]=None,\nimage_name: str='0',\nlabel_name: Optional[str]=None,\nlabel_alpha: float=0.3,\npyramid_level: Optional[int]=None,\npyramid_level_coord: Optional[int]=None,\nchannels: list[int]=[0],\nchannel_colors: list[str]=['white'],\nchannel_ranges: list[list[float]]=[[0.01, 0.95]],\nz_projection_method: str='maximum',\naxis_style: str='pixel',\ntitle: Optional[str]=None,\nscalebar_micrometer: int=0,\nscalebar_color: str='white',\nscalebar_position: str='bottomright',\nscalebar_label: bool=False,\ncall_show: bool=True,\nfig_width_inch: float=8.0,\nfig_height_inch: float=8.0,\nfig_dpi: int=200,\nfig_style: str='dark_background'):\n\"\"\"\n        Plot a well from a microtiter plate.\n        Plot an overview of a single well, for `channel` at\n        resolution `pyramid_level`.\n        Parameters:\n            well (str): The well (e.g. 'B03') to be plotted.\n            upper_left_yx (tuple): Tuple of (y, x) coordinates for the upper-left\n                (lower) coordinates defining the region of interest.\n            lower_right_yx (tuple): Tuple of (y, x) coordinates for the lower-right\n                (higher) coordinates defining the region of interest.\n            size_yx (tuple): Tuple of (size_y, size_x) defining the size of the\n                region of interest.\n            image_name (str): The name of the image in the well to be plotted.\n                Default: '0'.\n            label_name (str): The name of the a segmentation mask to be plotted\n                semi-transparently over the images. If `None`, just the image\n                is plotted.\n            label_alpha (float): A scalar value between 0 (fully transparent)\n                and 1 (solid) defining the transparency of the label masks.\n            pyramid_level (int): The pyramid level (resolution level), from\n                which the image should be extracted. If `None`, the\n                lowest-resolution (highest) pyramid level will be selected.\n            pyramid_level_coord (int): An optional integer scalar giving the image pyramid level\n                to which the coordinates (`upper_left_yx`, `lower_right_yx` and `size_yx`)\n                refer to. By default, this is `None`, which will use `pyramid_level`.\n            channels (list[int]): The image channel(s) to be plotted.\n            channel_colors (list[str]): A list with python color strings\n                (e.g. 'red') defining the color for each channel in `channels`.\n            channel_ranges (list[list[float]]): A list of 2-element lists\n                (e.g. [0.01, 0.95]) giving the value ranges that should be\n                mapped to colors for each channel. If the given numerical values\n                are less or equal to 1.0, they are interpreted as quantiles and\n                the corresponding intensity values are calculated on the channel\n                non-zero values, otherwise they are directly used as intensities.\n                Values outside of this range will be clipped.\n            z_projection_method (str): Method for combining multiple z planes.\n                For available methods, see ez_zarr.plotting.zproject\n                (default: 'maximum').\n            axis_style (str): A string scalar defining how to draw the axis. Should\n                be one of 'none' (no axis), 'pixel' (show pixel labels, the default)\n                or 'micrometer' (show micrometer labels). If `axis_style='micrometer'`,\n                `spacing_yx` is used to convert pixel to micrometer.\n            title (str): String scalar to add as title. If `None`, `well` will\n                be used as `title`.\n            scalebar_micrometer (int): If non-zero, add a scale bar corresponding\n                to `scalebar_micrometer` to the bottom right.\n            scalebar_label (bool): If `True`, add micrometer label to scale bar.\n            call_show (bool): If `True`, the call to `matplotlib.pyplot.imshow` is\n                embedded between `matplotlib.pyplot.figure` and\n                `matplotlib.pyplot.show`/`matplotlib.pyplot.close` calls.\n                This is the default behaviour and typically used when an individual\n                image should be plotted and displayed. It can be set to `False`\n                if multiple images should be plotted and their arrangement\n                is controlled outside of `plotting.plot_image`. The parameters\n                `fig_width_inch`, `fig_height_inch` and `fig_dpi` are ignored\n                in that case.\n            fig_width_inch (float): Figure width (in inches).\n            fig_height_inch (float): Figure height (in inches).\n            fig_dpi (int): Figure resolution (dots per inch).\n            fig_style (str): Style for the figure. Supported are 'brightfield', which\n                is a special mode for single-channel brightfield microscopic images\n                (it will automatically set `channels=[0]`, `channel_colors=['white']`\n                `z_projection_method='minimum'` and `fig_style='default'`), and any\n                other styles that can be passed to `matplotlib.pyplot.style.context`\n                (default: 'dark_background')\n        Examples:\n            Overview plot of the well 'B03'.\n            &gt;&gt;&gt; plateA.plot_well(well='B03')\n        \"\"\"\n# digest arguments\nwell = self._digest_well_argument(well, as_path=False)\nassert image_name in self.image_names, (\nf\"Unknown image_name ({image_name}), should be one of \"\n', '.join(self.image_names)\n)\nassert label_name == None or label_name in self.label_names, (\nf\"Unknown label_name ({label_name}), should be `None` or one of \"\n', '.join(self.label_names)\n)\nimg_pl = self._digest_pyramid_level_argument(pyramid_level=pyramid_level,\npyramid_ref=('image', image_name))\nassert all(ch &lt; len(self.channels) for ch in channels), (\nf\"Invalid channels ({channels}), must be less than {len(self.channels)}\"\n)\n# import optional modules\nplotting = importlib.import_module('ez_zarr.plotting')\n# get mask pyramid level corresponding to `img_pl`\nif label_name != None:\npl_match = [self.level_zyx_spacing_images[image_name][img_pl] == x\nfor x in self.level_zyx_spacing_labels[label_name]]\nassert sum(pl_match) == 1, (\nf\"Could not find a label pyramid level corresponding to the \"\nf\"selected image pyramid level ({img_pl})\"\n)\nmsk_pl = pl_match.index(True)\n# get well image\nimg = self.get_image_ROI(well=well,\nupper_left_yx=upper_left_yx,\nlower_right_yx=lower_right_yx,\nsize_yx=size_yx,\npyramid_level=img_pl,\npyramid_level_coord=pyramid_level_coord,\nas_NumPy=True)\nif label_name != None:\nmsk = self.get_label_ROI(label_name=label_name,\nwell=well,\nupper_left_yx=upper_left_yx,\nlower_right_yx=lower_right_yx,\nsize_yx=size_yx,\npyramid_level=msk_pl,\npyramid_level_coord=pyramid_level_coord,\nas_NumPy=True)\nassert img.shape[1:] == msk.shape, (\nf\"label {label_name} shape {msk.shape} does not match \"\nf\"image shape {img.shape} for well {well}\"\n)\nelse:\nmsk = None\n# calculate scalebar length in pixel in x direction\nif scalebar_micrometer != 0:\nscalebar_pixel = self.convert_micrometer_to_pixel(zyx = (0, 0, scalebar_micrometer),\npyramid_level=img_pl)[2]\nelse:\nscalebar_pixel = 0\n# plot well\nif title is None:\ntitle = well\nif scalebar_label:\nscalebar_label = str(scalebar_micrometer) + ' \u00b5m'\nelse:\nscalebar_label = None\nplotting.plot_image(im=img,\nmsk=msk,\nmsk_alpha=label_alpha,\nchannels=channels,\nchannel_colors=channel_colors,\nchannel_ranges=channel_ranges,\nz_projection_method=z_projection_method,\naxis_style=axis_style,\nspacing_yx=self.level_zyx_spacing_images[image_name][img_pl][1:],\ntitle=title,\nscalebar_pixel=scalebar_pixel,\nscalebar_color=scalebar_color,\nscalebar_position=scalebar_position,\nscalebar_label=scalebar_label,\ncall_show=call_show,\nfig_width_inch=fig_width_inch,\nfig_height_inch=fig_height_inch,\nfig_dpi=fig_dpi,\nfig_style=fig_style)\ndef plot_plate(self,\nimage_name: str='0',\nlabel_name: Optional[str]=None,\nlabel_alpha: float=0.3,\npyramid_level: Optional[int]=None,\nchannels: list[int]=[0],\nchannel_colors: list[str]=['white'],\nchannel_ranges: list[list[float]]=[[0.01, 0.95]],\nz_projection_method: str='maximum',\nplate_layout: str='96well',\nfig_title: Optional[str]=None,\nfig_width_inch: float=24.0,\nfig_height_inch: float=16.0,\nfig_dpi: int=200,\nfig_style: str='dark_background'):\n\"\"\"\n        Plot microtiter plate.\n        Plot an overview of all wells in plate arrangement, for `channel` at\n        resolution `pyramid_level`.\n        Parameters:\n            image_name (str): The name of the image in each well to be plotted.\n                Default: '0'.\n            label_name (str): The name of the segmentation mask to be plotted\n                semi-transparently over the images. If `None`, just the image\n                is plotted.\n            label_alpha (float): A scalar value between 0 (fully transparent)\n                and 1 (solid) defining the transparency of the label masks.\n            pyramid_level (int): The pyramid level (resolution level), from\n                which the image should be extracted. If `None`, the\n                lowest-resolution (highest) pyramid level will be selected.\n            channels (list[int]): The image channel(s) to be plotted.\n            channel_colors (list[str]): A list with python color strings\n                (e.g. 'red') defining the color for each channel in `channels`.\n            channel_ranges (list[list[float]]): A list of 2-element lists\n                (e.g. [0.01, 0.95]) giving the value ranges that should be\n                mapped to colors for each channel. If the given numerical values\n                are less or equal to 1.0, they are interpreted as quantiles and\n                the corresponding intensity values are calculated on the channel\n                non-zero values, otherwise they are directly used as intensities.\n                Values outside of this range will be clipped.\n            z_projection_method (str): Method for combining multiple z planes.\n                For available methods, see ez_zarr.plotting.zproject\n                (default: 'maximum').\n            plate_layout (str): Defines the layout of the plate\n                (default: '96well').\n            fig_title (str): String scalar to use as overall figure title\n                (default: the `.name` attribute of the object). Use `fig_title=''`\n                to not add any title to the plot.\n            fig_width_inch (float): Figure width (in inches).\n            fig_height_inch (float): Figure height (in inches).\n            fig_dpi (int): Figure resolution (dots per inch).\n            fig_style (str): Style for the figure. Supported are 'brightfield', which\n                is a special mode for single-channel brightfield microscopic images\n                (it will automatically set `channels=[0]`, `channel_colors=['white']`\n                `z_projection_method='minimum'` and `fig_style='default'`), and any\n                other styles that can be passed to `matplotlib.pyplot.style.context`\n                (default: 'dark_background')\n        Examples:\n            Overview plot of a plate for image channel 1.\n            &gt;&gt;&gt; plateA.plot_plate(channels=[1])\n        \"\"\"\n# digest arguments\nassert image_name in self.image_names, (\nf\"Unknown image_name ({image_name}), should be one of \"\n', '.join(self.image_names)\n)\nassert label_name == None or label_name in self.label_names, (\nf\"Unknown label_name ({label_name}), should be `None` or one of \"\n', '.join(self.label_names)\n)\nimg_pl = self._digest_pyramid_level_argument(pyramid_level=pyramid_level,\npyramid_ref=('image', image_name))\nassert all(ch &lt; len(self.channels) for ch in channels), (\nf\"Invalid channels ({channels}), must be less than {len(self.channels)}\"\n)\n# import optional modules\nplotting = importlib.import_module('ez_zarr.plotting')\nassert plate_layout in plotting.plate_layouts, (\nf\"Unknown plate_layout ({plate_layout}), should be one of \"\n', '.join(list(plotting.plate_layouts.keys()))\n)\nplt = importlib.import_module('matplotlib.pyplot')\n# plate layout\nrows = plotting.plate_layouts[plate_layout]['rows']\ncolumns = plotting.plate_layouts[plate_layout]['columns']\n# available wells\nwells = self.get_wells(simplify=True)\n# get mask pyramid level corresponding to `img_pl`\nif label_name != None:\npl_match = [self.level_zyx_spacing_images[image_name][img_pl] == x\nfor x in self.level_zyx_spacing_labels[label_name]]\nassert sum(pl_match) == 1, (\nf\"Could not find a label pyramid level corresponding to the \"\nf\"selected image pyramid level ({img_pl})\"\n)\nmsk_pl = pl_match.index(True)\n# get the maximal well y,x coordinates\nwell_dims = [self.get_image_ROI(well=w, pyramid_level=img_pl).shape[2:] for w in wells]\nmax_yx = np.max(np.stack(well_dims), axis=0)\n# adjust parameters for brightfield images\nif fig_style == 'brightfield':\nchannels = [0]\nchannel_colors = ['white']\nz_projection_method = 'minimum'\nfig_style = 'default'\nempty_well = np.ones(max_yx)\nelse:\nempty_well = np.zeros(max_yx)\n# define figure title\nif fig_title is None:\nfig_title = self.name\n# loop over wells\nwith plt.style.context(fig_style):\nfig = plt.figure(figsize=(fig_width_inch, fig_height_inch))\nfig.set_dpi(fig_dpi)\nif fig_title != '':\nfig.suptitle(fig_title, size='xx-large') # default title size: 'large'\nfor r in range(len(rows)):\nfor c in range(len(columns)):\nw = rows[r] + columns[c]\nplt.subplot(len(rows), len(columns), r * len(columns) + c + 1)\nif w in wells:\n# get well image\nimg = self.get_image_ROI(well=w,\npyramid_level=img_pl,\nas_NumPy=True)\nimg_shape_before_padding = img.shape\n# add segmentation mask on top\nif label_name != None:\n# get well label\nmsk = self.get_label_ROI(label_name=label_name,\nwell=w,\npyramid_level=msk_pl,\nas_NumPy=True)\nassert img_shape_before_padding[1:] == msk.shape, (\nf\"label {label_name} shape {msk.shape} does not match \"\nf\"image shape {img_shape_before_padding} for well {w}\"\n)\nelse:\nmsk = None\n# plot well\nplotting.plot_image(im=img,\nmsk=msk,\nmsk_alpha=label_alpha,\nchannels=channels,\nchannel_colors=channel_colors,\nchannel_ranges=channel_ranges,\nz_projection_method=z_projection_method,\npad_to_yx=max_yx,\naxis_style='frame',\ntitle=w,\ncall_show=False)\nelse:\n# plot empty well\nplt.imshow(empty_well, cmap='gray', vmin=0, vmax=1)\nplt.xticks([]) # remove axis ticks\nplt.yticks([])\nplt.title(w)\nfig.tight_layout()\nplt.show()\nplt.close()\n</code></pre>"},{"location":"hcs_wrappers/#src.ez_zarr.hcs_wrappers.FractalZarr.__init__","title":"<code>__init__(zarr_path, name=None)</code>","text":"<p>Initializes an OME-Zarr fileset (.zarr) from its path. Typically, the fileset represents a single assay plate, and  we assume that the structures (pyramid levels, labels, tables, etc.) are consistent across wells.</p> <p>Parameters:</p> Name Type Description Default <code>zarr_path</code> <code>str</code> <p>Path containing the plate ome-zarr fileset.</p> required <code>name</code> <code>str</code> <p>Optional name for the plate.</p> <code>None</code> <p>Examples:</p> <p>Get an object corresponding to a plate.</p> <pre><code>&gt;&gt;&gt; from ez_zarr import hcs_wrappers\n&gt;&gt;&gt; plateA = hcs_wrappers.FractalZarr('path/to/plate.zarr')\n&gt;&gt;&gt; plateA\n</code></pre> <p>This will print information about the plate.</p> Source code in <code>src/ez_zarr/hcs_wrappers.py</code> <pre><code>def __init__(self, zarr_path: str, name: Optional[str]=None) -&gt; None:\n\"\"\"\n    Initializes an OME-Zarr fileset (.zarr) from its path.\n    Typically, the fileset represents a single assay plate, and \n    we assume that the structures (pyramid levels, labels, tables, etc.)\n    are consistent across wells.\n    Parameters:\n        zarr_path (str): Path containing the plate ome-zarr fileset.\n        name (str, optional): Optional name for the plate.\n    Examples:\n        Get an object corresponding to a plate.\n        &gt;&gt;&gt; from ez_zarr import hcs_wrappers\n        &gt;&gt;&gt; plateA = hcs_wrappers.FractalZarr('path/to/plate.zarr')\n        &gt;&gt;&gt; plateA\n        This will print information about the plate.\n    \"\"\"\nself.path: str = zarr_path\nself.name: str = ''\nif name:\nself.name = name\nelse:\nself.name = os.path.basename(self.path)\nself.__top: zarr.Group = zarr.open(store=self.path, mode='r')\nif not 'plate' in self.__top.attrs:\nraise ValueError(f\"{self.name} does not contain a zarr fileset with a 'plate'\")\nself.acquisitions: list = self.__top.attrs['plate']['acquisitions']\nself.columns: list[dict] = self.__top.attrs['plate']['columns']\nself.rows: list[dict] = self.__top.attrs['plate']['rows']\nself.wells: list[dict] = self.__top.attrs['plate']['wells']\n# images\nself.image_names: list[str] = self._load_image_names()\nself.channels: list[dict] = self._load_channel_info()\nself.multiscales_images: dict[str, Any] = self._load_multiscale_info('images')\nself.level_paths_images: dict[str, list[str]] = {im: [x['path'] for x in self.multiscales_images[im]['datasets']] for im in self.image_names}\nself.level_zyx_spacing_images: dict[str, list[list[float]]] = {im: [x['coordinateTransformations'][0]['scale'][1:] for x in self.multiscales_images[im]['datasets']] for im in self.image_names} # convention: unit is micrometer\nself.level_zyx_scalefactor: dict[str, np.ndarray] = {im: np.divide(self.level_zyx_spacing_images[im][1], self.level_zyx_spacing_images[im][0]) for im in self.image_names}\n# labels\nself.label_names: list[str] = self._load_label_names()\nself.multiscales_labels: dict[str, Any] = self._load_multiscale_info('labels')\nself.level_paths_labels: dict[str, list[str]] = {lab: [x['path'] for x in self.multiscales_labels[lab]['datasets']] for lab in self.label_names}\nself.level_zyx_spacing_labels: dict[str, list[list[float]]] = {lab: [x['coordinateTransformations'][0]['scale'] for x in self.multiscales_labels[lab]['datasets']] for lab in self.label_names} # convention: unit is micrometer\n# tables\nself.table_names: list[str] = self._load_table_names()\n</code></pre>"},{"location":"hcs_wrappers/#src.ez_zarr.hcs_wrappers.FractalZarr.calc_average_FOV","title":"<code>calc_average_FOV(include_wells=[], pyramid_level=None, channel=0)</code>","text":"<p>Calculate the average field of view.</p> <p>Using the coordinates stored in table 'FOV_ROI_table', calculate the averaged field of view for wells in <code>include_wells</code>, for <code>channel</code> at resolution <code>pyramid_level</code>.</p> <p>Parameters:</p> Name Type Description Default <code>include_wells</code> <code>str or list</code> <p>List of well names to include. If empty <code>[]</code>, all wells are included.</p> <code>[]</code> <code>pyramid_level</code> <code>int</code> <p>The pyramid level (resolution level), from which the image should be extracted. If <code>None</code>, the lowest-resolution (highest) pyramid level will be selected.</p> <code>None</code> <code>channel</code> <code>int</code> <p>The channel for which the fields of view should be averaged.</p> <code>0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The averaged field of view, as an array of shape (z,y,x).</p> <p>Examples:</p> <p>Calculate the averaged field of view for channel zero over all wells for pyramid level 1.</p> <pre><code>&gt;&gt;&gt; avg_fov = plateA.calc_average_FOV(pyramid_level=1, channel=0)\n</code></pre> Source code in <code>src/ez_zarr/hcs_wrappers.py</code> <pre><code>def calc_average_FOV(self,\ninclude_wells: Union[str, list[str]]=[],\npyramid_level: Optional[int]=None,\nchannel: int=0) -&gt; np.ndarray:\n\"\"\"\n    Calculate the average field of view.\n    Using the coordinates stored in table 'FOV_ROI_table', calculate the averaged\n    field of view for wells in `include_wells`, for `channel` at resolution `pyramid_level`.\n    Parameters:\n        include_wells (str or list): List of well names to include. If empty `[]`, all wells are included.\n        pyramid_level (int): The pyramid level (resolution level), from which the image\n            should be extracted. If `None`, the lowest-resolution (highest) pyramid level\n            will be selected.\n        channel (int): The channel for which the fields of view should be averaged.\n    Returns:\n        The averaged field of view, as an array of shape (z,y,x).\n    Examples:\n        Calculate the averaged field of view for channel zero over all wells\n        for pyramid level 1.\n        &gt;&gt;&gt; avg_fov = plateA.calc_average_FOV(pyramid_level=1, channel=0)\n    \"\"\"\n# check if required data is available\nif not 'FOV_ROI_table' in self.table_names:\nraise ValueError(\"`FOV_ROI_table` not found - cannot calculate average FOV\")\n# digest arguments\ninclude_wells = self._digest_include_wells_argument(include_wells)\npyramid_level = self._digest_pyramid_level_argument(pyramid_level)\n# extract FOV table and scaling information\nfov_tab = self.get_table('FOV_ROI_table')\npyramid_spacing = self.level_zyx_spacing_images['0'][pyramid_level]\nassert len(pyramid_spacing) == 3\npyramid_spacing = pyramid_spacing[1:] # scale is (z, y, x), just keep y, x\n# sum FOVs\navg_fov = np.zeros((0))\nn = 0\nfor well, group in fov_tab.groupby('well'):\nwell = self._digest_well_argument(well)\nif well in include_wells:\n# load full well image\nimg_path = os.path.join(self.path, well, '0', str(pyramid_level))\nimg = dask.array.from_zarr(img_path)\n# calculate coordinates for `pyramid_level` that correspond to fields of view\nfov_yx_start_um = group[['y_micrometer', 'x_micrometer']].values\nfov_yx_end_um = fov_yx_start_um + group[['len_y_micrometer', 'len_x_micrometer']].values\nfov_yx_start_px = np.round(np.divide(fov_yx_start_um, pyramid_spacing)).astype(int)\nfov_yx_end_px = np.round(np.divide(fov_yx_end_um, pyramid_spacing)).astype(int)\nif len(avg_fov) == 0:\navg_fov = np.zeros((img.shape[1],\nfov_yx_end_px[0,0] - fov_yx_start_px[0,0],\nfov_yx_end_px[0,1] - fov_yx_start_px[0,1]))\n# add fields of view to `avg_fov`\nfor i in range(group.shape[0]):\nfov_img = img[:,\n:,\nslice(fov_yx_start_px[i,0], fov_yx_end_px[i,0]),\nslice(fov_yx_start_px[i,1], fov_yx_end_px[i,1])]\nn += 1\navg_fov += fov_img[channel].compute()\n# calculate mean\navg_fov /= n\nreturn(avg_fov)\n</code></pre>"},{"location":"hcs_wrappers/#src.ez_zarr.hcs_wrappers.FractalZarr.convert_micrometer_to_pixel","title":"<code>convert_micrometer_to_pixel(zyx, pyramid_level=None, pyramid_ref=('image', '0'))</code>","text":"<p>Convert micrometers to pixels for a given pyramid level.</p> <p>Parameters:</p> Name Type Description Default <code>zyx</code> <code>tuple</code> <p>The micrometer coordinates in the form (z, y, x) to be converted to pixels.</p> required <code>pyramid_level</code> <code>int</code> <p>The pyramid level (resolution), which the output pixel coordinates will refer to.  If <code>None</code>, the lowest-resolution (highest) pyramid level will be selected.</p> <code>None</code> <code>pyramid_ref</code> <code>tuple(str, str</code> <p>The reference that the <code>pyramid_level</code> refers to. It is given as a tuple with two <code>str</code> elements, the first being either 'image' or 'label', and the second being the name of the image or label. The default is ('image', '0').</p> <code>('image', '0')</code> <p>Returns:</p> Type Description <code>tuple[int]</code> <p>A tuple (z, y, x) with pixel coordinates.</p> <p>Examples:</p> <p>Obtain the x-length (x_px) of a scale bar corresopnding to 10 micrometer for pyramid level 0:</p> <pre><code>&gt;&gt;&gt; z_px, y_px, x_px = plateA.convert_micrometer_to_pixel(zyx=(0,0,10), pyramid_level=0)\n</code></pre> Source code in <code>src/ez_zarr/hcs_wrappers.py</code> <pre><code>def convert_micrometer_to_pixel(self,\nzyx: tuple[float],\npyramid_level: Optional[int]=None,\npyramid_ref: tuple[str]=('image', '0')) -&gt; tuple[int]:\n\"\"\"\n    Convert micrometers to pixels for a given pyramid level.\n    Parameters:\n        zyx (tuple): The micrometer coordinates in the form (z, y, x) to be converted\n            to pixels.\n        pyramid_level (int): The pyramid level (resolution), which the output\n            pixel coordinates will refer to.  If `None`, the lowest-resolution\n            (highest) pyramid level will be selected.\n        pyramid_ref (tuple(str, str)): The reference that the `pyramid_level` refers\n            to. It is given as a tuple with two `str` elements, the first being\n            either 'image' or 'label', and the second being the name of the\n            image or label. The default is ('image', '0').\n    Returns:\n        A tuple (z, y, x) with pixel coordinates.\n    Examples:\n        Obtain the x-length (x_px) of a scale bar corresopnding to 10 micrometer for\n        pyramid level 0:\n        &gt;&gt;&gt; z_px, y_px, x_px = plateA.convert_micrometer_to_pixel(zyx=(0,0,10), pyramid_level=0)\n    \"\"\"\n# digest arguments\nassert isinstance(zyx, tuple), \"zyx needs to be a tuple of the form (z,y,x)\"\npyramid_level = self._digest_pyramid_level_argument(pyramid_level)\n# convert\nif pyramid_ref[0] == 'image':\npyramid_spacing = self.level_zyx_spacing_images[pyramid_ref[1]][pyramid_level]\nelse:\npyramid_spacing = self.level_zyx_spacing_labels[pyramid_ref[1]][pyramid_level]\nzyx_px = np.round(np.divide(zyx, pyramid_spacing)).astype(int)\n# return as tuple\nreturn(tuple(zyx_px))\n</code></pre>"},{"location":"hcs_wrappers/#src.ez_zarr.hcs_wrappers.FractalZarr.convert_pixel_to_micrometer","title":"<code>convert_pixel_to_micrometer(zyx, pyramid_level=None, pyramid_ref=('image', '0'))</code>","text":"<p>Convert pixels to micrometers for a given pyramid level.</p> <p>Parameters:</p> Name Type Description Default <code>zyx</code> <code>tuple</code> <p>The pixel coordinates in the form (z, y, x) to be converted to micrometers.</p> required <code>pyramid_level</code> <code>int</code> <p>The pyramid level (resolution), which the input pixel coordinates refer to. If <code>None</code>, the lowest-resolution (highest) pyramid level will be selected.</p> <code>None</code> <code>pyramid_ref</code> <code>tuple(str, str</code> <p>The reference that the <code>pyramid_level</code> refers to. It is given as a tuple with two <code>str</code> elements, the first being either 'image' or 'label', and the second being the name of the image or label. The default is ('image', '0').</p> <code>('image', '0')</code> <p>Returns:</p> Type Description <code>tuple[float]</code> <p>A tuple (z, y, x) with micrometer coordinates.</p> <p>Examples:</p> <p>Obtain the micrometer dimensions of a cube with 10 pixel sides for pyramid level 0:</p> <pre><code>&gt;&gt;&gt; z_um, y_um, x_um = plateA.convert_pixel_to_micrometer(zyx=(10,10,10), pyramid_level=0)\n</code></pre> Source code in <code>src/ez_zarr/hcs_wrappers.py</code> <pre><code>def convert_pixel_to_micrometer(self,\nzyx: tuple[int],\npyramid_level: Optional[int]=None,\npyramid_ref: tuple[str]=('image', '0')) -&gt; tuple[float]:\n\"\"\"\n    Convert pixels to micrometers for a given pyramid level.\n    Parameters:\n        zyx (tuple): The pixel coordinates in the form (z, y, x) to be converted\n            to micrometers.\n        pyramid_level (int): The pyramid level (resolution), which the input\n            pixel coordinates refer to. If `None`, the lowest-resolution\n            (highest) pyramid level will be selected.\n        pyramid_ref (tuple(str, str)): The reference that the `pyramid_level` refers\n            to. It is given as a tuple with two `str` elements, the first being\n            either 'image' or 'label', and the second being the name of the\n            image or label. The default is ('image', '0').\n    Returns:\n        A tuple (z, y, x) with micrometer coordinates.\n    Examples:\n        Obtain the micrometer dimensions of a cube with 10 pixel sides for pyramid level 0:\n        &gt;&gt;&gt; z_um, y_um, x_um = plateA.convert_pixel_to_micrometer(zyx=(10,10,10), pyramid_level=0)\n    \"\"\"\n# digest arguments\npyramid_level = self._digest_pyramid_level_argument(pyramid_level)\n# convert\nif pyramid_ref[0] == 'image':\npyramid_spacing = self.level_zyx_spacing_images[pyramid_ref[1]][pyramid_level]\nelse:\npyramid_spacing = self.level_zyx_spacing_labels[pyramid_ref[1]][pyramid_level]\nzyx_um = np.round(np.multiply(zyx, pyramid_spacing)).astype(float)\n# return as tuple\nreturn(tuple(zyx_um))\n</code></pre>"},{"location":"hcs_wrappers/#src.ez_zarr.hcs_wrappers.FractalZarr.convert_pixel_to_pixel","title":"<code>convert_pixel_to_pixel(zyx, pyramid_level_from=None, pyramid_level_to=None, pyramid_ref_from=('image', '0'), pyramid_ref_to=('image', '0'))</code>","text":"<p>Convert pixel coordinates between pyramid levels.</p> <p>Parameters:</p> Name Type Description Default <code>zyx</code> <code>tuple</code> <p>The pixel coordinates in the form (z, y, x) to be converted.</p> required <code>pyramid_level_from</code> <code>int</code> <p>The pyramid level (resolution), which the input pixel coordinates refer to. If <code>None</code>, the lowest-resolution (highest) pyramid level will be selected.</p> <code>None</code> <code>pyramid_level_to</code> <code>int</code> <p>The pyramid level (resolution), which the output pixel coordinates will refer to. If <code>None</code>, the lowest-resolution (highest) pyramid level will be selected.</p> <code>None</code> <code>pyramid_ref_from</code> <code>tuple(str, str</code> <p>The reference that the <code>pyramid_level_from</code> refers to. It is given as a tuple with two <code>str</code> elements, the first being either 'image' or 'label', and the second being the name of the image or label. The default is ('image', '0').</p> <code>('image', '0')</code> <code>pyramid_ref_to</code> <code>tuple(str, str</code> <p>The reference that the <code>pyramid_level_to</code> refers to. It is given as a tuple with two <code>str</code> elements, the first being either 'image' or 'label', and the second being the name of the image or label. The default is ('image', '0').</p> <code>('image', '0')</code> <p>Returns:</p> Type Description <code>tuple[int]</code> <p>A tuple (z, y, x) with pixel coordinates in the new pyramid level.</p> <p>Examples:</p> <p>Convert a point (0, 10, 30) from pyramid level 3 to 0:</p> <pre><code>&gt;&gt;&gt; z0, y0, x0 = plateA.convert_pixel_to_pixel(zyx=(0,10,30), pyramid_level_from=3, pyramid_level_to=0)\n</code></pre> Source code in <code>src/ez_zarr/hcs_wrappers.py</code> <pre><code>def convert_pixel_to_pixel(self,\nzyx: tuple[int],\npyramid_level_from: Optional[int]=None,\npyramid_level_to: Optional[int]=None,\npyramid_ref_from: tuple[str]=('image', '0'),\npyramid_ref_to: tuple[str]=('image', '0')) -&gt; tuple[int]:\n\"\"\"\n    Convert pixel coordinates between pyramid levels.\n    Parameters:\n        zyx (tuple): The pixel coordinates in the form (z, y, x) to be converted.\n        pyramid_level_from (int): The pyramid level (resolution), which the input\n            pixel coordinates refer to. If `None`, the lowest-resolution\n            (highest) pyramid level will be selected.\n        pyramid_level_to (int): The pyramid level (resolution), which the output\n            pixel coordinates will refer to. If `None`, the lowest-resolution\n            (highest) pyramid level will be selected.\n        pyramid_ref_from (tuple(str, str)): The reference that the `pyramid_level_from` refers\n            to. It is given as a tuple with two `str` elements, the first being\n            either 'image' or 'label', and the second being the name of the\n            image or label. The default is ('image', '0').\n        pyramid_ref_to (tuple(str, str)): The reference that the `pyramid_level_to` refers\n            to. It is given as a tuple with two `str` elements, the first being\n            either 'image' or 'label', and the second being the name of the\n            image or label. The default is ('image', '0').\n    Returns:\n        A tuple (z, y, x) with pixel coordinates in the new pyramid level.\n    Examples:\n        Convert a point (0, 10, 30) from pyramid level 3 to 0:\n        &gt;&gt;&gt; z0, y0, x0 = plateA.convert_pixel_to_pixel(zyx=(0,10,30), pyramid_level_from=3, pyramid_level_to=0)\n    \"\"\"\n# digest arguments\npyramid_level_from = self._digest_pyramid_level_argument(pyramid_level_from)\npyramid_level_to = self._digest_pyramid_level_argument(pyramid_level_to)\n# convert\nif pyramid_ref_from[0] == 'image':\npyramid_spacing_from = self.level_zyx_spacing_images[pyramid_ref_from[1]][pyramid_level_from]\nelse:\npyramid_spacing_from = self.level_zyx_spacing_labels[pyramid_ref_from[1]][pyramid_level_from]\nif pyramid_ref_to[0] == 'image':\npyramid_spacing_to = self.level_zyx_spacing_images[pyramid_ref_to[1]][pyramid_level_to]\nelse:\npyramid_spacing_to = self.level_zyx_spacing_labels[pyramid_ref_to[1]][pyramid_level_to]\nzyx_scale = np.divide(pyramid_spacing_from, pyramid_spacing_to)\nzyx_new = np.round(np.multiply(zyx, zyx_scale)).astype(int)\n# return as tuple\nreturn(tuple(zyx_new))\n</code></pre>"},{"location":"hcs_wrappers/#src.ez_zarr.hcs_wrappers.FractalZarr.get_channels","title":"<code>get_channels()</code>","text":"<p>Get info on channels in an OME-Zarr fileset.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of dicts with information on channels.</p> Source code in <code>src/ez_zarr/hcs_wrappers.py</code> <pre><code>def get_channels(self) -&gt; list:\n\"\"\"Get info on channels in an OME-Zarr fileset.\n    Returns:\n        A list of dicts with information on channels.\n    \"\"\"\nreturn self.channels\n</code></pre>"},{"location":"hcs_wrappers/#src.ez_zarr.hcs_wrappers.FractalZarr.get_image_ROI","title":"<code>get_image_ROI(upper_left_yx=None, lower_right_yx=None, size_yx=None, well=None, image_name='0', pyramid_level=None, pyramid_level_coord=None, as_NumPy=False)</code>","text":"<p>Extract a region of interest from a well image by coordinates.</p> <p>None or exactly two of <code>upper_left_yx</code>, <code>lower_right_yx</code> and <code>size_yx</code> need to be given. If none are given, it will return the full image (the whole well). Otherwise, <code>upper_left_yx</code> contains the lower indices than <code>lower_right_yx</code> (origin on the top-left, zero-based coordinates), and each of them is a tuple of (y, x). No z coordinate needs to be given, all z planes are returned if there are several ones.</p> <p>Parameters:</p> Name Type Description Default <code>upper_left_yx</code> <code>tuple</code> <p>Tuple of (y, x) coordinates for the upper-left (lower) coordinates defining the region of interest.</p> <code>None</code> <code>lower_right_yx</code> <code>tuple</code> <p>Tuple of (y, x) coordinates for the lower-right (higher) coordinates defining the region of interest.</p> <code>None</code> <code>size_yx</code> <code>tuple</code> <p>Tuple of (size_y, size_x) defining the size of the region of interest.</p> <code>None</code> <code>well</code> <code>str</code> <p>The well (e.g. 'B03') from which an image should be extracted.</p> <code>None</code> <code>image_name</code> <code>str</code> <p>The name of the image in <code>well</code> to extract from. Default: '0'.</p> <code>'0'</code> <code>pyramid_level</code> <code>int</code> <p>The pyramid level (resolution level), from which the image should be extracted. If <code>None</code>, the lowest-resolution (highest) pyramid level will be selected.</p> <code>None</code> <code>pyramid_level_coord</code> <code>int</code> <p>An optional integer scalar giving the image pyramid level to which the coordinates (<code>upper_left_yx</code>, <code>lower_right_yx</code> and <code>size_yx</code>) refer to. By default, this is <code>None</code>, which will use <code>pyramid_level</code>.</p> <code>None</code> <code>as_NumPy</code> <code>bool</code> <p>If <code>True</code>, return the image as 4D <code>numpy.ndarray</code> object (c,z,y,x). Otherwise, return the (on-disk) <code>dask</code> array of the same dimensions.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[Array, ndarray]</code> <p>The extracted image, either as a <code>dask.array.Array</code> on-disk array, or as an in-memory <code>numpy.ndarray</code> if <code>as_NumPy=True</code>.</p> <p>Examples:</p> <p>Obtain the image of the lowest-resolution for the full well 'A02':</p> <pre><code>&gt;&gt;&gt; plateA.get_image_ROI(well='A02')\n</code></pre> Source code in <code>src/ez_zarr/hcs_wrappers.py</code> <pre><code>def get_image_ROI(self,\nupper_left_yx: Optional[tuple[int]]=None,\nlower_right_yx: Optional[tuple[int]]=None,\nsize_yx: Optional[tuple[int]]=None,\nwell: Optional[str]=None,\nimage_name: str='0',\npyramid_level: Optional[int]=None,\npyramid_level_coord: Optional[int]=None,\nas_NumPy: bool=False) -&gt; Union[dask.array.Array, np.ndarray]:\n\"\"\"\n    Extract a region of interest from a well image by coordinates.\n    None or exactly two of `upper_left_yx`, `lower_right_yx` and `size_yx` need to be given.\n    If none are given, it will return the full image (the whole well).\n    Otherwise, `upper_left_yx` contains the lower indices than `lower_right_yx`\n    (origin on the top-left, zero-based coordinates), and each of them is\n    a tuple of (y, x). No z coordinate needs to be given, all z planes are returned\n    if there are several ones.\n    Parameters:\n        upper_left_yx (tuple): Tuple of (y, x) coordinates for the upper-left (lower) coordinates\n            defining the region of interest.\n        lower_right_yx (tuple): Tuple of (y, x) coordinates for the lower-right (higher) coordinates defining the region of interest.\n        size_yx (tuple): Tuple of (size_y, size_x) defining the size of the region of interest.\n        well (str): The well (e.g. 'B03') from which an image should be extracted.\n        image_name (str): The name of the image in `well` to extract from. Default: '0'.\n        pyramid_level (int): The pyramid level (resolution level), from which the image\n            should be extracted. If `None`, the lowest-resolution (highest) pyramid level\n            will be selected.\n        pyramid_level_coord (int): An optional integer scalar giving the image pyramid level\n            to which the coordinates (`upper_left_yx`, `lower_right_yx` and `size_yx`)\n            refer to. By default, this is `None`, which will use `pyramid_level`.\n        as_NumPy (bool): If `True`, return the image as 4D `numpy.ndarray` object (c,z,y,x).\n            Otherwise, return the (on-disk) `dask` array of the same dimensions.\n    Returns:\n        The extracted image, either as a `dask.array.Array` on-disk array, or as an in-memory `numpy.ndarray` if `as_NumPy=True`.\n    Examples:\n        Obtain the image of the lowest-resolution for the full well 'A02':\n        &gt;&gt;&gt; plateA.get_image_ROI(well='A02')\n    \"\"\"\n# digest arguments\nwell = self._digest_well_argument(well)\npyramid_level = self._digest_pyramid_level_argument(pyramid_level, ('image', image_name))\n# load image\nimg_path = os.path.join(self.path, well, image_name, str(pyramid_level))\nimg = dask.array.from_zarr(img_path)\n# calculate corner coordinates and subset if needed\n# (images are always of 4D shape c,z,y,x)\nnum_unknowns = sum([x == None for x in [upper_left_yx, lower_right_yx, size_yx]])\nif num_unknowns == 1:\nif size_yx:\nassert all([x &gt; 0 for x in size_yx]), 'size_yx values need to be positive'\nif not upper_left_yx:\nupper_left_yx = tuple(lower_right_yx[i] - size_yx[i] for i in range(2))\nelif not lower_right_yx:\nlower_right_yx = tuple(upper_left_yx[i] + size_yx[i] for i in range(2))\nassert all([upper_left_yx[i] &lt; lower_right_yx[i] for i in range(len(upper_left_yx))]), 'upper_left_yx needs to be less than lower_right_yx'\n# convert coordinates if needed\nif pyramid_level_coord != None and pyramid_level != pyramid_level_coord:\nupper_left_yx = self.convert_pixel_to_pixel(zyx=((0,) + upper_left_yx),\npyramid_level_from=pyramid_level_coord,\npyramid_level_to=pyramid_level,\npyramid_ref_from=('image', image_name),\npyramid_ref_to=('image', image_name))[1:]\nlower_right_yx = self.convert_pixel_to_pixel(zyx=((0,) + lower_right_yx),\npyramid_level_from=pyramid_level_coord,\npyramid_level_to=pyramid_level,\npyramid_ref_from=('image', image_name),\npyramid_ref_to=('image', image_name))[1:]\nimg = img[:,\n:,\nslice(upper_left_yx[0], lower_right_yx[0] + 1),\nslice(upper_left_yx[1], lower_right_yx[1] + 1)]\nelif num_unknowns != 3:\nraise ValueError(\"Either none or two of `upper_left_yx`, `lower_right_yx` and `size_yx` have to be given\")\n# convert if needed and return\nif as_NumPy:\nimg = np.array(img)\nreturn img\n</code></pre>"},{"location":"hcs_wrappers/#src.ez_zarr.hcs_wrappers.FractalZarr.get_image_grid_ROIs","title":"<code>get_image_grid_ROIs(well=None, pyramid_level=None, lowres_level=None, num_y=10, num_x=10, num_select=9, sample_method='sum', channel=0, seed=42, as_NumPy=False)</code>","text":"<p>Split a well image into a regular grid and extract a subset of grid cells (all z planes if several).</p> <p><code>num_y</code> and <code>num_x</code> define the grid by specifying the number of cells in y and x. <code>num_select</code> grid cells are picked from the total number and returned as a list. All returned grid cells are guaranteed to be of equal size, but a few pixels from the image may not be included in grid cells of the last row or column if the image shape is not divisible by <code>num_y</code> or <code>num_x</code>.</p> <p>Parameters:</p> Name Type Description Default <code>well</code> <code>str</code> <p>The well (e.g. 'B03') from which an image should be extracted.</p> <code>None</code> <code>pyramid_level</code> <code>int</code> <p>The pyramid level (resolution level), from which the selected image grid cells should be returned. If <code>None</code>, the lowest-resolution (highest) pyramid level will be selected.</p> <code>None</code> <code>lowres_level</code> <code>int</code> <p>Similar to <code>pyramid_level</code>, but defining the resolution for calculating the <code>sample_method</code>. Calculations on low-resolution images are faster and often result in identical ordering of grid cells, so that high-resolution images can be returned by <code>pyramid_level</code> without making their sampling slower.</p> <code>None</code> <code>num_y</code> <code>int</code> <p>The size of the grid in y.</p> <code>10</code> <code>num_x</code> <code>int</code> <p>The size of the grid in x.</p> <code>10</code> <code>num_select</code> <code>int</code> <p>The number of grid cells to return as images.</p> <code>9</code> <code>sample_method</code> <code>str</code> <p>Defines how the <code>num_select</code> cells are selected. Possible values are: - 'sum': order grid cells decreasingly by the sum of <code>channel</code> (working on <code>lowres_level</code>) - 'var': order grid cells decreasingly by the variance of <code>channel</code> (working on <code>lowres_level</code>) - 'random': order grid cells randomly (use <code>seed</code>)</p> <code>'sum'</code> <code>channel</code> <code>int</code> <p>Selects the channel on which <code>sample_method</code> is calculated.</p> <code>0</code> <code>seed</code> <code>int</code> <p>Used in <code>random.seed()</code> to make sampling for <code>sample_method='random'</code> reproducible.</p> <code>42</code> <code>as_NumPy</code> <code>bool</code> <p>If <code>True</code>, return the grid cell image as <code>numpy.ndarray</code> objects with shapes (c,z,y,x). Otherwise, return the (on-disk) <code>dask</code> arrays of the same dimensions.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[tuple[list[tuple[int]], list[Array]], tuple[list[tuple[int]], list[ndarray]]]</code> <p>A tuple of two lists (coord_list, img_list), each with <code>num_select</code> elements  corresponding to the coordinates and images of selected grid cells.  The coordinates are tuples of the form  (y_start, y_end, x_start, x_end).</p> <p>Examples:</p> <p>Obtain grid cells with highest signal sum in channel 0 from well 'A02':</p> <pre><code>&gt;&gt;&gt; plateA.get_image_grid_ROIs(well='A02')\n</code></pre> Source code in <code>src/ez_zarr/hcs_wrappers.py</code> <pre><code>def get_image_grid_ROIs(self,\nwell: Optional[str]=None,\npyramid_level: Optional[int]=None,\nlowres_level: Optional[int]=None,\nnum_y: int=10,\nnum_x: int=10,\nnum_select: int=9,\nsample_method: str='sum',\nchannel: int=0,\nseed: int=42,\nas_NumPy: bool=False) -&gt; Union[tuple[list[tuple[int]], list[dask.array.Array]], tuple[list[tuple[int]], list[np.ndarray]]]:\n\"\"\"\n    Split a well image into a regular grid and extract a subset of grid cells (all z planes if several).\n    `num_y` and `num_x` define the grid by specifying the number of cells in y and x.\n    `num_select` grid cells are picked from the total number and returned as a list.\n    All returned grid cells are guaranteed to be of equal size, but a few pixels from the image\n    may not be included in grid cells of the last row or column if the image shape\n    is not divisible by `num_y` or `num_x`.\n    Parameters:\n        well (str):  The well (e.g. 'B03') from which an image should be extracted.\n        pyramid_level (int): The pyramid level (resolution level), from which the\n            selected image grid cells should be returned. If `None`, the lowest-resolution\n            (highest) pyramid level will be selected.\n        lowres_level (int): Similar to `pyramid_level`, but defining the resolution\n            for calculating the `sample_method`. Calculations on low-resolution\n            images are faster and often result in identical ordering of grid cells,\n            so that high-resolution images can be returned by `pyramid_level` without making\n            their sampling slower.\n        num_y (int): The size of the grid in y.\n        num_x (int): The size of the grid in x.\n        num_select (int): The number of grid cells to return as images.\n        sample_method (str): Defines how the `num_select` cells are selected. Possible values are:\n            - 'sum': order grid cells decreasingly by the sum of `channel` (working on `lowres_level`)\n            - 'var': order grid cells decreasingly by the variance of `channel` (working on `lowres_level`)\n            - 'random': order grid cells randomly (use `seed`)\n        channel (int): Selects the channel on which `sample_method` is calculated.\n        seed (int): Used in `random.seed()` to make sampling for `sample_method='random'` reproducible.\n        as_NumPy (bool): If `True`, return the grid cell image as `numpy.ndarray` objects with\n            shapes (c,z,y,x). Otherwise, return the (on-disk) `dask` arrays of the same dimensions.\n    Returns:\n        A tuple of two lists (coord_list, img_list), each with `num_select` elements \n            corresponding to the coordinates and images of selected grid cells. \n            The coordinates are tuples of the form  (y_start, y_end, x_start, x_end).\n    Examples:\n        Obtain grid cells with highest signal sum in channel 0 from well 'A02':\n        &gt;&gt;&gt; plateA.get_image_grid_ROIs(well='A02')\n    \"\"\"\n# digest arguments\nwell = self._digest_well_argument(well)\npyramid_level = self._digest_pyramid_level_argument(pyramid_level)\nlowres_level = self._digest_pyramid_level_argument(lowres_level)\nassert num_select &lt;= num_x * num_y, f\"num_select ({num_select}) needs to be less or equal to num_x * num_y\" + str(num_x * num_y)\n# load image (convention: single field of view per well -&gt; '0')\nimg_path = os.path.join(self.path, well, '0', str(pyramid_level))\nimg = dask.array.from_zarr(img_path)\nimg_path_lowres = os.path.join(self.path, well, '0', str(lowres_level))\nimg_lowres = dask.array.from_zarr(img_path_lowres)\n# calculate grid coordinates as a list of (y_start, y_end, x_start, x_end)\n# (images are always of 4D shape c,z,y,x)\nch, z, y, x = img.shape\ngrid = self._calculate_regular_grid_coordinates(y=y, x=x,\nnum_y=num_y,\nnum_x=num_x)\nch_lr, z_lr, y_lr, x_lr = img_lowres.shape\ngrid_lowres = self._calculate_regular_grid_coordinates(y=y_lr, x=x_lr,\nnum_y=num_y,\nnum_x=num_x)\n# select and extract grid cells\nsel_coords = []\nsel_img_cells = []\nif sample_method == 'sum':\ngrid_values = [\ndask.array.sum(\nimg_lowres[slice(channel, channel + 1),\n:,\nslice(grid_lowres[i][0], grid_lowres[i][1]),\nslice(grid_lowres[i][2], grid_lowres[i][3])]\n) for i in range(len(grid_lowres))\n]\nidx_sorted = list(np.argsort(np.array(grid_values)))\nsel_coords = [grid[i] for i in idx_sorted[-num_select:]]\nelif sample_method == 'var':\ngrid_values = [\ndask.array.var(\nimg_lowres[slice(channel, channel + 1),\n:,\nslice(grid_lowres[i][0], grid_lowres[i][1]),\nslice(grid_lowres[i][2], grid_lowres[i][3])]\n) for i in range(len(grid_lowres))\n]\nidx_sorted = list(np.argsort(np.array(grid_values)))\nsel_coords = [grid[i] for i in idx_sorted[-num_select:]]\nelif sample_method == 'random':\nrandom.seed(seed)\nsel_coords = random.sample(grid, num_select)\nelse:\nraise ValueError(\"'sample_method' must be one of 'sum', 'var' or 'random'\")\nfor i in range(num_select):\nimg_cell = img[:,\n:,\nslice(sel_coords[i][0], sel_coords[i][1]),\nslice(sel_coords[i][2], sel_coords[i][3])]\nif as_NumPy:\nimg_cell = np.array(img_cell)\nsel_img_cells.append(img_cell)\nreturn (sel_coords, sel_img_cells)\n</code></pre>"},{"location":"hcs_wrappers/#src.ez_zarr.hcs_wrappers.FractalZarr.get_image_table_idx","title":"<code>get_image_table_idx(table_name, table_idx, well=None, pyramid_level=None, as_NumPy=False)</code>","text":"<p>Extract a region of interest from a well image by table name and row index.</p> <p>Bounding box coordinates will be automatically obtained from the table <code>table_name</code> and row <code>row_idx</code> (zero-based row index). All z planes are returned if there are several ones.</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>The name of the table containing object coordinates in columns <code>x_micrometer</code>, <code>y_micrometer</code>, <code>len_x_micrometer</code> and <code>len_y_micrometer</code>.</p> required <code>table_idx</code> <code>int</code> <p>The zero-based row index for the object to be extracted.</p> required <code>well</code> <code>str</code> <p>The well (e.g. 'B03') from which an image should be extracted.</p> <code>None</code> <code>pyramid_level</code> <code>int</code> <p>The pyramid level (resolution level), from which the image should be extracted. If <code>None</code>, the lowest-resolution (highest) pyramid level will be selected.</p> <code>None</code> <code>as_NumPy</code> <code>bool</code> <p>If <code>True</code>, return the image as 4D <code>numpy.ndarray</code> object (c,z,y,x). Otherwise, return the (on-disk) <code>dask</code> array of the same dimensions.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[Array, ndarray]</code> <p>The extracted image, either as a <code>dask.array.Array</code> on-disk array, or as an in-memory <code>numpy.ndarray</code> if <code>as_NumPy=True</code>.</p> <p>Examples:</p> <p>Obtain the image of the first object in table <code>nuclei_ROI_table</code> in well 'A02':</p> <pre><code>&gt;&gt;&gt; plateA.get_image_table_idx(table_name='nuclei_ROI_table', table_idx=0, well='A02')\n</code></pre> Source code in <code>src/ez_zarr/hcs_wrappers.py</code> <pre><code>def get_image_table_idx(self,\ntable_name: str,\ntable_idx: int,\nwell: Optional[str]=None,\npyramid_level: Optional[int]=None,\nas_NumPy: bool=False) -&gt; Union[dask.array.Array, np.ndarray]:\n\"\"\"\n    Extract a region of interest from a well image by table name and row index.\n    Bounding box coordinates will be automatically obtained from the table\n    `table_name` and row `row_idx` (zero-based row index).\n    All z planes are returned if there are several ones.\n    Parameters:\n        table_name (str): The name of the table containing object coordinates in columns\n            `x_micrometer`, `y_micrometer`, `len_x_micrometer` and `len_y_micrometer`.\n        table_idx (int): The zero-based row index for the object to be extracted.\n        well (str): The well (e.g. 'B03') from which an image should be extracted.\n        pyramid_level (int): The pyramid level (resolution level), from which the image\n            should be extracted. If `None`, the lowest-resolution (highest) pyramid level\n            will be selected.\n        as_NumPy (bool): If `True`, return the image as 4D `numpy.ndarray` object (c,z,y,x).\n            Otherwise, return the (on-disk) `dask` array of the same dimensions.\n    Returns:\n        The extracted image, either as a `dask.array.Array` on-disk array, or as an in-memory `numpy.ndarray` if `as_NumPy=True`.\n    Examples:\n        Obtain the image of the first object in table `nuclei_ROI_table` in well 'A02':\n        &gt;&gt;&gt; plateA.get_image_table_idx(table_name='nuclei_ROI_table', table_idx=0, well='A02')\n    \"\"\"\n# digest arguments\nassert table_name in self.table_names, f\"Unknown table {table_name}, should be one of \" + ', '.join(self.table_names)\nwell = self._digest_well_argument(well, as_path=False)\npyramid_level = self._digest_pyramid_level_argument(pyramid_level)\n# extract table\ndf = self.get_table(table_name=table_name, include_wells=well, as_AnnData=False)\nrequired_columns = ['x_micrometer', 'y_micrometer', 'len_x_micrometer', 'len_y_micrometer']\nassert all(column in set(df.columns) for column in required_columns), f\"Missing columns: {set(required_columns) - set(df.columns)}\"\nassert table_idx &lt; len(df), f\"table_idx ({table_idx}) needs to be less than \" + str(len(df))\n# get bounding box coordinates\nul = self.convert_micrometer_to_pixel((0,\ndf['y_micrometer'].iloc[table_idx],\ndf['x_micrometer'].iloc[table_idx]),\npyramid_level=pyramid_level,\npyramid_ref=('image', '0'))\nhw = self.convert_micrometer_to_pixel((0,\ndf['len_y_micrometer'].iloc[table_idx],\ndf['len_x_micrometer'].iloc[table_idx]),\npyramid_level=pyramid_level,\npyramid_ref=('image', '0'))\n# load image\nimg = self.get_image_ROI(upper_left_yx=ul[1:],\nsize_yx=hw[1:],\nwell=well,\npyramid_level=pyramid_level,\nas_NumPy=as_NumPy)\nreturn img\n</code></pre>"},{"location":"hcs_wrappers/#src.ez_zarr.hcs_wrappers.FractalZarr.get_label_ROI","title":"<code>get_label_ROI(label_name, well=None, image_name='0', pyramid_level=None, pyramid_level_coord=None, upper_left_yx=None, lower_right_yx=None, size_yx=None, as_NumPy=False)</code>","text":"<p>Extract a region of interest from a label mask (segmentation) by coordinates.</p> <p>None or exactly two of <code>upper_left_yx</code>, <code>lower_right_yx</code> and <code>size_yx</code> need to be given. If none are given, it will return the full image (the whole well). Otherwise, <code>upper_left_yx</code> contains the lower indices than <code>lower_right_yx</code> (origin on the top-left, zero-based coordinates), and each of them is a tuple of (y, x). No z coordinate needs to be given, all z planes are returned if there are several ones.</p> <p>Parameters:</p> Name Type Description Default <code>label_name</code> <code>str</code> <p>The name of the segmentation</p> required <code>well</code> <code>str</code> <p>The well (e.g. 'B03') from which an image should be extracted.</p> <code>None</code> <code>image_name</code> <code>str</code> <p>The name of the image in <code>well</code> to extract labels from. Default: '0'.</p> <code>'0'</code> <code>pyramid_level</code> <code>int</code> <p>The pyramid level (resolution level), from which the image should be extracted. If <code>None</code>, the lowest-resolution (highest) pyramid level will be selected.</p> <code>None</code> <code>pyramid_level_coord</code> <code>int</code> <p>An optional integer scalar giving the image pyramid level to which the coordinates (<code>upper_left_yx</code>, <code>lower_right_yx</code> and <code>size_yx</code>) refer to. By default, this is <code>None</code>, which will use <code>pyramid_level</code>.</p> <code>None</code> <code>upper_left_yx</code> <code>tuple</code> <p>Tuple of (y, x) coordinates for the upper-left (lower) coordinates defining the region of interest.</p> <code>None</code> <code>lower_right_yx</code> <code>tuple</code> <p>Tuple of (y, x) coordinates for the lower-right (higher) coordinates defining the region of interest.</p> <code>None</code> <code>size_yx</code> <code>tuple</code> <p>Tuple of (size_y, size_x) defining the size of the region of interest.</p> <code>None</code> <code>as_NumPy</code> <code>bool</code> <p>If <code>True</code>, return the image as 4D <code>numpy.ndarray</code> object (c,z,y,x). Otherwise, return the (on-disk) <code>dask</code> array of the same dimensions.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[Array, ndarray]</code> <p>The extracted label mask, either as a <code>dask.array.Array</code> on-disk array, or as an in-memory <code>numpy.ndarray</code> if <code>as_NumPy=True</code>.</p> <p>Examples:</p> <p>Obtain the label mask of the lowest-resolution pyramid level for the full well 'A02':</p> <pre><code>&gt;&gt;&gt; plateA.get_label_ROI(well='A02')\n</code></pre> Source code in <code>src/ez_zarr/hcs_wrappers.py</code> <pre><code>def get_label_ROI(self,\nlabel_name: str,\nwell: Optional[str]=None,\nimage_name: str='0',\npyramid_level: Optional[int]=None,\npyramid_level_coord: Optional[int]=None,\nupper_left_yx: Optional[tuple[int]]=None,\nlower_right_yx: Optional[tuple[int]]=None,\nsize_yx: Optional[tuple[int]]=None,\nas_NumPy: bool=False) -&gt; Union[dask.array.Array, np.ndarray]:\n\"\"\"\n    Extract a region of interest from a label mask (segmentation) by coordinates.\n    None or exactly two of `upper_left_yx`, `lower_right_yx` and `size_yx` need to be given.\n    If none are given, it will return the full image (the whole well).\n    Otherwise, `upper_left_yx` contains the lower indices than `lower_right_yx`\n    (origin on the top-left, zero-based coordinates), and each of them is\n    a tuple of (y, x). No z coordinate needs to be given, all z planes are returned\n    if there are several ones.\n    Parameters:\n        label_name (str): The name of the segmentation\n        well (str): The well (e.g. 'B03') from which an image should be extracted.\n        image_name (str): The name of the image in `well` to extract labels from. Default: '0'.\n        pyramid_level (int): The pyramid level (resolution level), from which the image\n            should be extracted. If `None`, the lowest-resolution (highest) pyramid level\n            will be selected.\n        pyramid_level_coord (int): An optional integer scalar giving the image pyramid level\n            to which the coordinates (`upper_left_yx`, `lower_right_yx` and `size_yx`)\n            refer to. By default, this is `None`, which will use `pyramid_level`.\n        upper_left_yx (tuple): Tuple of (y, x) coordinates for the upper-left (lower) coordinates\n            defining the region of interest.\n        lower_right_yx (tuple): Tuple of (y, x) coordinates for the lower-right (higher) coordinates defining the region of interest.\n        size_yx (tuple): Tuple of (size_y, size_x) defining the size of the region of interest.\n        as_NumPy (bool): If `True`, return the image as 4D `numpy.ndarray` object (c,z,y,x).\n            Otherwise, return the (on-disk) `dask` array of the same dimensions.\n    Returns:\n        The extracted label mask, either as a `dask.array.Array` on-disk array, or as an in-memory `numpy.ndarray` if `as_NumPy=True`.\n    Examples:\n        Obtain the label mask of the lowest-resolution pyramid level for the full well 'A02':\n        &gt;&gt;&gt; plateA.get_label_ROI(well='A02')\n    \"\"\"\n# digest arguments\nwell = self._digest_well_argument(well)\nassert label_name in self.label_names, f\"Unknown label_name {label_name}, should be one of \" + ', '.join(self.label_names)\npyramid_level = self._digest_pyramid_level_argument(pyramid_level, ('image', image_name))\n# load image\nmsk_path = os.path.join(self.path, well, image_name, 'labels', label_name, str(pyramid_level))\nmsk = dask.array.from_zarr(msk_path)\n# calculate corner coordinates and subset if needed\n# (images are always of 4D shape c,z,y,x)\nnum_unknowns = sum([x == None for x in [upper_left_yx, lower_right_yx, size_yx]])\nif num_unknowns == 1:\nif size_yx:\nassert all([x &gt; 0 for x in size_yx]), 'size_yx values need to be positive'\nif not upper_left_yx:\nupper_left_yx = tuple(lower_right_yx[i] - size_yx[i] for i in range(2))\nelif not lower_right_yx:\nlower_right_yx = tuple(upper_left_yx[i] + size_yx[i] for i in range(2))\nassert all([upper_left_yx[i] &lt; lower_right_yx[i] for i in range(len(upper_left_yx))]), 'upper_left_yx needs to be less than lower_right_yx'\n# convert coordinates if needed\nif pyramid_level_coord != None and pyramid_level != pyramid_level_coord:\nupper_left_yx = self.convert_pixel_to_pixel(zyx=((0,) + upper_left_yx),\npyramid_level_from=pyramid_level_coord,\npyramid_level_to=pyramid_level,\npyramid_ref_from=('image', image_name),\npyramid_ref_to=('image', image_name))[1:]\nlower_right_yx = self.convert_pixel_to_pixel(zyx=((0,) + lower_right_yx),\npyramid_level_from=pyramid_level_coord,\npyramid_level_to=pyramid_level,\npyramid_ref_from=('image', image_name),\npyramid_ref_to=('image', image_name))[1:]\nmsk = msk[:,\nslice(upper_left_yx[0], lower_right_yx[0] + 1),\nslice(upper_left_yx[1], lower_right_yx[1] + 1)]\nelif num_unknowns != 3:\nraise ValueError(\"Either none or two of `upper_left_yx`, `lower_right_yx` and `size_yx` have to be given\")\n# convert if needed and return\nif as_NumPy:\nmsk = np.array(msk)\nreturn msk\n</code></pre>"},{"location":"hcs_wrappers/#src.ez_zarr.hcs_wrappers.FractalZarr.get_label_names","title":"<code>get_label_names()</code>","text":"<p>Get list of label names in an OME-Zarr fileset.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of label names (str) available in the plate.</p> Source code in <code>src/ez_zarr/hcs_wrappers.py</code> <pre><code>def get_label_names(self) -&gt; list:\n\"\"\"Get list of label names in an OME-Zarr fileset.\n    Returns:\n        A list of label names (str) available in the plate.\n    \"\"\"\nreturn self.label_names\n</code></pre>"},{"location":"hcs_wrappers/#src.ez_zarr.hcs_wrappers.FractalZarr.get_label_table_idx","title":"<code>get_label_table_idx(label_name, table_name, table_idx, well=None, pyramid_level=None, as_NumPy=False)</code>","text":"<p>Extract a region of interest from a label mask (segmentation) by table name and row index.</p> <p>Bounding box coordinates will be automatically obtained from the table <code>table_name</code> and row <code>row_idx</code> (zero-based row index). All z planes are returned if there are several ones.</p> <p>Parameters:</p> Name Type Description Default <code>label_name</code> <code>str</code> <p>The name of the segmentation</p> required <code>table_name</code> <code>str</code> <p>The name of the table containing object coordinates in columns <code>x_micrometer</code>, <code>y_micrometer</code>, <code>len_x_micrometer</code> and <code>len_y_micrometer</code>.</p> required <code>table_idx</code> <code>int</code> <p>The zero-based row index for the object to be extracted.</p> required <code>well</code> <code>str</code> <p>The well (e.g. 'B03') from which an image should be extracted.</p> <code>None</code> <code>pyramid_level</code> <code>int</code> <p>The pyramid level (resolution level), from which the image should be extracted. If <code>None</code>, the lowest-resolution (highest) pyramid level will be selected.</p> <code>None</code> <code>as_NumPy</code> <code>bool</code> <p>If <code>True</code>, return the image as 4D <code>numpy.ndarray</code> object (c,z,y,x). Otherwise, return the (on-disk) <code>dask</code> array of the same dimensions.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[Array, ndarray]</code> <p>The extracted label mask, either as a <code>dask.array.Array</code> on-disk array, or as an in-memory <code>numpy.ndarray</code> if <code>as_NumPy=True</code>.</p> <p>Examples:</p> <p>Obtain the label mask in 'nuclei' of the first object in table <code>nuclei_ROI_table</code> in well 'A02':</p> <pre><code>&gt;&gt;&gt; plateA.get_label_table_idx(label_name='nuclei',\n                               table_name='nuclei_ROI_table',\n                               table_idx=0, well='A02')\n</code></pre> Source code in <code>src/ez_zarr/hcs_wrappers.py</code> <pre><code>def get_label_table_idx(self,\nlabel_name: str,\ntable_name: str,\ntable_idx: int,\nwell: Optional[str]=None,\npyramid_level: Optional[int]=None,\nas_NumPy: bool=False) -&gt; Union[dask.array.Array, np.ndarray]:\n\"\"\"\n    Extract a region of interest from a label mask (segmentation) by table name and row index.\n    Bounding box coordinates will be automatically obtained from the table\n    `table_name` and row `row_idx` (zero-based row index).\n    All z planes are returned if there are several ones.\n    Parameters:\n        label_name (str): The name of the segmentation\n        table_name (str): The name of the table containing object coordinates in columns\n            `x_micrometer`, `y_micrometer`, `len_x_micrometer` and `len_y_micrometer`.\n        table_idx (int): The zero-based row index for the object to be extracted.\n        well (str): The well (e.g. 'B03') from which an image should be extracted.\n        pyramid_level (int): The pyramid level (resolution level), from which the image\n            should be extracted. If `None`, the lowest-resolution (highest) pyramid level\n            will be selected.\n        as_NumPy (bool): If `True`, return the image as 4D `numpy.ndarray` object (c,z,y,x).\n            Otherwise, return the (on-disk) `dask` array of the same dimensions.\n    Returns:\n        The extracted label mask, either as a `dask.array.Array` on-disk array, or as an in-memory `numpy.ndarray` if `as_NumPy=True`.\n    Examples:\n        Obtain the label mask in 'nuclei' of the first object in table `nuclei_ROI_table` in well 'A02':\n        &gt;&gt;&gt; plateA.get_label_table_idx(label_name='nuclei',\n                                       table_name='nuclei_ROI_table',\n                                       table_idx=0, well='A02')\n    \"\"\"\n# digest arguments\nassert label_name in self.label_names, f\"Unknown label_name {label_name}, should be one of \" + ', '.join(self.label_names)\nassert table_name in self.table_names, f\"Unknown table_name {table_name}, should be one of \" + ', '.join(self.table_names)\nwell = self._digest_well_argument(well, as_path=False)\npyramid_level = self._digest_pyramid_level_argument(pyramid_level)\n# extract table\ndf = self.get_table(table_name=table_name, include_wells=well, as_AnnData=False)\nrequired_columns = ['x_micrometer', 'y_micrometer', 'len_x_micrometer', 'len_y_micrometer']\nassert all(column in set(df.columns) for column in required_columns), f\"Missing columns: {set(required_columns) - set(df.columns)}\"\nassert table_idx &lt; len(df), f\"table_idx ({table_idx}) needs to be less than \" + str(len(df))\n# get bounding box coordinates\nul = self.convert_micrometer_to_pixel((0,\ndf['y_micrometer'].iloc[table_idx],\ndf['x_micrometer'].iloc[table_idx]),\npyramid_level=pyramid_level,\npyramid_ref=('label', label_name))\nhw = self.convert_micrometer_to_pixel((0,\ndf['len_y_micrometer'].iloc[table_idx],\ndf['len_x_micrometer'].iloc[table_idx]),\npyramid_level=pyramid_level,\npyramid_ref=('label', label_name))\n# load image\nimg = self.get_label_ROI(label_name=label_name,\nwell=well,\nupper_left_yx=ul[1:],\nsize_yx=hw[1:],\npyramid_level=pyramid_level,\nas_NumPy=as_NumPy)\nreturn img\n</code></pre>"},{"location":"hcs_wrappers/#src.ez_zarr.hcs_wrappers.FractalZarr.get_path","title":"<code>get_path()</code>","text":"<p>Get the path of an OME-Zarr fileset.</p> <p>Returns:</p> Type Description <code>str</code> <p>The path to the OME-Zarr fileset.</p> Source code in <code>src/ez_zarr/hcs_wrappers.py</code> <pre><code>def get_path(self) -&gt; str:\n\"\"\"Get the path of an OME-Zarr fileset.\n    Returns:\n        The path to the OME-Zarr fileset.\n    \"\"\"\nreturn self.path\n</code></pre>"},{"location":"hcs_wrappers/#src.ez_zarr.hcs_wrappers.FractalZarr.get_table","title":"<code>get_table(table_name, include_wells=[], as_AnnData=False)</code>","text":"<p>Extract table for wells in an OME-Zarr fileset.</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>The name of the table to extract.</p> required <code>include_wells</code> <code>str or list</code> <p>List of well names to include. If empty <code>[]</code>, all wells are included.</p> <code>[]</code> <code>as_AnnData</code> <code>bool</code> <p>If <code>True</code>, the table is returned as an <code>AnnData</code> object, otherwise it is converted to a <code>pandas.DataFrame</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The extracted table, either as an <code>anndata.AnnData</code> object if <code>as_AnnData=True</code>, and as a <code>pandas.DataFrame</code> otherwise.</p> <p>Examples:</p> <p>Get a table with coordinates of fields of view:</p> <pre><code>&gt;&gt;&gt; plateA.get_table(table_name='FOV_ROI_table')\n</code></pre> Source code in <code>src/ez_zarr/hcs_wrappers.py</code> <pre><code>def get_table(self,\ntable_name: str,\ninclude_wells: Union[str, list[str]]=[],\nas_AnnData: bool=False) -&gt; Any:\n\"\"\"Extract table for wells in an OME-Zarr fileset.\n    Parameters:\n        table_name (str): The name of the table to extract.\n        include_wells (str or list): List of well names to include. If empty `[]`, all wells are included.\n        as_AnnData (bool): If `True`, the table is returned as an `AnnData` object, otherwise it is converted to a `pandas.DataFrame`.\n    Returns:\n        The extracted table, either as an `anndata.AnnData` object if `as_AnnData=True`, and as a `pandas.DataFrame` otherwise.\n    Examples:\n        Get a table with coordinates of fields of view:\n        &gt;&gt;&gt; plateA.get_table(table_name='FOV_ROI_table')\n    \"\"\"\ninclude_wells = self._digest_include_wells_argument(include_wells)\ntable_paths = [os.path.join(w, '0', 'tables', table_name) for w in include_wells]\n# remark: warn if not all well have the table?\ntable_paths = [p for p in table_paths if p in self.__top]\nif len(table_paths) == 0:\nreturn None\nwith warnings.catch_warnings():\nwarnings.filterwarnings(\"ignore\")\nad = importlib.import_module('anndata')\nanndata_list = [ad.read_zarr(os.path.join(self.path, p)) for p in table_paths]\n# ... retain well information when combining anndata objects\nfor ann, w in zip(anndata_list, include_wells):\nann.obs['well'] = w.replace('/', '')\nanndata_combined = ad.concat(anndata_list, index_unique=None, keys=[w.replace('/', '') for w in include_wells])\nif as_AnnData:\nreturn anndata_combined\nelse:\ndf_combined = pd.concat([anndata_combined.obs['well'],\nanndata_combined.to_df()],\naxis=1)\nreturn df_combined\n</code></pre>"},{"location":"hcs_wrappers/#src.ez_zarr.hcs_wrappers.FractalZarr.get_table_names","title":"<code>get_table_names()</code>","text":"<p>Get list of table names in an OME-Zarr fileset.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of table names (str) available in the plate.</p> Source code in <code>src/ez_zarr/hcs_wrappers.py</code> <pre><code>def get_table_names(self) -&gt; list:\n\"\"\"Get list of table names in an OME-Zarr fileset.\n    Returns:\n        A list of table names (str) available in the plate.\n    \"\"\"\nreturn self.table_names\n</code></pre>"},{"location":"hcs_wrappers/#src.ez_zarr.hcs_wrappers.FractalZarr.get_wells","title":"<code>get_wells(simplify=False)</code>","text":"<p>Get info on wells in an OME-Zarr fileset.</p> <p>Parameters:</p> Name Type Description Default <code>simplify</code> <code>bool</code> <p>If <code>True</code>, the well names are returned in human readable form (e.g. 'B03').</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[list[dict[str, Any]], list[str]]</code> <p>A list of wells in the plate, either name strings (if <code>simplify=True</code>) or dicts with well attributes.</p> Source code in <code>src/ez_zarr/hcs_wrappers.py</code> <pre><code>def get_wells(self, simplify: bool=False) -&gt; Union[list[dict[str, Any]], list[str]]:\n\"\"\"Get info on wells in an OME-Zarr fileset.\n    Parameters:\n        simplify (bool): If `True`, the well names are returned in human readable form (e.g. 'B03').\n    Returns:\n        A list of wells in the plate, either name strings (if `simplify=True`) or dicts with well attributes.\n    \"\"\"\nif simplify:\nreturn [w['path'].replace('/', '') for w in self.wells]\nelse:\nreturn self.wells\n</code></pre>"},{"location":"hcs_wrappers/#src.ez_zarr.hcs_wrappers.FractalZarr.plot_plate","title":"<code>plot_plate(image_name='0', label_name=None, label_alpha=0.3, pyramid_level=None, channels=[0], channel_colors=['white'], channel_ranges=[[0.01, 0.95]], z_projection_method='maximum', plate_layout='96well', fig_title=None, fig_width_inch=24.0, fig_height_inch=16.0, fig_dpi=200, fig_style='dark_background')</code>","text":"<p>Plot microtiter plate.</p> <p>Plot an overview of all wells in plate arrangement, for <code>channel</code> at resolution <code>pyramid_level</code>.</p> <p>Parameters:</p> Name Type Description Default <code>image_name</code> <code>str</code> <p>The name of the image in each well to be plotted. Default: '0'.</p> <code>'0'</code> <code>label_name</code> <code>str</code> <p>The name of the segmentation mask to be plotted semi-transparently over the images. If <code>None</code>, just the image is plotted.</p> <code>None</code> <code>label_alpha</code> <code>float</code> <p>A scalar value between 0 (fully transparent) and 1 (solid) defining the transparency of the label masks.</p> <code>0.3</code> <code>pyramid_level</code> <code>int</code> <p>The pyramid level (resolution level), from which the image should be extracted. If <code>None</code>, the lowest-resolution (highest) pyramid level will be selected.</p> <code>None</code> <code>channels</code> <code>list[int]</code> <p>The image channel(s) to be plotted.</p> <code>[0]</code> <code>channel_colors</code> <code>list[str]</code> <p>A list with python color strings (e.g. 'red') defining the color for each channel in <code>channels</code>.</p> <code>['white']</code> <code>channel_ranges</code> <code>list[list[float]]</code> <p>A list of 2-element lists (e.g. [0.01, 0.95]) giving the value ranges that should be mapped to colors for each channel. If the given numerical values are less or equal to 1.0, they are interpreted as quantiles and the corresponding intensity values are calculated on the channel non-zero values, otherwise they are directly used as intensities. Values outside of this range will be clipped.</p> <code>[[0.01, 0.95]]</code> <code>z_projection_method</code> <code>str</code> <p>Method for combining multiple z planes. For available methods, see ez_zarr.plotting.zproject (default: 'maximum').</p> <code>'maximum'</code> <code>plate_layout</code> <code>str</code> <p>Defines the layout of the plate (default: '96well').</p> <code>'96well'</code> <code>fig_title</code> <code>str</code> <p>String scalar to use as overall figure title (default: the <code>.name</code> attribute of the object). Use <code>fig_title=''</code> to not add any title to the plot.</p> <code>None</code> <code>fig_width_inch</code> <code>float</code> <p>Figure width (in inches).</p> <code>24.0</code> <code>fig_height_inch</code> <code>float</code> <p>Figure height (in inches).</p> <code>16.0</code> <code>fig_dpi</code> <code>int</code> <p>Figure resolution (dots per inch).</p> <code>200</code> <code>fig_style</code> <code>str</code> <p>Style for the figure. Supported are 'brightfield', which is a special mode for single-channel brightfield microscopic images (it will automatically set <code>channels=[0]</code>, <code>channel_colors=['white']</code> <code>z_projection_method='minimum'</code> and <code>fig_style='default'</code>), and any other styles that can be passed to <code>matplotlib.pyplot.style.context</code> (default: 'dark_background')</p> <code>'dark_background'</code> <p>Examples:</p> <p>Overview plot of a plate for image channel 1.</p> <pre><code>&gt;&gt;&gt; plateA.plot_plate(channels=[1])\n</code></pre> Source code in <code>src/ez_zarr/hcs_wrappers.py</code> <pre><code>def plot_plate(self,\nimage_name: str='0',\nlabel_name: Optional[str]=None,\nlabel_alpha: float=0.3,\npyramid_level: Optional[int]=None,\nchannels: list[int]=[0],\nchannel_colors: list[str]=['white'],\nchannel_ranges: list[list[float]]=[[0.01, 0.95]],\nz_projection_method: str='maximum',\nplate_layout: str='96well',\nfig_title: Optional[str]=None,\nfig_width_inch: float=24.0,\nfig_height_inch: float=16.0,\nfig_dpi: int=200,\nfig_style: str='dark_background'):\n\"\"\"\n    Plot microtiter plate.\n    Plot an overview of all wells in plate arrangement, for `channel` at\n    resolution `pyramid_level`.\n    Parameters:\n        image_name (str): The name of the image in each well to be plotted.\n            Default: '0'.\n        label_name (str): The name of the segmentation mask to be plotted\n            semi-transparently over the images. If `None`, just the image\n            is plotted.\n        label_alpha (float): A scalar value between 0 (fully transparent)\n            and 1 (solid) defining the transparency of the label masks.\n        pyramid_level (int): The pyramid level (resolution level), from\n            which the image should be extracted. If `None`, the\n            lowest-resolution (highest) pyramid level will be selected.\n        channels (list[int]): The image channel(s) to be plotted.\n        channel_colors (list[str]): A list with python color strings\n            (e.g. 'red') defining the color for each channel in `channels`.\n        channel_ranges (list[list[float]]): A list of 2-element lists\n            (e.g. [0.01, 0.95]) giving the value ranges that should be\n            mapped to colors for each channel. If the given numerical values\n            are less or equal to 1.0, they are interpreted as quantiles and\n            the corresponding intensity values are calculated on the channel\n            non-zero values, otherwise they are directly used as intensities.\n            Values outside of this range will be clipped.\n        z_projection_method (str): Method for combining multiple z planes.\n            For available methods, see ez_zarr.plotting.zproject\n            (default: 'maximum').\n        plate_layout (str): Defines the layout of the plate\n            (default: '96well').\n        fig_title (str): String scalar to use as overall figure title\n            (default: the `.name` attribute of the object). Use `fig_title=''`\n            to not add any title to the plot.\n        fig_width_inch (float): Figure width (in inches).\n        fig_height_inch (float): Figure height (in inches).\n        fig_dpi (int): Figure resolution (dots per inch).\n        fig_style (str): Style for the figure. Supported are 'brightfield', which\n            is a special mode for single-channel brightfield microscopic images\n            (it will automatically set `channels=[0]`, `channel_colors=['white']`\n            `z_projection_method='minimum'` and `fig_style='default'`), and any\n            other styles that can be passed to `matplotlib.pyplot.style.context`\n            (default: 'dark_background')\n    Examples:\n        Overview plot of a plate for image channel 1.\n        &gt;&gt;&gt; plateA.plot_plate(channels=[1])\n    \"\"\"\n# digest arguments\nassert image_name in self.image_names, (\nf\"Unknown image_name ({image_name}), should be one of \"\n', '.join(self.image_names)\n)\nassert label_name == None or label_name in self.label_names, (\nf\"Unknown label_name ({label_name}), should be `None` or one of \"\n', '.join(self.label_names)\n)\nimg_pl = self._digest_pyramid_level_argument(pyramid_level=pyramid_level,\npyramid_ref=('image', image_name))\nassert all(ch &lt; len(self.channels) for ch in channels), (\nf\"Invalid channels ({channels}), must be less than {len(self.channels)}\"\n)\n# import optional modules\nplotting = importlib.import_module('ez_zarr.plotting')\nassert plate_layout in plotting.plate_layouts, (\nf\"Unknown plate_layout ({plate_layout}), should be one of \"\n', '.join(list(plotting.plate_layouts.keys()))\n)\nplt = importlib.import_module('matplotlib.pyplot')\n# plate layout\nrows = plotting.plate_layouts[plate_layout]['rows']\ncolumns = plotting.plate_layouts[plate_layout]['columns']\n# available wells\nwells = self.get_wells(simplify=True)\n# get mask pyramid level corresponding to `img_pl`\nif label_name != None:\npl_match = [self.level_zyx_spacing_images[image_name][img_pl] == x\nfor x in self.level_zyx_spacing_labels[label_name]]\nassert sum(pl_match) == 1, (\nf\"Could not find a label pyramid level corresponding to the \"\nf\"selected image pyramid level ({img_pl})\"\n)\nmsk_pl = pl_match.index(True)\n# get the maximal well y,x coordinates\nwell_dims = [self.get_image_ROI(well=w, pyramid_level=img_pl).shape[2:] for w in wells]\nmax_yx = np.max(np.stack(well_dims), axis=0)\n# adjust parameters for brightfield images\nif fig_style == 'brightfield':\nchannels = [0]\nchannel_colors = ['white']\nz_projection_method = 'minimum'\nfig_style = 'default'\nempty_well = np.ones(max_yx)\nelse:\nempty_well = np.zeros(max_yx)\n# define figure title\nif fig_title is None:\nfig_title = self.name\n# loop over wells\nwith plt.style.context(fig_style):\nfig = plt.figure(figsize=(fig_width_inch, fig_height_inch))\nfig.set_dpi(fig_dpi)\nif fig_title != '':\nfig.suptitle(fig_title, size='xx-large') # default title size: 'large'\nfor r in range(len(rows)):\nfor c in range(len(columns)):\nw = rows[r] + columns[c]\nplt.subplot(len(rows), len(columns), r * len(columns) + c + 1)\nif w in wells:\n# get well image\nimg = self.get_image_ROI(well=w,\npyramid_level=img_pl,\nas_NumPy=True)\nimg_shape_before_padding = img.shape\n# add segmentation mask on top\nif label_name != None:\n# get well label\nmsk = self.get_label_ROI(label_name=label_name,\nwell=w,\npyramid_level=msk_pl,\nas_NumPy=True)\nassert img_shape_before_padding[1:] == msk.shape, (\nf\"label {label_name} shape {msk.shape} does not match \"\nf\"image shape {img_shape_before_padding} for well {w}\"\n)\nelse:\nmsk = None\n# plot well\nplotting.plot_image(im=img,\nmsk=msk,\nmsk_alpha=label_alpha,\nchannels=channels,\nchannel_colors=channel_colors,\nchannel_ranges=channel_ranges,\nz_projection_method=z_projection_method,\npad_to_yx=max_yx,\naxis_style='frame',\ntitle=w,\ncall_show=False)\nelse:\n# plot empty well\nplt.imshow(empty_well, cmap='gray', vmin=0, vmax=1)\nplt.xticks([]) # remove axis ticks\nplt.yticks([])\nplt.title(w)\nfig.tight_layout()\nplt.show()\nplt.close()\n</code></pre>"},{"location":"hcs_wrappers/#src.ez_zarr.hcs_wrappers.FractalZarr.plot_well","title":"<code>plot_well(well, upper_left_yx=None, lower_right_yx=None, size_yx=None, image_name='0', label_name=None, label_alpha=0.3, pyramid_level=None, pyramid_level_coord=None, channels=[0], channel_colors=['white'], channel_ranges=[[0.01, 0.95]], z_projection_method='maximum', axis_style='pixel', title=None, scalebar_micrometer=0, scalebar_color='white', scalebar_position='bottomright', scalebar_label=False, call_show=True, fig_width_inch=8.0, fig_height_inch=8.0, fig_dpi=200, fig_style='dark_background')</code>","text":"<p>Plot a well from a microtiter plate.</p> <p>Plot an overview of a single well, for <code>channel</code> at resolution <code>pyramid_level</code>.</p> <p>Parameters:</p> Name Type Description Default <code>well</code> <code>str</code> <p>The well (e.g. 'B03') to be plotted.</p> required <code>upper_left_yx</code> <code>tuple</code> <p>Tuple of (y, x) coordinates for the upper-left (lower) coordinates defining the region of interest.</p> <code>None</code> <code>lower_right_yx</code> <code>tuple</code> <p>Tuple of (y, x) coordinates for the lower-right (higher) coordinates defining the region of interest.</p> <code>None</code> <code>size_yx</code> <code>tuple</code> <p>Tuple of (size_y, size_x) defining the size of the region of interest.</p> <code>None</code> <code>image_name</code> <code>str</code> <p>The name of the image in the well to be plotted. Default: '0'.</p> <code>'0'</code> <code>label_name</code> <code>str</code> <p>The name of the a segmentation mask to be plotted semi-transparently over the images. If <code>None</code>, just the image is plotted.</p> <code>None</code> <code>label_alpha</code> <code>float</code> <p>A scalar value between 0 (fully transparent) and 1 (solid) defining the transparency of the label masks.</p> <code>0.3</code> <code>pyramid_level</code> <code>int</code> <p>The pyramid level (resolution level), from which the image should be extracted. If <code>None</code>, the lowest-resolution (highest) pyramid level will be selected.</p> <code>None</code> <code>pyramid_level_coord</code> <code>int</code> <p>An optional integer scalar giving the image pyramid level to which the coordinates (<code>upper_left_yx</code>, <code>lower_right_yx</code> and <code>size_yx</code>) refer to. By default, this is <code>None</code>, which will use <code>pyramid_level</code>.</p> <code>None</code> <code>channels</code> <code>list[int]</code> <p>The image channel(s) to be plotted.</p> <code>[0]</code> <code>channel_colors</code> <code>list[str]</code> <p>A list with python color strings (e.g. 'red') defining the color for each channel in <code>channels</code>.</p> <code>['white']</code> <code>channel_ranges</code> <code>list[list[float]]</code> <p>A list of 2-element lists (e.g. [0.01, 0.95]) giving the value ranges that should be mapped to colors for each channel. If the given numerical values are less or equal to 1.0, they are interpreted as quantiles and the corresponding intensity values are calculated on the channel non-zero values, otherwise they are directly used as intensities. Values outside of this range will be clipped.</p> <code>[[0.01, 0.95]]</code> <code>z_projection_method</code> <code>str</code> <p>Method for combining multiple z planes. For available methods, see ez_zarr.plotting.zproject (default: 'maximum').</p> <code>'maximum'</code> <code>axis_style</code> <code>str</code> <p>A string scalar defining how to draw the axis. Should be one of 'none' (no axis), 'pixel' (show pixel labels, the default) or 'micrometer' (show micrometer labels). If <code>axis_style='micrometer'</code>, <code>spacing_yx</code> is used to convert pixel to micrometer.</p> <code>'pixel'</code> <code>title</code> <code>str</code> <p>String scalar to add as title. If <code>None</code>, <code>well</code> will be used as <code>title</code>.</p> <code>None</code> <code>scalebar_micrometer</code> <code>int</code> <p>If non-zero, add a scale bar corresponding to <code>scalebar_micrometer</code> to the bottom right.</p> <code>0</code> <code>scalebar_label</code> <code>bool</code> <p>If <code>True</code>, add micrometer label to scale bar.</p> <code>False</code> <code>call_show</code> <code>bool</code> <p>If <code>True</code>, the call to <code>matplotlib.pyplot.imshow</code> is embedded between <code>matplotlib.pyplot.figure</code> and <code>matplotlib.pyplot.show</code>/<code>matplotlib.pyplot.close</code> calls. This is the default behaviour and typically used when an individual image should be plotted and displayed. It can be set to <code>False</code> if multiple images should be plotted and their arrangement is controlled outside of <code>plotting.plot_image</code>. The parameters <code>fig_width_inch</code>, <code>fig_height_inch</code> and <code>fig_dpi</code> are ignored in that case.</p> <code>True</code> <code>fig_width_inch</code> <code>float</code> <p>Figure width (in inches).</p> <code>8.0</code> <code>fig_height_inch</code> <code>float</code> <p>Figure height (in inches).</p> <code>8.0</code> <code>fig_dpi</code> <code>int</code> <p>Figure resolution (dots per inch).</p> <code>200</code> <code>fig_style</code> <code>str</code> <p>Style for the figure. Supported are 'brightfield', which is a special mode for single-channel brightfield microscopic images (it will automatically set <code>channels=[0]</code>, <code>channel_colors=['white']</code> <code>z_projection_method='minimum'</code> and <code>fig_style='default'</code>), and any other styles that can be passed to <code>matplotlib.pyplot.style.context</code> (default: 'dark_background')</p> <code>'dark_background'</code> <p>Examples:</p> <p>Overview plot of the well 'B03'.</p> <pre><code>&gt;&gt;&gt; plateA.plot_well(well='B03')\n</code></pre> Source code in <code>src/ez_zarr/hcs_wrappers.py</code> <pre><code>def plot_well(self,\nwell: str,\nupper_left_yx: Optional[tuple[int]]=None,\nlower_right_yx: Optional[tuple[int]]=None,\nsize_yx: Optional[tuple[int]]=None,\nimage_name: str='0',\nlabel_name: Optional[str]=None,\nlabel_alpha: float=0.3,\npyramid_level: Optional[int]=None,\npyramid_level_coord: Optional[int]=None,\nchannels: list[int]=[0],\nchannel_colors: list[str]=['white'],\nchannel_ranges: list[list[float]]=[[0.01, 0.95]],\nz_projection_method: str='maximum',\naxis_style: str='pixel',\ntitle: Optional[str]=None,\nscalebar_micrometer: int=0,\nscalebar_color: str='white',\nscalebar_position: str='bottomright',\nscalebar_label: bool=False,\ncall_show: bool=True,\nfig_width_inch: float=8.0,\nfig_height_inch: float=8.0,\nfig_dpi: int=200,\nfig_style: str='dark_background'):\n\"\"\"\n    Plot a well from a microtiter plate.\n    Plot an overview of a single well, for `channel` at\n    resolution `pyramid_level`.\n    Parameters:\n        well (str): The well (e.g. 'B03') to be plotted.\n        upper_left_yx (tuple): Tuple of (y, x) coordinates for the upper-left\n            (lower) coordinates defining the region of interest.\n        lower_right_yx (tuple): Tuple of (y, x) coordinates for the lower-right\n            (higher) coordinates defining the region of interest.\n        size_yx (tuple): Tuple of (size_y, size_x) defining the size of the\n            region of interest.\n        image_name (str): The name of the image in the well to be plotted.\n            Default: '0'.\n        label_name (str): The name of the a segmentation mask to be plotted\n            semi-transparently over the images. If `None`, just the image\n            is plotted.\n        label_alpha (float): A scalar value between 0 (fully transparent)\n            and 1 (solid) defining the transparency of the label masks.\n        pyramid_level (int): The pyramid level (resolution level), from\n            which the image should be extracted. If `None`, the\n            lowest-resolution (highest) pyramid level will be selected.\n        pyramid_level_coord (int): An optional integer scalar giving the image pyramid level\n            to which the coordinates (`upper_left_yx`, `lower_right_yx` and `size_yx`)\n            refer to. By default, this is `None`, which will use `pyramid_level`.\n        channels (list[int]): The image channel(s) to be plotted.\n        channel_colors (list[str]): A list with python color strings\n            (e.g. 'red') defining the color for each channel in `channels`.\n        channel_ranges (list[list[float]]): A list of 2-element lists\n            (e.g. [0.01, 0.95]) giving the value ranges that should be\n            mapped to colors for each channel. If the given numerical values\n            are less or equal to 1.0, they are interpreted as quantiles and\n            the corresponding intensity values are calculated on the channel\n            non-zero values, otherwise they are directly used as intensities.\n            Values outside of this range will be clipped.\n        z_projection_method (str): Method for combining multiple z planes.\n            For available methods, see ez_zarr.plotting.zproject\n            (default: 'maximum').\n        axis_style (str): A string scalar defining how to draw the axis. Should\n            be one of 'none' (no axis), 'pixel' (show pixel labels, the default)\n            or 'micrometer' (show micrometer labels). If `axis_style='micrometer'`,\n            `spacing_yx` is used to convert pixel to micrometer.\n        title (str): String scalar to add as title. If `None`, `well` will\n            be used as `title`.\n        scalebar_micrometer (int): If non-zero, add a scale bar corresponding\n            to `scalebar_micrometer` to the bottom right.\n        scalebar_label (bool): If `True`, add micrometer label to scale bar.\n        call_show (bool): If `True`, the call to `matplotlib.pyplot.imshow` is\n            embedded between `matplotlib.pyplot.figure` and\n            `matplotlib.pyplot.show`/`matplotlib.pyplot.close` calls.\n            This is the default behaviour and typically used when an individual\n            image should be plotted and displayed. It can be set to `False`\n            if multiple images should be plotted and their arrangement\n            is controlled outside of `plotting.plot_image`. The parameters\n            `fig_width_inch`, `fig_height_inch` and `fig_dpi` are ignored\n            in that case.\n        fig_width_inch (float): Figure width (in inches).\n        fig_height_inch (float): Figure height (in inches).\n        fig_dpi (int): Figure resolution (dots per inch).\n        fig_style (str): Style for the figure. Supported are 'brightfield', which\n            is a special mode for single-channel brightfield microscopic images\n            (it will automatically set `channels=[0]`, `channel_colors=['white']`\n            `z_projection_method='minimum'` and `fig_style='default'`), and any\n            other styles that can be passed to `matplotlib.pyplot.style.context`\n            (default: 'dark_background')\n    Examples:\n        Overview plot of the well 'B03'.\n        &gt;&gt;&gt; plateA.plot_well(well='B03')\n    \"\"\"\n# digest arguments\nwell = self._digest_well_argument(well, as_path=False)\nassert image_name in self.image_names, (\nf\"Unknown image_name ({image_name}), should be one of \"\n', '.join(self.image_names)\n)\nassert label_name == None or label_name in self.label_names, (\nf\"Unknown label_name ({label_name}), should be `None` or one of \"\n', '.join(self.label_names)\n)\nimg_pl = self._digest_pyramid_level_argument(pyramid_level=pyramid_level,\npyramid_ref=('image', image_name))\nassert all(ch &lt; len(self.channels) for ch in channels), (\nf\"Invalid channels ({channels}), must be less than {len(self.channels)}\"\n)\n# import optional modules\nplotting = importlib.import_module('ez_zarr.plotting')\n# get mask pyramid level corresponding to `img_pl`\nif label_name != None:\npl_match = [self.level_zyx_spacing_images[image_name][img_pl] == x\nfor x in self.level_zyx_spacing_labels[label_name]]\nassert sum(pl_match) == 1, (\nf\"Could not find a label pyramid level corresponding to the \"\nf\"selected image pyramid level ({img_pl})\"\n)\nmsk_pl = pl_match.index(True)\n# get well image\nimg = self.get_image_ROI(well=well,\nupper_left_yx=upper_left_yx,\nlower_right_yx=lower_right_yx,\nsize_yx=size_yx,\npyramid_level=img_pl,\npyramid_level_coord=pyramid_level_coord,\nas_NumPy=True)\nif label_name != None:\nmsk = self.get_label_ROI(label_name=label_name,\nwell=well,\nupper_left_yx=upper_left_yx,\nlower_right_yx=lower_right_yx,\nsize_yx=size_yx,\npyramid_level=msk_pl,\npyramid_level_coord=pyramid_level_coord,\nas_NumPy=True)\nassert img.shape[1:] == msk.shape, (\nf\"label {label_name} shape {msk.shape} does not match \"\nf\"image shape {img.shape} for well {well}\"\n)\nelse:\nmsk = None\n# calculate scalebar length in pixel in x direction\nif scalebar_micrometer != 0:\nscalebar_pixel = self.convert_micrometer_to_pixel(zyx = (0, 0, scalebar_micrometer),\npyramid_level=img_pl)[2]\nelse:\nscalebar_pixel = 0\n# plot well\nif title is None:\ntitle = well\nif scalebar_label:\nscalebar_label = str(scalebar_micrometer) + ' \u00b5m'\nelse:\nscalebar_label = None\nplotting.plot_image(im=img,\nmsk=msk,\nmsk_alpha=label_alpha,\nchannels=channels,\nchannel_colors=channel_colors,\nchannel_ranges=channel_ranges,\nz_projection_method=z_projection_method,\naxis_style=axis_style,\nspacing_yx=self.level_zyx_spacing_images[image_name][img_pl][1:],\ntitle=title,\nscalebar_pixel=scalebar_pixel,\nscalebar_color=scalebar_color,\nscalebar_position=scalebar_position,\nscalebar_label=scalebar_label,\ncall_show=call_show,\nfig_width_inch=fig_width_inch,\nfig_height_inch=fig_height_inch,\nfig_dpi=fig_dpi,\nfig_style=fig_style)\n</code></pre>"},{"location":"hcs_wrappers/#src.ez_zarr.hcs_wrappers.FractalZarrSet","title":"<code>FractalZarrSet</code>","text":"<p>Represents a folder containing one or several ome-zarr fileset(s).</p> Source code in <code>src/ez_zarr/hcs_wrappers.py</code> <pre><code>class FractalZarrSet:\n\"\"\"Represents a folder containing one or several ome-zarr fileset(s).\"\"\"\n# constructor and helper functions ----------------------------------------\ndef __init__(self, path: str, name=None) -&gt; None:\n\"\"\"\n        Initializes a container for a folder containing one or several OME-Zarr\n        fileset(s) (.zarr). Typically, the object is used for a folder which\n        contains exactly two related `.zarr` objects, one corresponding to the\n        four-dimensional (c,z,y,x) plate dataset, and a second one corresponding to\n        a three-dimensional maximum intensity projection derived from it.\n        Parameters:\n            path (str): Path containing the OME-Zarr fileset(s).\n            name (str): Optional name for the experiment.\n        Examples:\n            Get an object corresponding to a set of `.zarr`s.\n            &gt;&gt;&gt; from ez_zarr import hcs_wrappers\n            &gt;&gt;&gt; plate_set = hcs_wrappers.FractalZarrSet('path/to/zarrs')\n            &gt;&gt;&gt; plate_set\n            This will print information on the `.zarr`s.\n        \"\"\"\nif not os.path.isdir(path):\nraise ValueError(f'`{path}` does not exist')\nself.path: str = path\nself.name: str = ''\nif name is None:\nself.name = os.path.basename(self.path)\nelse:\nself.name = name\nself.zarr_paths: list[str] = [f for f in os.listdir(self.path) if f[-5:] == '.zarr']\nif len(self.zarr_paths) == 0:\nraise ValueError(f'no `.zarr` filesets found in `{path}`')\nself.zarr_paths.sort(reverse=True) # defined order (_mip.zarr before .zarr)\nself.zarr_mip_idx: Optional[int] = None\nself.zarr_3d_idx: Optional[int] = None\nif len(self.zarr_paths) == 2:\nif self.zarr_paths[0].replace('_mip.zarr', '.zarr') == self.zarr_paths[1]:\n# special case of 3D plate plus derived maximum intensity projection?\nself.zarr_mip_idx = 0\nself.zarr_3d_idx = 1\nself.zarr: list[FractalZarr] = [FractalZarr(os.path.join(self.path, f)) for f in self.zarr_paths]\nself.zarr_names: list[str] = [x.name for x in self.zarr]\n# string representation ---------------------------------------------------\ndef __str__(self) -&gt; str:\nnplates = len(self.zarr)\nplatenames = ''.join(f'    {i}: {self.zarr[i].name}\\n' for i in range(len(self.zarr)))\nreturn f\"FractalZarrSet {self.name}\\n  path: {self.path}\\n  n_plates: {nplates}\\n{platenames}\\n\"\ndef __repr__(self) -&gt; str:\nreturn str(self)\n# accessors ---------------------------------------------------------------\ndef __len__(self) -&gt; int:\nreturn len(self.zarr)\ndef __getitem__(self, key: Union[int, str]) -&gt; FractalZarr:\nif isinstance(key, int):\nreturn self.zarr[key]\nelif isinstance(key, str):\nreturn self.zarr[self.zarr_names.index(key)]\ndef __getattr__(self, name):\ntry:\nattr = getattr(self.zarr[0], name)\nexcept AttributeError:\nraise AttributeError(f\"'{type(self.zarr[0]).__name__}' objects have no attribute '{name}'\")\nif callable(attr):\ndef wrapper(*args, **kwargs):\nreturn [getattr(plate, name)(*args, **kwargs) for plate in self.zarr]\nreturn wrapper\nelse:\nreturn [getattr(plate, name) for plate in self.zarr]\n</code></pre>"},{"location":"hcs_wrappers/#src.ez_zarr.hcs_wrappers.FractalZarrSet.__init__","title":"<code>__init__(path, name=None)</code>","text":"<p>Initializes a container for a folder containing one or several OME-Zarr fileset(s) (.zarr). Typically, the object is used for a folder which contains exactly two related <code>.zarr</code> objects, one corresponding to the four-dimensional (c,z,y,x) plate dataset, and a second one corresponding to a three-dimensional maximum intensity projection derived from it.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path containing the OME-Zarr fileset(s).</p> required <code>name</code> <code>str</code> <p>Optional name for the experiment.</p> <code>None</code> <p>Examples:</p> <p>Get an object corresponding to a set of <code>.zarr</code>s.</p> <pre><code>&gt;&gt;&gt; from ez_zarr import hcs_wrappers\n&gt;&gt;&gt; plate_set = hcs_wrappers.FractalZarrSet('path/to/zarrs')\n&gt;&gt;&gt; plate_set\n</code></pre> <p>This will print information on the <code>.zarr</code>s.</p> Source code in <code>src/ez_zarr/hcs_wrappers.py</code> <pre><code>def __init__(self, path: str, name=None) -&gt; None:\n\"\"\"\n    Initializes a container for a folder containing one or several OME-Zarr\n    fileset(s) (.zarr). Typically, the object is used for a folder which\n    contains exactly two related `.zarr` objects, one corresponding to the\n    four-dimensional (c,z,y,x) plate dataset, and a second one corresponding to\n    a three-dimensional maximum intensity projection derived from it.\n    Parameters:\n        path (str): Path containing the OME-Zarr fileset(s).\n        name (str): Optional name for the experiment.\n    Examples:\n        Get an object corresponding to a set of `.zarr`s.\n        &gt;&gt;&gt; from ez_zarr import hcs_wrappers\n        &gt;&gt;&gt; plate_set = hcs_wrappers.FractalZarrSet('path/to/zarrs')\n        &gt;&gt;&gt; plate_set\n        This will print information on the `.zarr`s.\n    \"\"\"\nif not os.path.isdir(path):\nraise ValueError(f'`{path}` does not exist')\nself.path: str = path\nself.name: str = ''\nif name is None:\nself.name = os.path.basename(self.path)\nelse:\nself.name = name\nself.zarr_paths: list[str] = [f for f in os.listdir(self.path) if f[-5:] == '.zarr']\nif len(self.zarr_paths) == 0:\nraise ValueError(f'no `.zarr` filesets found in `{path}`')\nself.zarr_paths.sort(reverse=True) # defined order (_mip.zarr before .zarr)\nself.zarr_mip_idx: Optional[int] = None\nself.zarr_3d_idx: Optional[int] = None\nif len(self.zarr_paths) == 2:\nif self.zarr_paths[0].replace('_mip.zarr', '.zarr') == self.zarr_paths[1]:\n# special case of 3D plate plus derived maximum intensity projection?\nself.zarr_mip_idx = 0\nself.zarr_3d_idx = 1\nself.zarr: list[FractalZarr] = [FractalZarr(os.path.join(self.path, f)) for f in self.zarr_paths]\nself.zarr_names: list[str] = [x.name for x in self.zarr]\n</code></pre>"},{"location":"ome_zarr/","title":"Classes that wrap ome-zarr filesets","text":"<p>Wrap OME-Zarr filesets at different levels in classes.</p> <p>Represent an OME-Zarr fileset as a class to give high-level access to its contents.</p> <p>Classes:</p> Name Description <code>Image</code> <p>Contains a single <code>.zgroup</code>, typicallly a single image and possibly derived labels or tables.</p>"},{"location":"ome_zarr/#src.ez_zarr.ome_zarr.Image","title":"<code>Image</code>","text":"<p>Represents an OME-Zarr image.</p> Source code in <code>src/ez_zarr/ome_zarr.py</code> <pre><code>class Image:\n\"\"\"Represents an OME-Zarr image.\"\"\"\n# constructor and helper functions ----------------------------------------\ndef __init__(self, path: str,\nname: Optional[str]=None,\nskip_checks: Optional[bool]=False,\nverbose: bool=False) -&gt; None:\n\"\"\"\n        Initializes an OME-Zarr image from its path, containing a\n        single zarr group, possibly with multiple resolution levels,\n        derived labels or tables, but no further groups.\n        Parameters:\n            path (str): Path containing the OME-Zarr image.\n            name (str, optional): Optional name for the image.\n            skip_checks (bool, optional): If `True`, no checks are performed.\n            verbose (bool): Whether to print information messages.\n        Examples:\n            Get an object corresponding to an image.\n            &gt;&gt;&gt; from ez_zarr import ome_zarr\n            &gt;&gt;&gt; imageA = ome_zarr.Image('path/to/image')\n        \"\"\"\nself.path: str = path\nself.name: str = ''\nif name:\nself.name = name\nelse:\nself.name = os.path.basename(self.path)\nself.zarr_group: zarr.Group = zarr.open(store=self.path, mode='r')\nself.label_names = []\nif 'labels' in list(self.zarr_group.group_keys()):\nself.label_names = [x for x in self.zarr_group['labels'].group_keys()]\nself.table_names = []\nif 'tables' in list(self.zarr_group.group_keys()):\nself.table_names = [x for x in self.zarr_group['tables'].group_keys()]\n# get version info and check that the version is supported\nomezarr_version = None\nif 'ome' in self.zarr_group.attrs:\n# 'ome' was introduced with OME-Zarr v0.5\nif 'version' in self.zarr_group.attrs['ome']:\nomezarr_version = self.zarr_group.attrs['ome']['version']\nelse:\nwarnings.warn(\"Could not determine OME-Zarr version\")\nelse:\nif 'multiscales' not in self.zarr_group.attrs:\nraise ValueError(f\"{self.path} does not contain a 'multiscales' attribute\")\nif 'version' in list(self.zarr_group.attrs['multiscales'][0].keys()):\nomezarr_version = self.zarr_group.attrs['multiscales'][0]['version']\nelse:\nwarnings.warn(\"Could not determine OME-Zarr version\")\nif omezarr_version not in [None, \"0.4\", \"0.5\"]:\nraise ValueError(f\"OME-Zarr version {omezarr_version} is not supported, should be 0.4 or 0.5\")\nif not skip_checks:\n# make sure that it does not contain any further groups\nif len([x for x in self.zarr_group.group_keys() if x not in ['labels', 'tables']]) &gt; 0:\nraise ValueError(f\"{self.path} contains further groups\")\nself.array_dict: dict[str, zarr.Array] = {x[0]: x[1] for x in self.zarr_group.arrays()}\nself.ndim = self.array_dict[list(self.array_dict.keys())[0]].ndim\n# load info about available scales in image and labels\n# ... load multiscales dictionaries\nself.multiscales_image: dict[str, Any] = self._load_multiscale_info(self.zarr_group, skip_checks)\nself.multiscales_labels: dict[str, dict[str, Any]] = {x: self._load_multiscale_info(self.zarr_group['labels'][x], skip_checks) for x in self.label_names}\n# ... extract pyramid levels by decreasing resolution\nself.pyramid_levels_image: list[str] = Image._extract_paths_by_decreasing_resolution(self.multiscales_image['datasets'])\nself.pyramid_levels_labels: dict[str, list[str]] = {x: Image._extract_paths_by_decreasing_resolution(self.multiscales_labels[x]['datasets']) for x in self.label_names}\n# ... axes units\nself.axes_unit_image: str = self._load_axes_unit(self.multiscales_image, verbose, context=\"intensity image\")\nself.axes_unit_labels: dict[str, str] = {x: self._load_axes_unit(self.multiscales_labels[x], verbose, context=f\"label {x}\") for x in self.label_names}\n# load channel metadata\n# ... label dimensions, e.g. \"czyx\"\nself.channel_info_image: str = self._load_channel_info(self.multiscales_image)\nself.channel_info_labels: dict[str, str] = {x: self._load_channel_info(self.multiscales_labels[x]) for x in self.label_names}\n# ... store the number of image channels\nself.nchannels_image: int = self.array_dict[list(self.array_dict.keys())[0]].shape[self.channel_info_image.index('c')] if 'c' in self.channel_info_image else 0\n# ... store channel annotation from OMERO\nself.channels: list[dict[str, Any]] = []\nif 'omero' in self.zarr_group.attrs and 'channels' in self.zarr_group.attrs['omero']:\nself.channels = self.zarr_group.attrs['omero']['channels']\nelif self.nchannels_image &gt; 0:\nself.channels = [{'label': f'channel-{i+1}',\n'color': '00FFFF'} for i in range(self.nchannels_image)]\n@staticmethod\ndef _load_multiscale_info(group: zarr.Group,\nskip_checks: Optional[bool]=False) -&gt; dict[str, Any]:\nif 'ome' in group.attrs:\nif 'multiscales' not in group.attrs['ome']:\nraise ValueError(f\"no multiscale info found in {group.path}\")\nif len(group.attrs['ome']['multiscales']) &gt; 1:\nwarnings.warn(f\"{group.path} contains more than one multiscale - using the first one\")\ninfo = group.attrs['ome']['multiscales'][0]\nelse:\nif 'multiscales' not in group.attrs:\nraise ValueError(f\"no multiscale info found in {group.path}\")\nif len(group.attrs['multiscales']) &gt; 1:\nwarnings.warn(f\"{group.path} contains more than one multiscale - using the first one\")\ninfo = group.attrs['multiscales'][0]\nif not skip_checks:\nif 'axes' not in info:\nraise ValueError(f\"no axes info found in 'multiscales' of {group.path}\")\n# TODO: add further checks\nreturn info\n@staticmethod\ndef _load_axes_unit(multiscale_dict: dict[str, Any], verbose: bool = False, context: str = \"\") -&gt; str:\nsupported_units = {'micrometer':'micrometer',\n'micron':'micrometer',\n'um':'micrometer',\n'pixel':'pixel',\n'unit':'pixel'}\nunit_set = set([x['unit'] for x in multiscale_dict['axes'] if x['type'] == 'space' and 'unit' in x])\nif len(unit_set) == 0:\nretval = 'pixel'\nelif len(unit_set) == 1 and list(unit_set)[0] in supported_units:\nretval = supported_units[list(unit_set)[0]]\nelse:\nraise ValueError(f\"unsupported unit in multiscale_info: {multiscale_dict}\")\nif verbose:\nprint(f\"Identified/inferred axes unit ({context}): {retval}\")\nreturn retval\n@staticmethod\ndef _load_channel_info(multiscale_dict: dict[str, Any]) -&gt; str:\ntype2ch = {'time': 't', 'channel': 'c', 'space': 'S'}\nspatial = ['x', 'y', 'z']\nL = [type2ch[d['type']] for d in multiscale_dict['axes']]\nL.reverse()\nwhile 'S' in L:\nL[L.index('S')] = spatial.pop(0)\nL.reverse()\nreturn ''.join(L)\n@staticmethod\ndef _extract_scale_spacings(dataset_dict: dict[str, Any]) -&gt; list[Union[str, list[float]]]:\nif 'path' not in dataset_dict or 'coordinateTransformations' not in dataset_dict or 'scale' not in dataset_dict['coordinateTransformations'][0]:\nraise ValueError(\"could not extract zyx spacing from multiscale_info\")\nreturn [dataset_dict['path'], dataset_dict['coordinateTransformations'][0]['scale']]\n@staticmethod\ndef _compare_multiscale_dicts(a: dict[str, Any], b: dict[str, Any]) -&gt; int:\nt1 = a['coordinateTransformations'][0]['scale']\nt2 = b['coordinateTransformations'][0]['scale']\nsum_of_votes = sum([1 if t1[i] &gt; t2[i] else -1 if t1[i] &lt; t2[i] else 0 for i in range(len(t1))])\nif sum_of_votes &gt; 0:\nreturn 1  # t1 &gt; t2 (t1 is lower resolution)\nelif sum_of_votes &lt; 0:\nreturn -1 # t1 &lt; t2 (t1 is higher resolution)\nelse:\nreturn 0  # t1 = t2 (equal resolution)\n@staticmethod\ndef _extract_paths_by_decreasing_resolution(datasets: list[dict[str, Any]]) -&gt; list[str]:\ndatasets_sorted = sorted(datasets, key=cmp_to_key(lambda x, y: Image._compare_multiscale_dicts(x, y)))\nreturn [str(x['path']) for x in datasets_sorted]\ndef _find_path_of_lowest_resolution_level(self, label_name: Optional[str] = None, \nverbose: bool = False) -&gt; str:\nif label_name:\nif label_name in self.label_names:\nplev = self.pyramid_levels_labels[label_name][-1]\nelse:\nraise ValueError(f\"Label name '{label_name}' not found in Image object.\")\nelse:\nplev = self.pyramid_levels_image[-1]\nif verbose:\nprint(f\"Returning lowest resolution pyramid level: {plev}\")\nreturn plev\ndef _find_path_of_highest_resolution_level(self, label_name: Optional[str] = None,\nverbose: bool = False) -&gt; str:\nif label_name:\nif label_name in self.label_names:\nplev = self.pyramid_levels_labels[label_name][0]\nelse:\nraise ValueError(f\"Label name '{label_name}' not found in Image object.\")\nelse:\nplev = self.pyramid_levels_image[0]\nif verbose:\nprint(f\"Returning highest resolution pyramid level: {plev}\")\nreturn plev\ndef _digest_pyramid_level_argument(self,\npyramid_level=None,\nlabel_name=None,\ndefault_to='lowest',\nverbose: bool = False) -&gt; str:\n\"\"\"\n        [internal] Interpret a `pyramid_level` argument in the context of a given Image object.\n        Parameters:\n            pyramid_level (int, str or None): pyramid level, coerced to str. If None,\n                the lowest-resolution pyramid level (or the highest-resolution one,\n                if `default_to='highest'`) will be returned.\n            label_name (str or None): defines what `pyramid_level` refers to. If None,\n                it refers to the intensity image. Otherwise, it refers to a label with\n                the name given by `label_name`. For example, to select the 'nuclei'\n                labels, the argument would be set to `nuclei`.\n            default_to (str): Defines what pyramid level to return if `pyramid_level`\n                is `None`. Currently supported are `'lowest'` and `'highest'`.\n            verbose (bool): Whether to print out information messages.\n        Returns:\n            Integer index of the pyramid level.\n        \"\"\"\nif label_name is not None and label_name not in self.label_names:\nraise ValueError(f\"invalid label name '{label_name}' - must be one of {self.label_names}\")\nif pyramid_level == None: \n# no pyramid level given -&gt; pick according to `default_to`\nmethods = {'lowest': self._find_path_of_lowest_resolution_level,\n'highest': self._find_path_of_highest_resolution_level}\npyramid_level = methods[default_to](label_name, verbose)\nelse:\n# make sure it is a string\npyramid_level = str(pyramid_level)\n# make sure it exists\nif label_name is None: # intensity image\npyramid_level_names = [str(x['path']) for x in self.multiscales_image['datasets']]\nelse: # label image\npyramid_level_names = [str(x['path']) for x in self.multiscales_labels[label_name]['datasets']]\nif pyramid_level not in pyramid_level_names:\nraise ValueError(f\"invalid pyramid level '{pyramid_level}' - must be one of {pyramid_level_names}\")\nreturn pyramid_level\ndef _digest_channels_labels(self, channels_labels: list[str]) -&gt; list[int]:\nall_channels_labels = [ch['label'] for ch in self.channels]\nmissing_labels = [channels_labels[i] for i in range(len(channels_labels)) if channels_labels[i] not in all_channels_labels]\nif len(missing_labels) &gt; 0:\nraise ValueError(f\"Unknown channels_labels ({', '.join(missing_labels)}), should be `None` or one of {', '.join(all_channels_labels)}\")\nreturn [all_channels_labels.index(x) for x in channels_labels]\ndef _digest_bounding_box(self,\nupper_left_yx: Optional[tuple[int, ...]]=None,\nlower_right_yx: Optional[tuple[int, ...]]=None,\nsize_yx: Optional[tuple[int, ...]]=None,\ncoordinate_unit: str='micrometer',\nlabel_name: Optional[str]=None,\npyramid_level: Optional[str]=None,\npyramid_level_coord: Optional[str]=None,\nverbose: bool=False) -&gt; list[tuple[int, ...]]:\n\"\"\"\n        Solves for the bounding box defined by upper-left, lower-right or size.\n        None or exactly two of `upper_left_yx`, `lower_right_yx` and `size_yx`\n        need to be given. If none are given, the bounding box will correspond to\n        the full image.\n        Otherwise, `upper_left_yx` contains lower values than `lower_right_yx`\n        (origin on the top-left, zero-based coordinates), and each of them is\n        a tuple of (y, x).\n        If `coordinate_unit` is not 'pixel', or `coordinate_unit` is 'pixel' and\n        `pyramid_level_coord` is not None and different from `pyramid_level`, the\n        solved bounding box coordinates are converted to pixels in `pyramid_level`.\n        Parameters:\n            upper_left_yx (tuple, optional): Tuple of (y, x) coordinates for the upper-left\n                (lower) coordinates defining the region of interest.\n            lower_right_yx (tuple, optional): Tuple of (y, x) coordinates for the lower-right\n                (higher) coordinates defining the region of interest.\n            size_yx (tuple, optional): Tuple of (size_y, size_x) defining the size of the\n                region of interest.\n            coordinate_unit (str): The unit of the image coordinates, for example\n                'micrometer' or 'pixel'.\n            label_name (str, optional): The name of the label image that the coordinates\n                refer to. If `None`, the intensity image will be used as reference.\n            pyramid_level (str): The pyramid level (resolution level), to which the\n                returned coordinates should refer. If `None`, the lowest-resolution\n                pyramid level will be selected.\n            pyramid_level_coord (str, optional): An optional string giving the \n                image pyramid level to which the input coordinates (`upper_left_yx`,\n                `lower_right_yx` and `size_yx`) refer to if `coordinate_unit=\"pixel\"`\n                (it is ignored otherwise). By default, this is `None`, which will\n                use `pyramid_level`.\n            verbose (bool): Whether to print out information messages.\n        Returns:\n            A list of upper-left and lower-right tuple coordinates for the bounding box: `[(y1, x1), (y2, x2)]`. These coordinates\n            are always in 'pixel' units of `pyramid_level`.\n        Examples:\n            Obtain the whole coordinates of the full image at pyramid level 0:\n            &gt;&gt;&gt; img._digest_bounding_box(pyramid_level=0)\n        \"\"\"\n# digest arguments\npyramid_level = self._digest_pyramid_level_argument(pyramid_level, label_name, verbose=verbose)\n# get image array\nif label_name:\narr = self.zarr_group['labels'][label_name][pyramid_level]\nelse:\narr = self.zarr_group[pyramid_level]\n# calculate corner coordinates\nnum_unknowns = sum([x == None for x in [upper_left_yx, lower_right_yx, size_yx]])\nif num_unknowns == 1:\nif size_yx:\nassert all([x &gt; 0 for x in size_yx]), 'size_yx values need to be positive'\nif not upper_left_yx:\nif verbose:\nprint(\"Inferring upper_left_yx\")\nupper_left_yx = tuple(lower_right_yx[i] - size_yx[i] for i in range(2))\nelif not lower_right_yx:\nif verbose:\nprint(\"Inferring lower_right_yx\")\nlower_right_yx = tuple(upper_left_yx[i] + size_yx[i] for i in range(2))\nassert all([upper_left_yx[i] &lt; lower_right_yx[i] for i in range(len(upper_left_yx))]), 'upper_left_yx needs to be less than lower_right_yx'\nelif num_unknowns == 3:\nif verbose:\nprint(\"Returning the full image\")\nupper_left_yx = (0, 0)\nlower_right_yx = (arr.shape[-2], arr.shape[-1])\ncoordinate_unit = 'pixel'\npyramid_level_coord = pyramid_level\nelse:\nraise ValueError(\"Either none or two of `upper_left_yx`, `lower_right_yx` and `size_yx` have to be given\")\n# convert coordinates if needed\nif coordinate_unit != \"pixel\" or (pyramid_level != pyramid_level_coord):\nif coordinate_unit == \"micrometer\":\n# Note: this assumes that all non-spatial dimensions\n#       (channels, time) have scales of 1.0\nscale_from = [1.0] * len(arr.shape)\nelif coordinate_unit == \"pixel\":\nif pyramid_level_coord is None:\npyramid_level_coord = pyramid_level\nelse:\npyramid_level_coord = self._digest_pyramid_level_argument(pyramid_level=pyramid_level_coord, \nlabel_name=label_name, default_to=\"lowest\",\nverbose=verbose)\nscale_from = self.get_scale(pyramid_level=pyramid_level_coord, label_name=label_name,\nverbose=verbose)\nelse:\nraise ValueError(\"`coordinate_unit` needs to be 'micrometer' or 'pixel'\")\nscale_to = self.get_scale(pyramid_level=pyramid_level, label_name=label_name,\nverbose=verbose)\n# convert and round to int\nupper_left_yx = tuple(int(round(x)) for x in convert_coordinates(upper_left_yx, scale_from[-2:], scale_to[-2:]))\nlower_right_yx = tuple(int(round(x)) for x in convert_coordinates(lower_right_yx, scale_from[-2:], scale_to[-2:]))\n# return\nreturn([upper_left_yx, lower_right_yx])\n# string representation ---------------------------------------------------\ndef __str__(self):\nnch = self.nchannels_image\nchlabs = ', '.join([x['label'] for x in self.channels])\nnpl = len(self.multiscales_image['datasets'])\nsegnames = ', '.join(self.label_names)\ntabnames = ', '.join(self.table_names)\nspatial_dims = [i for i in range(len(self.channel_info_image)) if self.channel_info_image[i] in ['z', 'y', 'x']]\nzyx = ''.join([self.channel_info_image[i] for i in spatial_dims])\nimage_spacings = {x[0]: [x[1][s] for s in spatial_dims] for x in [self._extract_scale_spacings(y) for y in self.multiscales_image['datasets']]}\npl_scalefactor = 'None (only one pyramid level)'\nif len(image_spacings) &gt; 1:\npl_nms = list(image_spacings.keys())\npl_scalefactor = np.divide(image_spacings[pl_nms[1]], image_spacings[pl_nms[0]])\nreturn f\"Image {self.name}\\n  path: {self.path}\\n  n_channels: {nch} ({chlabs})\\n  n_pyramid_levels: {npl}\\n  pyramid_{zyx}_scalefactor: {pl_scalefactor}\\n  full_resolution_{zyx}_spacing ({self.axes_unit_image}): {image_spacings[list(image_spacings.keys())[0]]}\\n  segmentations: {segnames}\\n  tables (measurements): {tabnames}\\n\"\ndef __repr__(self):\nreturn str(self)\n# accessor methods -----------------------------------------------------------\ndef get_path(self) -&gt; str:\n\"\"\"Get the path of an OME-Zarr image.\n        Returns:\n            The path to the OME-Zarr image.\n        \"\"\"\nreturn self.path\ndef get_channels(self) -&gt; list:\n\"\"\"Get info on channels in an OME-Zarr image.\n        Returns:\n            A list of dicts with information on channels.\n        \"\"\"\nreturn self.channels\ndef get_label_names(self) -&gt; list:\n\"\"\"Get list of label names in an OME-Zarr image.\n        Returns:\n            A list of label names (str) available for the image.\n        \"\"\"\nreturn self.label_names\ndef get_table_names(self) -&gt; list:\n\"\"\"Get list of table names in an OME-Zarr image.\n        Returns:\n            A list of table names (str) available for the image.\n        \"\"\"\nreturn self.table_names\ndef get_pyramid_levels(self, label_name: Optional[str]=None) -&gt; list[str]:\n\"\"\"Get list of pyramid levels in an OME-Zarr image.\n        Parameters:\n            label_name (str, optional): The name of the label image for which\n                to return pyramid levels. If None, pyramid levels from the\n                intensity image are returned.\n        Returns:\n            A list of available pyramid levels (str).\n        \"\"\"\nif label_name:\nreturn [str(x['path']) for x in self.multiscales_labels[label_name]['datasets']]\nelse:\nreturn [str(x['path']) for x in self.multiscales_image['datasets']]\ndef get_scale(self,\npyramid_level: str,\nlabel_name: Optional[str]=None,\nspatial_axes_only: bool=False,\nverbose: bool=False) -&gt; list[float]:\n\"\"\"\n        Get the scale of a given pyramid level.\n        Parameters:\n            pyramid_level (str): The pyramid level from which to get the scale.\n            label_name (str or None): The name of the label image to which\n                `pyramid_level` refers to. If None, `pyramid_level` is assumed\n                to refer to the intensity image.\n            spatial_axes_only (bool): If True, only the scales for spatial\n                dimensions are returned.\n            verbose (bool): Whether to print out information messages.\n        Returns:\n            A list with the axis scales of the given pyramid level.\n        Example:\n            Get the axis scales of the first pyramid level:\n            &gt;&gt;&gt; scale = img.get_scale('level_0', 'nuclei')\n        \"\"\"\n# digest arguments\npyramid_level = self._digest_pyramid_level_argument(pyramid_level=pyramid_level, \nlabel_name=label_name, default_to=\"lowest\",\nverbose=verbose)\n# extract scale\nif label_name:\ndatasets_list = self.multiscales_labels[label_name]['datasets']\nchannel_info = self.channel_info_labels[label_name]\nelse:\ndatasets_list = self.multiscales_image['datasets']\nchannel_info = self.channel_info_image\nscale = [x['coordinateTransformations'][0]['scale']\nfor x in datasets_list\nif str(x['path']) == pyramid_level][0]\nif spatial_axes_only:\nscale = [scale[i]\nfor i in range(len(scale))\nif channel_info[i] in ['z', 'y', 'x']]\n# return\nreturn scale\ndef get_bounding_box_for_label_value(self,\nlabel_name: str,\nlabel_value: Union[int, float, str],\nlabel_pyramid_level: str,\nextend_pixels: Optional[int]=0,\nlabel_name_output: Optional[str]=None,\npyramid_level_output: Optional[str]=None,\nverbose: bool=False) -&gt; Union[tuple[tuple[int, ...], tuple[int, ...]], tuple[None, None]]:\n\"\"\"\n        Given a label name and value, find the corner coordinates of the bounding box.\n        Parameters:\n            label_name (str): The name of the label image to extract the bounding\n                box from.\n            label_value (int, float, str): The value of the label to extract the\n                bounding box for.\n            label_pyramid_level (int, str): The pyramid level to extract the bounding\n                box from.\n            extend_pixels (int): The number of pixels to add to each side for each\n                axis of the bounding box (before possible conversion to\n                `label_name_output` and `pyramid_level_output`).\n            label_name_output (str or None): The name of the label image to which\n                the returned bounding box coordinates refer to. If `None` (the\n                default), the coordinates refer to the intensity image.\n            pyramid_level_output (str or None): The pyramid level to which the\n                returned bounding box coordinates refer to. If `None` (the\n                default), the coordinates refer to the highest resolution pyramid\n                level.\n            verbose (bool): Whether to print out information messages.\n        Returns:\n            A tuple of upper-left and lower-right pixel coordinates for the bounding\n            box containing the label value in the requested output space, or\n            Throws an error if the label value is not found.\n            For a 2D label image, this would be `((y1, x1), (y2, x2))`.\n        Example:\n            Get the bounding box for the 'nuclei' label value 1 from pyramid\n            level 0,in the space of highest-resolution pyramid level of\n            the intensity image:\n            &gt;&gt;&gt; img.get_bounding_box_for_label_value(label_name='nuclei', label_value=1, label_pyramid_level=0)\n        \"\"\"\n# digest arguments\nassert label_name in self.label_names, f'`label_name` must be in {self.label_names}'\nlabel_pyramid_level = self._digest_pyramid_level_argument(pyramid_level=label_pyramid_level, \nlabel_name=label_name, verbose=verbose)\nassert isinstance(extend_pixels, int), '`extend_pixels` must be an integer scalar'\nassert isinstance(label_name_output, str) or label_name_output is None\npyramid_level_output = self._digest_pyramid_level_argument(\npyramid_level_output, label_name_output, default_to='highest', verbose=verbose)\n# get label array\nlab_arr = self.get_array_by_coordinate(label_name=label_name,\npyramid_level=label_pyramid_level)\n# find bounding box\nvalue_coordinates = np.equal(lab_arr, label_value).nonzero()\nif len(value_coordinates[0]) == 0:\nraise ValueError(f'Label value {label_value} not found in label {label_name}')\nupper_left = tuple([min(x) for x in value_coordinates])\nlower_right = tuple([max(x) + 1 for x in value_coordinates])\n# padding\nupper_left = tuple([max(0, upper_left[i] - extend_pixels) for i in range(len(upper_left))])\nlower_right = tuple([min(lab_arr.shape[i], lower_right[i] + extend_pixels) for i in range(len(lower_right))])\n# convert to output space\nin_scale = self.get_scale(pyramid_level=label_pyramid_level,\nlabel_name=label_name,\nspatial_axes_only=True,\nverbose=verbose)\nout_scale = self.get_scale(pyramid_level=pyramid_level_output,\nlabel_name=label_name_output,\nspatial_axes_only=True,\nverbose=verbose)\nupper_left_out = convert_coordinates(coords_from=upper_left,\nscale_from=in_scale,\nscale_to=out_scale)\nlower_right_out = convert_coordinates(coords_from=lower_right,\nscale_from=in_scale,\nscale_to=out_scale)\n# return result\nreturn tuple([tuple([round(x) for x in upper_left_out]),\ntuple([round(x) for x in lower_right_out])])\ndef get_array_by_coordinate(self,\nlabel_name: Optional[str]=None,\nupper_left_yx: Optional[tuple[int]]=None,\nlower_right_yx: Optional[tuple[int]]=None,\nsize_yx: Optional[tuple[int]]=None,\ncoordinate_unit: str='micrometer',\npyramid_level: Optional[str]=None,\npyramid_level_coord: Optional[str]=None,\nas_NumPy: bool=False,\nverbose: bool=False) -&gt; Union[zarr.Array, np.ndarray]:\n\"\"\"\n        Extract a (sub)array from an image (intensity image or label) by coordinates.\n        None or exactly two of `upper_left_yx`, `lower_right_yx` and `size_yx`\n        need to be given. If none are given, the full image is returned.\n        Otherwise, `upper_left_yx` contains the lower indices than `lower_right_yx`\n        (origin on the top-left, zero-based coordinates), and each of them is\n        a tuple of (y, x). No t, c or z coordinate need to be given, all of them\n        are returned if there are several ones.\n        Parameters:\n            label_name (str, optional): The name of the label image to be extracted.\n                If `None`, the intensity image will be extracted.\n            upper_left_yx (tuple, optional): Tuple of (y, x) coordinates for the upper-left\n                (lower) coordinates defining the region of interest.\n            lower_right_yx (tuple, optional): Tuple of (y, x) coordinates for the lower-right\n                (higher) coordinates defining the region of interest.\n            size_yx (tuple, optional): Tuple of (size_y, size_x) defining the size of the\n                region of interest.\n            coordinate_unit (str): The unit of the image coordinates, for example\n                'micrometer' or 'pixel'.\n            pyramid_level (str): The pyramid level (resolution level), from which the\n                array should be extracted. If `None`, the lowest-resolution\n                pyramid level will be selected.\n            pyramid_level_coord (str, optional): An optional string giving the \n                image pyramid level to which the coordinates (`upper_left_yx`,\n                `lower_right_yx` and `size_yx`) refer to if `coordinate_unit=\"pixel\"`\n                (it is ignored otherwise). By default, this is `None`, which will\n                use `pyramid_level`.\n            as_NumPy (bool): If `True`, return the image as a `numpy.ndarray`\n                object (e.g. c,z,y,x). Otherwise, return the (on-disk) `dask`\n                array of the same dimensions.\n            verbose (bool): Whether to print out information messages.\n        Returns:\n            The extracted array, either as an on-disk `zarr.Array`,\n            or as an in-memory `numpy.ndarray` if `as_NumPy=True`.\n        Examples:\n            Obtain the whole image of the lowest-resolution as an array:\n            &gt;&gt;&gt; img.get_array_by_coordinate()\n        \"\"\"\n# digest arguments\npyramid_level = self._digest_pyramid_level_argument(pyramid_level=pyramid_level, \nlabel_name=label_name, verbose=verbose)\n# load image\nif label_name:\narr = self.zarr_group['labels'][label_name][pyramid_level]\nelse:\narr = self.zarr_group[pyramid_level]\n# calculate corner coordinates\nupper_left_yx, lower_right_yx = self._digest_bounding_box(\nupper_left_yx=upper_left_yx,\nlower_right_yx=lower_right_yx,\nsize_yx=size_yx,\ncoordinate_unit=coordinate_unit,\nlabel_name=label_name,\npyramid_level=pyramid_level,\npyramid_level_coord=pyramid_level_coord,\nverbose=verbose)\n# subset array if needed\nif upper_left_yx != (0, 0) or lower_right_yx != arr.shape[-2:]:\narr = arr[...,\nslice(upper_left_yx[0], lower_right_yx[0]),\nslice(upper_left_yx[1], lower_right_yx[1])]\n# convert if needed and return\nif as_NumPy:\narr = np.array(arr)\nreturn arr\ndef get_array_pair_by_coordinate(self,\nlabel_name: Union[str, list[str]],\nupper_left_yx: Optional[tuple[int]]=None,\nlower_right_yx: Optional[tuple[int]]=None,\nsize_yx: Optional[tuple[int]]=None,\ncoordinate_unit: str='micrometer',\npyramid_level: Optional[str]=None,\npyramid_level_coord: Optional[str]=None,\nverbose: bool=False) -&gt; tuple[np.ndarray]:\n\"\"\"\n        Extract a matching pair of (sub)arrays (intensity and label) by coordinates.\n        None or exactly two of `upper_left_yx`, `lower_right_yx` and `size_yx`\n        need to be given. If none are given, the full image is returned.\n        Otherwise, `upper_left_yx` contains the lower indices than `lower_right_yx`\n        (origin on the top-left, zero-based coordinates), and each of them is\n        a tuple of (y, x). No t, c or z coordinate need to be given, all of them\n        are returned if there are several ones.\n        Coordinate and pyramid level arguments all refer to the intensity image.\n        For the label, matching values will be selected automatically, and if\n        necessary, the label array is resized to match the intensity array.\n        Parameters:\n            label_name (str or list of str): The name(s) of the label image(s)\n                to be extracted.\n            upper_left_yx (tuple, optional): Tuple of (y, x) intensity image\n                coordinates for the upper-left (lower) coordinates defining the\n                region of interest.\n            lower_right_yx (tuple, optional): Tuple of (y, x) intensity image\n                coordinates for the lower-right (higher) coordinates defining the\n                region of interest.\n            size_yx (tuple, optional): Tuple of (size_y, size_x) defining the size\n                of the intensity image region of interest.\n            coordinate_unit (str): The unit of the image coordinates, for example\n                'micrometer' or 'pixel'.\n            pyramid_level (str): The intensity image pyramid level (resolution\n                level), from which the intensity array should be extracted.\n                If `None`, the lowest-resolution pyramid level will be selected.\n                A matching pyramid level for the label will be selected\n                automatically.\n            pyramid_level_coord (str, optional): An optional string giving the \n                intensity image pyramid level to which the coordinates (if any)\n                refer to if `coordinate_unit=\"pixel\"` (it is ignored otherwise).\n                By default, this is `None`, which will use `pyramid_level`.\n            verbose (bool): Whether to print out information messages.\n        Returns:\n            A tuple of length two, with the first element corresponding to\n            a `numpy.ndarray` with the extracted intensity array and the\n            second element a dictionary with keys corresponding to the\n            `label_name` and the values corresponding to label arrays.\n            Label arrays are resized if necessary to match the intensity\n            array.\n        Examples:\n            Obtain the whole image and matching 'organoids' label arrays:\n            &gt;&gt;&gt; img, lab = img.get_array_pair_by_coordinate(label_name = 'organoids')\n        \"\"\"\n# digest arguments\nif isinstance(label_name, str):\nlabel_name = [label_name]\nassert isinstance(label_name, list) and all([ln in self.label_names for ln in label_name]), (\nf\"Unknown label_name(s) ({', '.join([ln for ln in label_name if ln not in self.label_names])}), should be one of \"\n', '.join(self.label_names)\n)\npyramid_level = self._digest_pyramid_level_argument(\npyramid_level=pyramid_level,\nlabel_name=None, verbose=verbose\n)\nif pyramid_level_coord is None:\npyramid_level_coord = pyramid_level\n# get intensity image scale\nimg_scale_spatial = self.get_scale(\npyramid_level=pyramid_level,\nlabel_name=None,\nspatial_axes_only=True,\nverbose=verbose\n)\n# loop over label names\nlab_arr_dict = {}\nfor lname in label_name:\n# find matching label pyramid level\nlab_scale_spatial_dict = {\npl: self.get_scale(pyramid_level=pl, label_name=lname, spatial_axes_only=True, verbose=verbose) for pl in self.get_pyramid_levels(label_name=lname)\n}\n# ... filter out label scales with higher resolution than the intensity image\nlab_scale_spatial_dict = {pl: lab_scale_spatial for pl, lab_scale_spatial in lab_scale_spatial_dict.items() if all([lab_scale_spatial[i] &gt;= img_scale_spatial[i] for i in range(len(lab_scale_spatial))])}\nif len(lab_scale_spatial_dict) == 0:\nraise ValueError(f\"For the requested pyramid level ({pyramid_level}) of the intensity image, down-scaling of an available label ('{lname}') would be required. Down-scaling of labels is not supported - try selecting a higher-resolution intensity image.\")\nnearest_scale_idx = np.argmin([np.mean(np.array(lab_scale_spatial_dict[pl]) / np.array(img_scale_spatial)) for pl in lab_scale_spatial_dict.keys()])\nnearest_scale_pl = list(lab_scale_spatial_dict.keys())[nearest_scale_idx]\nlab_scale_spatial = lab_scale_spatial_dict[nearest_scale_pl]\n# calculate image corner points\nimgpixel_upper_left_yx, imgpixel_lower_right_yx = self._digest_bounding_box(\nupper_left_yx=upper_left_yx,\nlower_right_yx=lower_right_yx,\nsize_yx=size_yx,\ncoordinate_unit=coordinate_unit,\nlabel_name=None,\npyramid_level=pyramid_level,\npyramid_level_coord=pyramid_level_coord,\nverbose=verbose\n)\n# make sure that the dimensions are divisible by\n# the yx scaling factor between intensity and label arrays\nscalefact_yx = np.divide(lab_scale_spatial, img_scale_spatial)\nimgpixel_upper_left_yx = tuple((np.floor_divide(imgpixel_upper_left_yx, scalefact_yx[-2:]) * scalefact_yx[-2:]))\nimgpixel_lower_right_yx = tuple((np.floor_divide(imgpixel_lower_right_yx, scalefact_yx[-2:]) * scalefact_yx[-2:]))\n# get intensity array\nimg_arr = self.get_array_by_coordinate(\nupper_left_yx=imgpixel_upper_left_yx,\nlower_right_yx=imgpixel_lower_right_yx,\nsize_yx=None,\ncoordinate_unit='pixel',\nlabel_name=None,\npyramid_level=pyramid_level, \nas_NumPy=False,\nverbose=verbose\n)\n# convert intensity coordiantes to label coordinates\nlabpixel_upper_left_yx = convert_coordinates(\nimgpixel_upper_left_yx,\nimg_scale_spatial[-2:],\nlab_scale_spatial[-2:]\n)\nlabpixel_lower_right_yx = convert_coordinates(\nimgpixel_lower_right_yx,\nimg_scale_spatial[-2:],\nlab_scale_spatial[-2:]\n)\n# get label array\nlab_arr = np.array(self.get_array_by_coordinate(\nupper_left_yx=labpixel_upper_left_yx,\nlower_right_yx=labpixel_lower_right_yx,\nsize_yx=None,\ncoordinate_unit='pixel',\nlabel_name=lname,\npyramid_level=nearest_scale_pl,\nverbose=verbose\n))\n# resize label if needed (correct non-matching scales or rounding errors)\nif lab_arr.shape[-2:] != img_arr.shape[-2:]:\nwarnings.warn(f\"For the requested pyramid level ({pyramid_level}) of the intensity image, no matching label ('{lname}') is available. Up-scaling the label using factor(s) {scalefact_yx}\")\nlab_arr = resize_image(\nim=lab_arr,\noutput_shape=img_arr.shape[(img_arr.ndim-lab_arr.ndim):],\nim_type='label',\nnumber_nonspatial_axes=sum([int(s not in ['z','y','x']) for s in self.channel_info_labels[lname]]),\nverbose=verbose\n)\n# store label array in dictionary\nlab_arr_dict[lname] = lab_arr\n# return arrays\nreturn tuple([np.array(img_arr), lab_arr_dict])\ndef get_table(self,\ntable_name: str,\nas_AnnData: bool=False) -&gt; Any:\n\"\"\"Extract tabular data (for example quantifications) for OME-Zarr image.\n        Parameters:\n            table_name (str): The name of the table to extract.\n            as_AnnData (bool): If `True`, the table is returned as an `AnnData` object, otherwise it is returned as a `pandas.DataFrame`.\n        Returns:\n            The extracted table, either as an `anndata.AnnData` object if `as_AnnData=True`, or a `pandas.DataFrame` otherwise. `None` if `table_name` is not found.\n        Examples:\n            List available tables names, and get table 'FOV_ROI_table':\n            &gt;&gt;&gt; img.get_table_names()\n            &gt;&gt;&gt; img.get_table(table_name='FOV_ROI_table')\n        \"\"\"\n# check for existing table_name\nif table_name not in self.table_names:\nwarnings.warn(f\"Table '{table_name}' not found in image at {self.path}.\")\nreturn None\nwith warnings.catch_warnings():\nwarnings.filterwarnings(\"ignore\")\nad = importlib.import_module('anndata')\nanndata = ad.read_zarr(os.path.join(self.path, 'tables', table_name))\nif as_AnnData:\nreturn anndata\nelse:\nreturn anndata.to_df()\n# zarr group methods ---------------------------------------------------------\ndef tree(self, **kwargs: Any) -&gt; Any:\n\"\"\"Print zarr tree using zarr.hierarchy.Group.tree().\"\"\"\nreturn self.zarr_group.tree(**kwargs)\n# plotting methods -----------------------------------------------------------\ndef plot(self,\nupper_left_yx: Optional[tuple[int]]=None,\nlower_right_yx: Optional[tuple[int]]=None,\nsize_yx: Optional[tuple[int]]=None,\ncoordinate_unit: str='micrometer',\nlabel_name: Optional[Union[list[str], str]]=None,\nlabel_value: Optional[Union[int, float, str]]=None,\nlabel_pyramid_level: Optional[str]=None,\nextend_pixels: int=0,\npyramid_level: Optional[str]=None,\npyramid_level_coord: Optional[str]=None,\nchannels_labels: Optional[list[str]]=None,\nscalebar_micrometer: int=0,\nshow_scalebar_label: bool=True,\ntime_index: int=0,\nverbose: bool=False,\n**kwargs: Any) -&gt; None:\n\"\"\"\n        Plot an image.\n        Plot a single image or a part of it, optionally selecting\n        channels by label and extracting colors from the OMERO metadata\n        using data at resolution `pyramid_level`.\n        Parameters:\n            upper_left_yx (tuple, optional): Tuple of (y, x) coordinates\n                for the upper-left (lower) coordinates defining the region\n                of interest.\n            lower_right_yx (tuple, optional): Tuple of (y, x) coordinates\n                for the lower-right (higher) coordinates defining the region\n                of interest.\n            size_yx (tuple, optional): Tuple of (size_y, size_x) defining\n                the size of the region of interest.\n            coordinate_unit (str): The unit of the image coordinates, for\n                example 'micrometer' or 'pixel'.\n            label_name (str or list of str, optional): The segmentation\n                mask name or names to be plotted semi-transparently over\n                the intensity image. If this is a list of multiple names, the\n                first one that is available for the image will be\n                used. If `None`, just the intensity image is plotted.\n            label_value (int, float, str, optional): The value of the label,\n                for which bounding box coordinates should be extracted. \n                The highest resolution pyramid level will be used.If\n                not `None`, `label_value` will automatically determine `upper_left_yx`,\n                `lower_right_yx` and `size_yx`. Any values given to those or\n                to `coordinate_unit` and `pyramid_level_coord` will be ignored.\n            label_pyramid_level (str, optional): The pyramid level (resolution level),\n                from which the label image should be extracted if `label_value` is\n                not `None`. If `None`, the lowest-resolution (highest) pyramid level\n                containing the `label_value` will be selected.\n            extend_pixels (int): The number of pixels to add to the final\n                image region coordinates on both sides of each axis. Only used\n                if `label_value` is not `None`.\n            pyramid_level (str, optional): The pyramid level (resolution level),\n                from which the intensity image should be extracted. If `None`,\n                the lowest-resolution (highest) pyramid level will be selected.\n            pyramid_level_coord (str, optional): An optional string giving the \n                image pyramid level to which the coordinates (`upper_left_yx`,\n                `lower_right_yx` and `size_yx`) refer to if `coordinate_unit=\"pixel\"`\n                (it is ignored otherwise). By default, this is `None`, which\n                indicates that coordinates refer to `pyramid_level`.\n            channels_labels (list[str], optional): The labels of the image\n                channel(s) to be plotted. This provides an alternative to\n                selecting `channels` by index.\n            scalebar_micrometer (int): If non-zero, add a scale bar corresponding\n                to `scalebar_micrometer` to the image.\n            show_scalebar_label (bool):  If `True`, add micrometer label to scale bar.\n            time_index (int): If the image contains a time axis, this argument\n                determines which time point (provided as the index to retain\n                along the time axis) is plotted. \n            verbose (bool): Whether to print out information messages.\n            **kwargs: Additional arguments for `plotting.plot_image`, for example\n                'channels', 'channel_colors', 'channel_ranges', 'z_projection_method',\n                'show_label_values', 'label_text_colour', 'label_fontsize', etc.\n                For a full list of available arguments, see\n                [plotting.plot_image documentation](plotting.md#src.ez_zarr.plotting.plot_image).\n        Examples:\n            Plot the first channel in cyan from the whole intensity image `img`.\n            &gt;&gt;&gt; img.plot(channels = [0], channel_colors = ['cyan'])\n        \"\"\"\n# digest arguments\nif isinstance(label_name, list):\nlabel_name = [ln for ln in label_name if ln in self.label_names]\nif len(label_name) == 0:\nlabel_name = None\nprint(f\"None of given `label_name`s found in image {self.name}\")\nelse:\nlabel_name = label_name[0]\nprint(f\"Using label_name='{label_name}' for image {self.name}\")\nassert label_name == None or label_name in self.label_names, (\nf\"Unknown label_name ({label_name}), should be `None` or one of \"\n', '.join(self.label_names)\n)\npyramid_level = self._digest_pyramid_level_argument(\npyramid_level=pyramid_level,\nlabel_name=None, verbose=verbose\n)\n# import optional modules\nplotting = importlib.import_module('ez_zarr.plotting')\n# get channel indices\nif channels_labels != None:\nif 'channels' in kwargs:\nwarnings.warn('`channels` will be ignored if `channels_labels` is given')\nkwargs['channels'] = self._digest_channels_labels(channels_labels)\n# extract `channel_colors`\nif 'channels' in kwargs and ('channel_colors' not in kwargs or  len(kwargs['channels']) != len(kwargs['channel_colors'])):\nprint(\"extracting `channel_colors` from image metadata\")\nkwargs['channel_colors'] = ['#' + self.channels[i]['color'] for i in kwargs['channels']]\n# extract `channel_ranges`\nif 'channels' in kwargs and ('channel_ranges' not in kwargs or len(kwargs['channels']) != len(kwargs['channel_ranges'])):\nprint(\"setting `channel_ranges` based on length of `channels`\")\nkwargs['channel_ranges'] = [[0.01, 0.95] for i in range(len(kwargs['channels']))]\n# get coordinates by `label_value` if needed\nif label_value != None:\nif upper_left_yx != None or lower_right_yx != None or size_yx != None:\nwarnings.warn(\"Ignoring provided coordinates since `label_value` was provided.\")\nif label_pyramid_level == None:\nfor label_pyramid_level in reversed(self.pyramid_levels_labels[label_name]):\ncurr_array = self.get_array_by_coordinate(label_name=label_name, pyramid_level=label_pyramid_level,\nverbose=verbose)\nif da.isin(label_value, curr_array).compute():\nbreak\nupper_left_yx, lower_right_yx = self.get_bounding_box_for_label_value(\nlabel_name=label_name,\nlabel_value=label_value,\nlabel_pyramid_level=label_pyramid_level,\nextend_pixels=0,\nlabel_name_output=None,\npyramid_level_output=pyramid_level,\nverbose=verbose\n)\nupper_left_yx = upper_left_yx[-2:]\nlower_right_yx = lower_right_yx[-2:]\nsize_yx = None\ncoordinate_unit = 'pixel'\npyramid_level_coord = None\n# padding\nupper_left_yx = tuple([max(0, upper_left_yx[i] - extend_pixels) for i in range(2)])\nlower_right_yx = tuple([min(self.array_dict[pyramid_level].shape[-2:][i], lower_right_yx[i] + extend_pixels) for i in range(2)])\n# get image and label arrays\nscale_img_spatial = self.get_scale(\npyramid_level=pyramid_level,\nspatial_axes_only=True,\nverbose=verbose\n)\nif label_name == None:\nimg = self.get_array_by_coordinate(\nlabel_name=None,\nupper_left_yx=upper_left_yx,\nlower_right_yx=lower_right_yx,\nsize_yx=size_yx,\ncoordinate_unit=coordinate_unit,\npyramid_level=pyramid_level,\npyramid_level_coord=pyramid_level_coord,\nas_NumPy=True,\nverbose=verbose\n)\nlab = None\nelse:\nimg, lab = self.get_array_pair_by_coordinate(\nlabel_name=label_name,\nupper_left_yx=upper_left_yx,\nlower_right_yx=lower_right_yx,\nsize_yx=size_yx,\ncoordinate_unit=coordinate_unit,\npyramid_level=pyramid_level,\npyramid_level_coord=pyramid_level_coord,\nverbose=verbose\n)\nlab = lab[label_name] # extract label array from dict\n# if there is a time axis, select a single timepoint and \n# remove the time axis for plotting\ntime_dim = [i for i in range(len(self.channel_info_image)) if self.channel_info_image[i] == 't']\nif len(time_dim) == 1:\n# make sure that only one timepoint is selected\nassert type(time_index) is int\n# select a single timepoint and squeeze time axis\nindex = [slice(None)] * img.ndim\nindex[time_dim[0]] = time_index\nimg = img[tuple(index)]\n# same for label image\nif label_name != None:\ntime_dim_lab = [i for i in range(len(self.channel_info_labels[label_name])) if self.channel_info_labels[label_name][i] == 't']\n# if there is a channel axis in the label image and it has \n# length 1, we will collapse it too\nchannel_dim_lab = [i for i in range(len(self.channel_info_labels[label_name])) if self.channel_info_labels[label_name][i] == 'c']\nif len(time_dim_lab) == 1 or len(channel_dim_lab) == 1:\nindex = [slice(None)] * lab.ndim\nif len(time_dim_lab) == 1:\n# make sure that only one timepoint is selected\nassert type(time_index) is int\n# select a single timepoint and squeeze time axis\nindex[time_dim_lab[0]] = time_index\nif len(channel_dim_lab) == 1:\n# make sure that there is only one channel\nassert lab.shape[channel_dim_lab[0]] == 1\n# squeeze the channel dimension\nindex[channel_dim_lab[0]] = 0\nlab = lab[tuple(index)]\n# calculate scalebar length in pixel in x direction\nif scalebar_micrometer != 0:\nkwargs['scalebar_pixel'] = convert_coordinates(\ncoords_from = (scalebar_micrometer,),\nscale_from = [1.0],\nscale_to = [self.get_scale(pyramid_level=pyramid_level, label_name=None)[-1]])[0]\nelse:\nkwargs['scalebar_pixel'] = 0\n# plot image\nif show_scalebar_label:\nkwargs['scalebar_label'] = str(scalebar_micrometer) + ' \u00b5m'\nelse:\nkwargs['scalebar_label'] = None\nkwargs['im'] = img\nkwargs['msk'] = lab\nkwargs['spacing_yx'] = scale_img_spatial[-2:]\nkwargs['verbose'] = verbose\nplotting.plot_image(**kwargs)\n</code></pre>"},{"location":"ome_zarr/#src.ez_zarr.ome_zarr.Image.__init__","title":"<code>__init__(path, name=None, skip_checks=False, verbose=False)</code>","text":"<p>Initializes an OME-Zarr image from its path, containing a single zarr group, possibly with multiple resolution levels, derived labels or tables, but no further groups.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path containing the OME-Zarr image.</p> required <code>name</code> <code>str</code> <p>Optional name for the image.</p> <code>None</code> <code>skip_checks</code> <code>bool</code> <p>If <code>True</code>, no checks are performed.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Whether to print information messages.</p> <code>False</code> <p>Examples:</p> <p>Get an object corresponding to an image.</p> <pre><code>&gt;&gt;&gt; from ez_zarr import ome_zarr\n&gt;&gt;&gt; imageA = ome_zarr.Image('path/to/image')\n</code></pre> Source code in <code>src/ez_zarr/ome_zarr.py</code> <pre><code>def __init__(self, path: str,\nname: Optional[str]=None,\nskip_checks: Optional[bool]=False,\nverbose: bool=False) -&gt; None:\n\"\"\"\n    Initializes an OME-Zarr image from its path, containing a\n    single zarr group, possibly with multiple resolution levels,\n    derived labels or tables, but no further groups.\n    Parameters:\n        path (str): Path containing the OME-Zarr image.\n        name (str, optional): Optional name for the image.\n        skip_checks (bool, optional): If `True`, no checks are performed.\n        verbose (bool): Whether to print information messages.\n    Examples:\n        Get an object corresponding to an image.\n        &gt;&gt;&gt; from ez_zarr import ome_zarr\n        &gt;&gt;&gt; imageA = ome_zarr.Image('path/to/image')\n    \"\"\"\nself.path: str = path\nself.name: str = ''\nif name:\nself.name = name\nelse:\nself.name = os.path.basename(self.path)\nself.zarr_group: zarr.Group = zarr.open(store=self.path, mode='r')\nself.label_names = []\nif 'labels' in list(self.zarr_group.group_keys()):\nself.label_names = [x for x in self.zarr_group['labels'].group_keys()]\nself.table_names = []\nif 'tables' in list(self.zarr_group.group_keys()):\nself.table_names = [x for x in self.zarr_group['tables'].group_keys()]\n# get version info and check that the version is supported\nomezarr_version = None\nif 'ome' in self.zarr_group.attrs:\n# 'ome' was introduced with OME-Zarr v0.5\nif 'version' in self.zarr_group.attrs['ome']:\nomezarr_version = self.zarr_group.attrs['ome']['version']\nelse:\nwarnings.warn(\"Could not determine OME-Zarr version\")\nelse:\nif 'multiscales' not in self.zarr_group.attrs:\nraise ValueError(f\"{self.path} does not contain a 'multiscales' attribute\")\nif 'version' in list(self.zarr_group.attrs['multiscales'][0].keys()):\nomezarr_version = self.zarr_group.attrs['multiscales'][0]['version']\nelse:\nwarnings.warn(\"Could not determine OME-Zarr version\")\nif omezarr_version not in [None, \"0.4\", \"0.5\"]:\nraise ValueError(f\"OME-Zarr version {omezarr_version} is not supported, should be 0.4 or 0.5\")\nif not skip_checks:\n# make sure that it does not contain any further groups\nif len([x for x in self.zarr_group.group_keys() if x not in ['labels', 'tables']]) &gt; 0:\nraise ValueError(f\"{self.path} contains further groups\")\nself.array_dict: dict[str, zarr.Array] = {x[0]: x[1] for x in self.zarr_group.arrays()}\nself.ndim = self.array_dict[list(self.array_dict.keys())[0]].ndim\n# load info about available scales in image and labels\n# ... load multiscales dictionaries\nself.multiscales_image: dict[str, Any] = self._load_multiscale_info(self.zarr_group, skip_checks)\nself.multiscales_labels: dict[str, dict[str, Any]] = {x: self._load_multiscale_info(self.zarr_group['labels'][x], skip_checks) for x in self.label_names}\n# ... extract pyramid levels by decreasing resolution\nself.pyramid_levels_image: list[str] = Image._extract_paths_by_decreasing_resolution(self.multiscales_image['datasets'])\nself.pyramid_levels_labels: dict[str, list[str]] = {x: Image._extract_paths_by_decreasing_resolution(self.multiscales_labels[x]['datasets']) for x in self.label_names}\n# ... axes units\nself.axes_unit_image: str = self._load_axes_unit(self.multiscales_image, verbose, context=\"intensity image\")\nself.axes_unit_labels: dict[str, str] = {x: self._load_axes_unit(self.multiscales_labels[x], verbose, context=f\"label {x}\") for x in self.label_names}\n# load channel metadata\n# ... label dimensions, e.g. \"czyx\"\nself.channel_info_image: str = self._load_channel_info(self.multiscales_image)\nself.channel_info_labels: dict[str, str] = {x: self._load_channel_info(self.multiscales_labels[x]) for x in self.label_names}\n# ... store the number of image channels\nself.nchannels_image: int = self.array_dict[list(self.array_dict.keys())[0]].shape[self.channel_info_image.index('c')] if 'c' in self.channel_info_image else 0\n# ... store channel annotation from OMERO\nself.channels: list[dict[str, Any]] = []\nif 'omero' in self.zarr_group.attrs and 'channels' in self.zarr_group.attrs['omero']:\nself.channels = self.zarr_group.attrs['omero']['channels']\nelif self.nchannels_image &gt; 0:\nself.channels = [{'label': f'channel-{i+1}',\n'color': '00FFFF'} for i in range(self.nchannels_image)]\n</code></pre>"},{"location":"ome_zarr/#src.ez_zarr.ome_zarr.Image.get_array_by_coordinate","title":"<code>get_array_by_coordinate(label_name=None, upper_left_yx=None, lower_right_yx=None, size_yx=None, coordinate_unit='micrometer', pyramid_level=None, pyramid_level_coord=None, as_NumPy=False, verbose=False)</code>","text":"<p>Extract a (sub)array from an image (intensity image or label) by coordinates.</p> <p>None or exactly two of <code>upper_left_yx</code>, <code>lower_right_yx</code> and <code>size_yx</code> need to be given. If none are given, the full image is returned. Otherwise, <code>upper_left_yx</code> contains the lower indices than <code>lower_right_yx</code> (origin on the top-left, zero-based coordinates), and each of them is a tuple of (y, x). No t, c or z coordinate need to be given, all of them are returned if there are several ones.</p> <p>Parameters:</p> Name Type Description Default <code>label_name</code> <code>str</code> <p>The name of the label image to be extracted. If <code>None</code>, the intensity image will be extracted.</p> <code>None</code> <code>upper_left_yx</code> <code>tuple</code> <p>Tuple of (y, x) coordinates for the upper-left (lower) coordinates defining the region of interest.</p> <code>None</code> <code>lower_right_yx</code> <code>tuple</code> <p>Tuple of (y, x) coordinates for the lower-right (higher) coordinates defining the region of interest.</p> <code>None</code> <code>size_yx</code> <code>tuple</code> <p>Tuple of (size_y, size_x) defining the size of the region of interest.</p> <code>None</code> <code>coordinate_unit</code> <code>str</code> <p>The unit of the image coordinates, for example 'micrometer' or 'pixel'.</p> <code>'micrometer'</code> <code>pyramid_level</code> <code>str</code> <p>The pyramid level (resolution level), from which the array should be extracted. If <code>None</code>, the lowest-resolution pyramid level will be selected.</p> <code>None</code> <code>pyramid_level_coord</code> <code>str</code> <p>An optional string giving the  image pyramid level to which the coordinates (<code>upper_left_yx</code>, <code>lower_right_yx</code> and <code>size_yx</code>) refer to if <code>coordinate_unit=\"pixel\"</code> (it is ignored otherwise). By default, this is <code>None</code>, which will use <code>pyramid_level</code>.</p> <code>None</code> <code>as_NumPy</code> <code>bool</code> <p>If <code>True</code>, return the image as a <code>numpy.ndarray</code> object (e.g. c,z,y,x). Otherwise, return the (on-disk) <code>dask</code> array of the same dimensions.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Whether to print out information messages.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[Array, ndarray]</code> <p>The extracted array, either as an on-disk <code>zarr.Array</code>,</p> <code>Union[Array, ndarray]</code> <p>or as an in-memory <code>numpy.ndarray</code> if <code>as_NumPy=True</code>.</p> <p>Examples:</p> <p>Obtain the whole image of the lowest-resolution as an array:</p> <pre><code>&gt;&gt;&gt; img.get_array_by_coordinate()\n</code></pre> Source code in <code>src/ez_zarr/ome_zarr.py</code> <pre><code>def get_array_by_coordinate(self,\nlabel_name: Optional[str]=None,\nupper_left_yx: Optional[tuple[int]]=None,\nlower_right_yx: Optional[tuple[int]]=None,\nsize_yx: Optional[tuple[int]]=None,\ncoordinate_unit: str='micrometer',\npyramid_level: Optional[str]=None,\npyramid_level_coord: Optional[str]=None,\nas_NumPy: bool=False,\nverbose: bool=False) -&gt; Union[zarr.Array, np.ndarray]:\n\"\"\"\n    Extract a (sub)array from an image (intensity image or label) by coordinates.\n    None or exactly two of `upper_left_yx`, `lower_right_yx` and `size_yx`\n    need to be given. If none are given, the full image is returned.\n    Otherwise, `upper_left_yx` contains the lower indices than `lower_right_yx`\n    (origin on the top-left, zero-based coordinates), and each of them is\n    a tuple of (y, x). No t, c or z coordinate need to be given, all of them\n    are returned if there are several ones.\n    Parameters:\n        label_name (str, optional): The name of the label image to be extracted.\n            If `None`, the intensity image will be extracted.\n        upper_left_yx (tuple, optional): Tuple of (y, x) coordinates for the upper-left\n            (lower) coordinates defining the region of interest.\n        lower_right_yx (tuple, optional): Tuple of (y, x) coordinates for the lower-right\n            (higher) coordinates defining the region of interest.\n        size_yx (tuple, optional): Tuple of (size_y, size_x) defining the size of the\n            region of interest.\n        coordinate_unit (str): The unit of the image coordinates, for example\n            'micrometer' or 'pixel'.\n        pyramid_level (str): The pyramid level (resolution level), from which the\n            array should be extracted. If `None`, the lowest-resolution\n            pyramid level will be selected.\n        pyramid_level_coord (str, optional): An optional string giving the \n            image pyramid level to which the coordinates (`upper_left_yx`,\n            `lower_right_yx` and `size_yx`) refer to if `coordinate_unit=\"pixel\"`\n            (it is ignored otherwise). By default, this is `None`, which will\n            use `pyramid_level`.\n        as_NumPy (bool): If `True`, return the image as a `numpy.ndarray`\n            object (e.g. c,z,y,x). Otherwise, return the (on-disk) `dask`\n            array of the same dimensions.\n        verbose (bool): Whether to print out information messages.\n    Returns:\n        The extracted array, either as an on-disk `zarr.Array`,\n        or as an in-memory `numpy.ndarray` if `as_NumPy=True`.\n    Examples:\n        Obtain the whole image of the lowest-resolution as an array:\n        &gt;&gt;&gt; img.get_array_by_coordinate()\n    \"\"\"\n# digest arguments\npyramid_level = self._digest_pyramid_level_argument(pyramid_level=pyramid_level, \nlabel_name=label_name, verbose=verbose)\n# load image\nif label_name:\narr = self.zarr_group['labels'][label_name][pyramid_level]\nelse:\narr = self.zarr_group[pyramid_level]\n# calculate corner coordinates\nupper_left_yx, lower_right_yx = self._digest_bounding_box(\nupper_left_yx=upper_left_yx,\nlower_right_yx=lower_right_yx,\nsize_yx=size_yx,\ncoordinate_unit=coordinate_unit,\nlabel_name=label_name,\npyramid_level=pyramid_level,\npyramid_level_coord=pyramid_level_coord,\nverbose=verbose)\n# subset array if needed\nif upper_left_yx != (0, 0) or lower_right_yx != arr.shape[-2:]:\narr = arr[...,\nslice(upper_left_yx[0], lower_right_yx[0]),\nslice(upper_left_yx[1], lower_right_yx[1])]\n# convert if needed and return\nif as_NumPy:\narr = np.array(arr)\nreturn arr\n</code></pre>"},{"location":"ome_zarr/#src.ez_zarr.ome_zarr.Image.get_array_pair_by_coordinate","title":"<code>get_array_pair_by_coordinate(label_name, upper_left_yx=None, lower_right_yx=None, size_yx=None, coordinate_unit='micrometer', pyramid_level=None, pyramid_level_coord=None, verbose=False)</code>","text":"<p>Extract a matching pair of (sub)arrays (intensity and label) by coordinates.</p> <p>None or exactly two of <code>upper_left_yx</code>, <code>lower_right_yx</code> and <code>size_yx</code> need to be given. If none are given, the full image is returned. Otherwise, <code>upper_left_yx</code> contains the lower indices than <code>lower_right_yx</code> (origin on the top-left, zero-based coordinates), and each of them is a tuple of (y, x). No t, c or z coordinate need to be given, all of them are returned if there are several ones.</p> <p>Coordinate and pyramid level arguments all refer to the intensity image. For the label, matching values will be selected automatically, and if necessary, the label array is resized to match the intensity array.</p> <p>Parameters:</p> Name Type Description Default <code>label_name</code> <code>str or list of str</code> <p>The name(s) of the label image(s) to be extracted.</p> required <code>upper_left_yx</code> <code>tuple</code> <p>Tuple of (y, x) intensity image coordinates for the upper-left (lower) coordinates defining the region of interest.</p> <code>None</code> <code>lower_right_yx</code> <code>tuple</code> <p>Tuple of (y, x) intensity image coordinates for the lower-right (higher) coordinates defining the region of interest.</p> <code>None</code> <code>size_yx</code> <code>tuple</code> <p>Tuple of (size_y, size_x) defining the size of the intensity image region of interest.</p> <code>None</code> <code>coordinate_unit</code> <code>str</code> <p>The unit of the image coordinates, for example 'micrometer' or 'pixel'.</p> <code>'micrometer'</code> <code>pyramid_level</code> <code>str</code> <p>The intensity image pyramid level (resolution level), from which the intensity array should be extracted. If <code>None</code>, the lowest-resolution pyramid level will be selected. A matching pyramid level for the label will be selected automatically.</p> <code>None</code> <code>pyramid_level_coord</code> <code>str</code> <p>An optional string giving the  intensity image pyramid level to which the coordinates (if any) refer to if <code>coordinate_unit=\"pixel\"</code> (it is ignored otherwise). By default, this is <code>None</code>, which will use <code>pyramid_level</code>.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Whether to print out information messages.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[ndarray]</code> <p>A tuple of length two, with the first element corresponding to</p> <code>tuple[ndarray]</code> <p>a <code>numpy.ndarray</code> with the extracted intensity array and the</p> <code>tuple[ndarray]</code> <p>second element a dictionary with keys corresponding to the</p> <code>tuple[ndarray]</code> <p><code>label_name</code> and the values corresponding to label arrays.</p> <code>tuple[ndarray]</code> <p>Label arrays are resized if necessary to match the intensity</p> <code>tuple[ndarray]</code> <p>array.</p> <p>Examples:</p> <p>Obtain the whole image and matching 'organoids' label arrays:</p> <pre><code>&gt;&gt;&gt; img, lab = img.get_array_pair_by_coordinate(label_name = 'organoids')\n</code></pre> Source code in <code>src/ez_zarr/ome_zarr.py</code> <pre><code>def get_array_pair_by_coordinate(self,\nlabel_name: Union[str, list[str]],\nupper_left_yx: Optional[tuple[int]]=None,\nlower_right_yx: Optional[tuple[int]]=None,\nsize_yx: Optional[tuple[int]]=None,\ncoordinate_unit: str='micrometer',\npyramid_level: Optional[str]=None,\npyramid_level_coord: Optional[str]=None,\nverbose: bool=False) -&gt; tuple[np.ndarray]:\n\"\"\"\n    Extract a matching pair of (sub)arrays (intensity and label) by coordinates.\n    None or exactly two of `upper_left_yx`, `lower_right_yx` and `size_yx`\n    need to be given. If none are given, the full image is returned.\n    Otherwise, `upper_left_yx` contains the lower indices than `lower_right_yx`\n    (origin on the top-left, zero-based coordinates), and each of them is\n    a tuple of (y, x). No t, c or z coordinate need to be given, all of them\n    are returned if there are several ones.\n    Coordinate and pyramid level arguments all refer to the intensity image.\n    For the label, matching values will be selected automatically, and if\n    necessary, the label array is resized to match the intensity array.\n    Parameters:\n        label_name (str or list of str): The name(s) of the label image(s)\n            to be extracted.\n        upper_left_yx (tuple, optional): Tuple of (y, x) intensity image\n            coordinates for the upper-left (lower) coordinates defining the\n            region of interest.\n        lower_right_yx (tuple, optional): Tuple of (y, x) intensity image\n            coordinates for the lower-right (higher) coordinates defining the\n            region of interest.\n        size_yx (tuple, optional): Tuple of (size_y, size_x) defining the size\n            of the intensity image region of interest.\n        coordinate_unit (str): The unit of the image coordinates, for example\n            'micrometer' or 'pixel'.\n        pyramid_level (str): The intensity image pyramid level (resolution\n            level), from which the intensity array should be extracted.\n            If `None`, the lowest-resolution pyramid level will be selected.\n            A matching pyramid level for the label will be selected\n            automatically.\n        pyramid_level_coord (str, optional): An optional string giving the \n            intensity image pyramid level to which the coordinates (if any)\n            refer to if `coordinate_unit=\"pixel\"` (it is ignored otherwise).\n            By default, this is `None`, which will use `pyramid_level`.\n        verbose (bool): Whether to print out information messages.\n    Returns:\n        A tuple of length two, with the first element corresponding to\n        a `numpy.ndarray` with the extracted intensity array and the\n        second element a dictionary with keys corresponding to the\n        `label_name` and the values corresponding to label arrays.\n        Label arrays are resized if necessary to match the intensity\n        array.\n    Examples:\n        Obtain the whole image and matching 'organoids' label arrays:\n        &gt;&gt;&gt; img, lab = img.get_array_pair_by_coordinate(label_name = 'organoids')\n    \"\"\"\n# digest arguments\nif isinstance(label_name, str):\nlabel_name = [label_name]\nassert isinstance(label_name, list) and all([ln in self.label_names for ln in label_name]), (\nf\"Unknown label_name(s) ({', '.join([ln for ln in label_name if ln not in self.label_names])}), should be one of \"\n', '.join(self.label_names)\n)\npyramid_level = self._digest_pyramid_level_argument(\npyramid_level=pyramid_level,\nlabel_name=None, verbose=verbose\n)\nif pyramid_level_coord is None:\npyramid_level_coord = pyramid_level\n# get intensity image scale\nimg_scale_spatial = self.get_scale(\npyramid_level=pyramid_level,\nlabel_name=None,\nspatial_axes_only=True,\nverbose=verbose\n)\n# loop over label names\nlab_arr_dict = {}\nfor lname in label_name:\n# find matching label pyramid level\nlab_scale_spatial_dict = {\npl: self.get_scale(pyramid_level=pl, label_name=lname, spatial_axes_only=True, verbose=verbose) for pl in self.get_pyramid_levels(label_name=lname)\n}\n# ... filter out label scales with higher resolution than the intensity image\nlab_scale_spatial_dict = {pl: lab_scale_spatial for pl, lab_scale_spatial in lab_scale_spatial_dict.items() if all([lab_scale_spatial[i] &gt;= img_scale_spatial[i] for i in range(len(lab_scale_spatial))])}\nif len(lab_scale_spatial_dict) == 0:\nraise ValueError(f\"For the requested pyramid level ({pyramid_level}) of the intensity image, down-scaling of an available label ('{lname}') would be required. Down-scaling of labels is not supported - try selecting a higher-resolution intensity image.\")\nnearest_scale_idx = np.argmin([np.mean(np.array(lab_scale_spatial_dict[pl]) / np.array(img_scale_spatial)) for pl in lab_scale_spatial_dict.keys()])\nnearest_scale_pl = list(lab_scale_spatial_dict.keys())[nearest_scale_idx]\nlab_scale_spatial = lab_scale_spatial_dict[nearest_scale_pl]\n# calculate image corner points\nimgpixel_upper_left_yx, imgpixel_lower_right_yx = self._digest_bounding_box(\nupper_left_yx=upper_left_yx,\nlower_right_yx=lower_right_yx,\nsize_yx=size_yx,\ncoordinate_unit=coordinate_unit,\nlabel_name=None,\npyramid_level=pyramid_level,\npyramid_level_coord=pyramid_level_coord,\nverbose=verbose\n)\n# make sure that the dimensions are divisible by\n# the yx scaling factor between intensity and label arrays\nscalefact_yx = np.divide(lab_scale_spatial, img_scale_spatial)\nimgpixel_upper_left_yx = tuple((np.floor_divide(imgpixel_upper_left_yx, scalefact_yx[-2:]) * scalefact_yx[-2:]))\nimgpixel_lower_right_yx = tuple((np.floor_divide(imgpixel_lower_right_yx, scalefact_yx[-2:]) * scalefact_yx[-2:]))\n# get intensity array\nimg_arr = self.get_array_by_coordinate(\nupper_left_yx=imgpixel_upper_left_yx,\nlower_right_yx=imgpixel_lower_right_yx,\nsize_yx=None,\ncoordinate_unit='pixel',\nlabel_name=None,\npyramid_level=pyramid_level, \nas_NumPy=False,\nverbose=verbose\n)\n# convert intensity coordiantes to label coordinates\nlabpixel_upper_left_yx = convert_coordinates(\nimgpixel_upper_left_yx,\nimg_scale_spatial[-2:],\nlab_scale_spatial[-2:]\n)\nlabpixel_lower_right_yx = convert_coordinates(\nimgpixel_lower_right_yx,\nimg_scale_spatial[-2:],\nlab_scale_spatial[-2:]\n)\n# get label array\nlab_arr = np.array(self.get_array_by_coordinate(\nupper_left_yx=labpixel_upper_left_yx,\nlower_right_yx=labpixel_lower_right_yx,\nsize_yx=None,\ncoordinate_unit='pixel',\nlabel_name=lname,\npyramid_level=nearest_scale_pl,\nverbose=verbose\n))\n# resize label if needed (correct non-matching scales or rounding errors)\nif lab_arr.shape[-2:] != img_arr.shape[-2:]:\nwarnings.warn(f\"For the requested pyramid level ({pyramid_level}) of the intensity image, no matching label ('{lname}') is available. Up-scaling the label using factor(s) {scalefact_yx}\")\nlab_arr = resize_image(\nim=lab_arr,\noutput_shape=img_arr.shape[(img_arr.ndim-lab_arr.ndim):],\nim_type='label',\nnumber_nonspatial_axes=sum([int(s not in ['z','y','x']) for s in self.channel_info_labels[lname]]),\nverbose=verbose\n)\n# store label array in dictionary\nlab_arr_dict[lname] = lab_arr\n# return arrays\nreturn tuple([np.array(img_arr), lab_arr_dict])\n</code></pre>"},{"location":"ome_zarr/#src.ez_zarr.ome_zarr.Image.get_bounding_box_for_label_value","title":"<code>get_bounding_box_for_label_value(label_name, label_value, label_pyramid_level, extend_pixels=0, label_name_output=None, pyramid_level_output=None, verbose=False)</code>","text":"<p>Given a label name and value, find the corner coordinates of the bounding box.</p> <p>Parameters:</p> Name Type Description Default <code>label_name</code> <code>str</code> <p>The name of the label image to extract the bounding box from.</p> required <code>label_value</code> <code>(int, float, str)</code> <p>The value of the label to extract the bounding box for.</p> required <code>label_pyramid_level</code> <code>(int, str)</code> <p>The pyramid level to extract the bounding box from.</p> required <code>extend_pixels</code> <code>int</code> <p>The number of pixels to add to each side for each axis of the bounding box (before possible conversion to <code>label_name_output</code> and <code>pyramid_level_output</code>).</p> <code>0</code> <code>label_name_output</code> <code>str or None</code> <p>The name of the label image to which the returned bounding box coordinates refer to. If <code>None</code> (the default), the coordinates refer to the intensity image.</p> <code>None</code> <code>pyramid_level_output</code> <code>str or None</code> <p>The pyramid level to which the returned bounding box coordinates refer to. If <code>None</code> (the default), the coordinates refer to the highest resolution pyramid level.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Whether to print out information messages.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[tuple[tuple[int, ...], tuple[int, ...]], tuple[None, None]]</code> <p>A tuple of upper-left and lower-right pixel coordinates for the bounding</p> <code>Union[tuple[tuple[int, ...], tuple[int, ...]], tuple[None, None]]</code> <p>box containing the label value in the requested output space, or</p> <code>Union[tuple[tuple[int, ...], tuple[int, ...]], tuple[None, None]]</code> <p>Throws an error if the label value is not found.</p> <code>Union[tuple[tuple[int, ...], tuple[int, ...]], tuple[None, None]]</code> <p>For a 2D label image, this would be <code>((y1, x1), (y2, x2))</code>.</p> Example <p>Get the bounding box for the 'nuclei' label value 1 from pyramid level 0,in the space of highest-resolution pyramid level of the intensity image:</p> <p>img.get_bounding_box_for_label_value(label_name='nuclei', label_value=1, label_pyramid_level=0)</p> Source code in <code>src/ez_zarr/ome_zarr.py</code> <pre><code>def get_bounding_box_for_label_value(self,\nlabel_name: str,\nlabel_value: Union[int, float, str],\nlabel_pyramid_level: str,\nextend_pixels: Optional[int]=0,\nlabel_name_output: Optional[str]=None,\npyramid_level_output: Optional[str]=None,\nverbose: bool=False) -&gt; Union[tuple[tuple[int, ...], tuple[int, ...]], tuple[None, None]]:\n\"\"\"\n    Given a label name and value, find the corner coordinates of the bounding box.\n    Parameters:\n        label_name (str): The name of the label image to extract the bounding\n            box from.\n        label_value (int, float, str): The value of the label to extract the\n            bounding box for.\n        label_pyramid_level (int, str): The pyramid level to extract the bounding\n            box from.\n        extend_pixels (int): The number of pixels to add to each side for each\n            axis of the bounding box (before possible conversion to\n            `label_name_output` and `pyramid_level_output`).\n        label_name_output (str or None): The name of the label image to which\n            the returned bounding box coordinates refer to. If `None` (the\n            default), the coordinates refer to the intensity image.\n        pyramid_level_output (str or None): The pyramid level to which the\n            returned bounding box coordinates refer to. If `None` (the\n            default), the coordinates refer to the highest resolution pyramid\n            level.\n        verbose (bool): Whether to print out information messages.\n    Returns:\n        A tuple of upper-left and lower-right pixel coordinates for the bounding\n        box containing the label value in the requested output space, or\n        Throws an error if the label value is not found.\n        For a 2D label image, this would be `((y1, x1), (y2, x2))`.\n    Example:\n        Get the bounding box for the 'nuclei' label value 1 from pyramid\n        level 0,in the space of highest-resolution pyramid level of\n        the intensity image:\n        &gt;&gt;&gt; img.get_bounding_box_for_label_value(label_name='nuclei', label_value=1, label_pyramid_level=0)\n    \"\"\"\n# digest arguments\nassert label_name in self.label_names, f'`label_name` must be in {self.label_names}'\nlabel_pyramid_level = self._digest_pyramid_level_argument(pyramid_level=label_pyramid_level, \nlabel_name=label_name, verbose=verbose)\nassert isinstance(extend_pixels, int), '`extend_pixels` must be an integer scalar'\nassert isinstance(label_name_output, str) or label_name_output is None\npyramid_level_output = self._digest_pyramid_level_argument(\npyramid_level_output, label_name_output, default_to='highest', verbose=verbose)\n# get label array\nlab_arr = self.get_array_by_coordinate(label_name=label_name,\npyramid_level=label_pyramid_level)\n# find bounding box\nvalue_coordinates = np.equal(lab_arr, label_value).nonzero()\nif len(value_coordinates[0]) == 0:\nraise ValueError(f'Label value {label_value} not found in label {label_name}')\nupper_left = tuple([min(x) for x in value_coordinates])\nlower_right = tuple([max(x) + 1 for x in value_coordinates])\n# padding\nupper_left = tuple([max(0, upper_left[i] - extend_pixels) for i in range(len(upper_left))])\nlower_right = tuple([min(lab_arr.shape[i], lower_right[i] + extend_pixels) for i in range(len(lower_right))])\n# convert to output space\nin_scale = self.get_scale(pyramid_level=label_pyramid_level,\nlabel_name=label_name,\nspatial_axes_only=True,\nverbose=verbose)\nout_scale = self.get_scale(pyramid_level=pyramid_level_output,\nlabel_name=label_name_output,\nspatial_axes_only=True,\nverbose=verbose)\nupper_left_out = convert_coordinates(coords_from=upper_left,\nscale_from=in_scale,\nscale_to=out_scale)\nlower_right_out = convert_coordinates(coords_from=lower_right,\nscale_from=in_scale,\nscale_to=out_scale)\n# return result\nreturn tuple([tuple([round(x) for x in upper_left_out]),\ntuple([round(x) for x in lower_right_out])])\n</code></pre>"},{"location":"ome_zarr/#src.ez_zarr.ome_zarr.Image.get_channels","title":"<code>get_channels()</code>","text":"<p>Get info on channels in an OME-Zarr image.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of dicts with information on channels.</p> Source code in <code>src/ez_zarr/ome_zarr.py</code> <pre><code>def get_channels(self) -&gt; list:\n\"\"\"Get info on channels in an OME-Zarr image.\n    Returns:\n        A list of dicts with information on channels.\n    \"\"\"\nreturn self.channels\n</code></pre>"},{"location":"ome_zarr/#src.ez_zarr.ome_zarr.Image.get_label_names","title":"<code>get_label_names()</code>","text":"<p>Get list of label names in an OME-Zarr image.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of label names (str) available for the image.</p> Source code in <code>src/ez_zarr/ome_zarr.py</code> <pre><code>def get_label_names(self) -&gt; list:\n\"\"\"Get list of label names in an OME-Zarr image.\n    Returns:\n        A list of label names (str) available for the image.\n    \"\"\"\nreturn self.label_names\n</code></pre>"},{"location":"ome_zarr/#src.ez_zarr.ome_zarr.Image.get_path","title":"<code>get_path()</code>","text":"<p>Get the path of an OME-Zarr image.</p> <p>Returns:</p> Type Description <code>str</code> <p>The path to the OME-Zarr image.</p> Source code in <code>src/ez_zarr/ome_zarr.py</code> <pre><code>def get_path(self) -&gt; str:\n\"\"\"Get the path of an OME-Zarr image.\n    Returns:\n        The path to the OME-Zarr image.\n    \"\"\"\nreturn self.path\n</code></pre>"},{"location":"ome_zarr/#src.ez_zarr.ome_zarr.Image.get_pyramid_levels","title":"<code>get_pyramid_levels(label_name=None)</code>","text":"<p>Get list of pyramid levels in an OME-Zarr image.</p> <p>Parameters:</p> Name Type Description Default <code>label_name</code> <code>str</code> <p>The name of the label image for which to return pyramid levels. If None, pyramid levels from the intensity image are returned.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of available pyramid levels (str).</p> Source code in <code>src/ez_zarr/ome_zarr.py</code> <pre><code>def get_pyramid_levels(self, label_name: Optional[str]=None) -&gt; list[str]:\n\"\"\"Get list of pyramid levels in an OME-Zarr image.\n    Parameters:\n        label_name (str, optional): The name of the label image for which\n            to return pyramid levels. If None, pyramid levels from the\n            intensity image are returned.\n    Returns:\n        A list of available pyramid levels (str).\n    \"\"\"\nif label_name:\nreturn [str(x['path']) for x in self.multiscales_labels[label_name]['datasets']]\nelse:\nreturn [str(x['path']) for x in self.multiscales_image['datasets']]\n</code></pre>"},{"location":"ome_zarr/#src.ez_zarr.ome_zarr.Image.get_scale","title":"<code>get_scale(pyramid_level, label_name=None, spatial_axes_only=False, verbose=False)</code>","text":"<p>Get the scale of a given pyramid level.</p> <p>Parameters:</p> Name Type Description Default <code>pyramid_level</code> <code>str</code> <p>The pyramid level from which to get the scale.</p> required <code>label_name</code> <code>str or None</code> <p>The name of the label image to which <code>pyramid_level</code> refers to. If None, <code>pyramid_level</code> is assumed to refer to the intensity image.</p> <code>None</code> <code>spatial_axes_only</code> <code>bool</code> <p>If True, only the scales for spatial dimensions are returned.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Whether to print out information messages.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[float]</code> <p>A list with the axis scales of the given pyramid level.</p> Example <p>Get the axis scales of the first pyramid level:</p> <p>scale = img.get_scale('level_0', 'nuclei')</p> Source code in <code>src/ez_zarr/ome_zarr.py</code> <pre><code>def get_scale(self,\npyramid_level: str,\nlabel_name: Optional[str]=None,\nspatial_axes_only: bool=False,\nverbose: bool=False) -&gt; list[float]:\n\"\"\"\n    Get the scale of a given pyramid level.\n    Parameters:\n        pyramid_level (str): The pyramid level from which to get the scale.\n        label_name (str or None): The name of the label image to which\n            `pyramid_level` refers to. If None, `pyramid_level` is assumed\n            to refer to the intensity image.\n        spatial_axes_only (bool): If True, only the scales for spatial\n            dimensions are returned.\n        verbose (bool): Whether to print out information messages.\n    Returns:\n        A list with the axis scales of the given pyramid level.\n    Example:\n        Get the axis scales of the first pyramid level:\n        &gt;&gt;&gt; scale = img.get_scale('level_0', 'nuclei')\n    \"\"\"\n# digest arguments\npyramid_level = self._digest_pyramid_level_argument(pyramid_level=pyramid_level, \nlabel_name=label_name, default_to=\"lowest\",\nverbose=verbose)\n# extract scale\nif label_name:\ndatasets_list = self.multiscales_labels[label_name]['datasets']\nchannel_info = self.channel_info_labels[label_name]\nelse:\ndatasets_list = self.multiscales_image['datasets']\nchannel_info = self.channel_info_image\nscale = [x['coordinateTransformations'][0]['scale']\nfor x in datasets_list\nif str(x['path']) == pyramid_level][0]\nif spatial_axes_only:\nscale = [scale[i]\nfor i in range(len(scale))\nif channel_info[i] in ['z', 'y', 'x']]\n# return\nreturn scale\n</code></pre>"},{"location":"ome_zarr/#src.ez_zarr.ome_zarr.Image.get_table","title":"<code>get_table(table_name, as_AnnData=False)</code>","text":"<p>Extract tabular data (for example quantifications) for OME-Zarr image.</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>The name of the table to extract.</p> required <code>as_AnnData</code> <code>bool</code> <p>If <code>True</code>, the table is returned as an <code>AnnData</code> object, otherwise it is returned as a <code>pandas.DataFrame</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>The extracted table, either as an <code>anndata.AnnData</code> object if <code>as_AnnData=True</code>, or a <code>pandas.DataFrame</code> otherwise. <code>None</code> if <code>table_name</code> is not found.</p> <p>Examples:</p> <p>List available tables names, and get table 'FOV_ROI_table':</p> <pre><code>&gt;&gt;&gt; img.get_table_names()\n&gt;&gt;&gt; img.get_table(table_name='FOV_ROI_table')\n</code></pre> Source code in <code>src/ez_zarr/ome_zarr.py</code> <pre><code>def get_table(self,\ntable_name: str,\nas_AnnData: bool=False) -&gt; Any:\n\"\"\"Extract tabular data (for example quantifications) for OME-Zarr image.\n    Parameters:\n        table_name (str): The name of the table to extract.\n        as_AnnData (bool): If `True`, the table is returned as an `AnnData` object, otherwise it is returned as a `pandas.DataFrame`.\n    Returns:\n        The extracted table, either as an `anndata.AnnData` object if `as_AnnData=True`, or a `pandas.DataFrame` otherwise. `None` if `table_name` is not found.\n    Examples:\n        List available tables names, and get table 'FOV_ROI_table':\n        &gt;&gt;&gt; img.get_table_names()\n        &gt;&gt;&gt; img.get_table(table_name='FOV_ROI_table')\n    \"\"\"\n# check for existing table_name\nif table_name not in self.table_names:\nwarnings.warn(f\"Table '{table_name}' not found in image at {self.path}.\")\nreturn None\nwith warnings.catch_warnings():\nwarnings.filterwarnings(\"ignore\")\nad = importlib.import_module('anndata')\nanndata = ad.read_zarr(os.path.join(self.path, 'tables', table_name))\nif as_AnnData:\nreturn anndata\nelse:\nreturn anndata.to_df()\n</code></pre>"},{"location":"ome_zarr/#src.ez_zarr.ome_zarr.Image.get_table_names","title":"<code>get_table_names()</code>","text":"<p>Get list of table names in an OME-Zarr image.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of table names (str) available for the image.</p> Source code in <code>src/ez_zarr/ome_zarr.py</code> <pre><code>def get_table_names(self) -&gt; list:\n\"\"\"Get list of table names in an OME-Zarr image.\n    Returns:\n        A list of table names (str) available for the image.\n    \"\"\"\nreturn self.table_names\n</code></pre>"},{"location":"ome_zarr/#src.ez_zarr.ome_zarr.Image.plot","title":"<code>plot(upper_left_yx=None, lower_right_yx=None, size_yx=None, coordinate_unit='micrometer', label_name=None, label_value=None, label_pyramid_level=None, extend_pixels=0, pyramid_level=None, pyramid_level_coord=None, channels_labels=None, scalebar_micrometer=0, show_scalebar_label=True, time_index=0, verbose=False, **kwargs)</code>","text":"<p>Plot an image.</p> <p>Plot a single image or a part of it, optionally selecting channels by label and extracting colors from the OMERO metadata using data at resolution <code>pyramid_level</code>.</p> <p>Parameters:</p> Name Type Description Default <code>upper_left_yx</code> <code>tuple</code> <p>Tuple of (y, x) coordinates for the upper-left (lower) coordinates defining the region of interest.</p> <code>None</code> <code>lower_right_yx</code> <code>tuple</code> <p>Tuple of (y, x) coordinates for the lower-right (higher) coordinates defining the region of interest.</p> <code>None</code> <code>size_yx</code> <code>tuple</code> <p>Tuple of (size_y, size_x) defining the size of the region of interest.</p> <code>None</code> <code>coordinate_unit</code> <code>str</code> <p>The unit of the image coordinates, for example 'micrometer' or 'pixel'.</p> <code>'micrometer'</code> <code>label_name</code> <code>str or list of str</code> <p>The segmentation mask name or names to be plotted semi-transparently over the intensity image. If this is a list of multiple names, the first one that is available for the image will be used. If <code>None</code>, just the intensity image is plotted.</p> <code>None</code> <code>label_value</code> <code>(int, float, str)</code> <p>The value of the label, for which bounding box coordinates should be extracted.  The highest resolution pyramid level will be used.If not <code>None</code>, <code>label_value</code> will automatically determine <code>upper_left_yx</code>, <code>lower_right_yx</code> and <code>size_yx</code>. Any values given to those or to <code>coordinate_unit</code> and <code>pyramid_level_coord</code> will be ignored.</p> <code>None</code> <code>label_pyramid_level</code> <code>str</code> <p>The pyramid level (resolution level), from which the label image should be extracted if <code>label_value</code> is not <code>None</code>. If <code>None</code>, the lowest-resolution (highest) pyramid level containing the <code>label_value</code> will be selected.</p> <code>None</code> <code>extend_pixels</code> <code>int</code> <p>The number of pixels to add to the final image region coordinates on both sides of each axis. Only used if <code>label_value</code> is not <code>None</code>.</p> <code>0</code> <code>pyramid_level</code> <code>str</code> <p>The pyramid level (resolution level), from which the intensity image should be extracted. If <code>None</code>, the lowest-resolution (highest) pyramid level will be selected.</p> <code>None</code> <code>pyramid_level_coord</code> <code>str</code> <p>An optional string giving the  image pyramid level to which the coordinates (<code>upper_left_yx</code>, <code>lower_right_yx</code> and <code>size_yx</code>) refer to if <code>coordinate_unit=\"pixel\"</code> (it is ignored otherwise). By default, this is <code>None</code>, which indicates that coordinates refer to <code>pyramid_level</code>.</p> <code>None</code> <code>channels_labels</code> <code>list[str]</code> <p>The labels of the image channel(s) to be plotted. This provides an alternative to selecting <code>channels</code> by index.</p> <code>None</code> <code>scalebar_micrometer</code> <code>int</code> <p>If non-zero, add a scale bar corresponding to <code>scalebar_micrometer</code> to the image.</p> <code>0</code> <code>show_scalebar_label</code> <code>bool</code> <p>If <code>True</code>, add micrometer label to scale bar.</p> <code>True</code> <code>time_index</code> <code>int</code> <p>If the image contains a time axis, this argument determines which time point (provided as the index to retain along the time axis) is plotted. </p> <code>0</code> <code>verbose</code> <code>bool</code> <p>Whether to print out information messages.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for <code>plotting.plot_image</code>, for example 'channels', 'channel_colors', 'channel_ranges', 'z_projection_method', 'show_label_values', 'label_text_colour', 'label_fontsize', etc. For a full list of available arguments, see plotting.plot_image documentation.</p> <code>{}</code> <p>Examples:</p> <p>Plot the first channel in cyan from the whole intensity image <code>img</code>.</p> <pre><code>&gt;&gt;&gt; img.plot(channels = [0], channel_colors = ['cyan'])\n</code></pre> Source code in <code>src/ez_zarr/ome_zarr.py</code> <pre><code>def plot(self,\nupper_left_yx: Optional[tuple[int]]=None,\nlower_right_yx: Optional[tuple[int]]=None,\nsize_yx: Optional[tuple[int]]=None,\ncoordinate_unit: str='micrometer',\nlabel_name: Optional[Union[list[str], str]]=None,\nlabel_value: Optional[Union[int, float, str]]=None,\nlabel_pyramid_level: Optional[str]=None,\nextend_pixels: int=0,\npyramid_level: Optional[str]=None,\npyramid_level_coord: Optional[str]=None,\nchannels_labels: Optional[list[str]]=None,\nscalebar_micrometer: int=0,\nshow_scalebar_label: bool=True,\ntime_index: int=0,\nverbose: bool=False,\n**kwargs: Any) -&gt; None:\n\"\"\"\n    Plot an image.\n    Plot a single image or a part of it, optionally selecting\n    channels by label and extracting colors from the OMERO metadata\n    using data at resolution `pyramid_level`.\n    Parameters:\n        upper_left_yx (tuple, optional): Tuple of (y, x) coordinates\n            for the upper-left (lower) coordinates defining the region\n            of interest.\n        lower_right_yx (tuple, optional): Tuple of (y, x) coordinates\n            for the lower-right (higher) coordinates defining the region\n            of interest.\n        size_yx (tuple, optional): Tuple of (size_y, size_x) defining\n            the size of the region of interest.\n        coordinate_unit (str): The unit of the image coordinates, for\n            example 'micrometer' or 'pixel'.\n        label_name (str or list of str, optional): The segmentation\n            mask name or names to be plotted semi-transparently over\n            the intensity image. If this is a list of multiple names, the\n            first one that is available for the image will be\n            used. If `None`, just the intensity image is plotted.\n        label_value (int, float, str, optional): The value of the label,\n            for which bounding box coordinates should be extracted. \n            The highest resolution pyramid level will be used.If\n            not `None`, `label_value` will automatically determine `upper_left_yx`,\n            `lower_right_yx` and `size_yx`. Any values given to those or\n            to `coordinate_unit` and `pyramid_level_coord` will be ignored.\n        label_pyramid_level (str, optional): The pyramid level (resolution level),\n            from which the label image should be extracted if `label_value` is\n            not `None`. If `None`, the lowest-resolution (highest) pyramid level\n            containing the `label_value` will be selected.\n        extend_pixels (int): The number of pixels to add to the final\n            image region coordinates on both sides of each axis. Only used\n            if `label_value` is not `None`.\n        pyramid_level (str, optional): The pyramid level (resolution level),\n            from which the intensity image should be extracted. If `None`,\n            the lowest-resolution (highest) pyramid level will be selected.\n        pyramid_level_coord (str, optional): An optional string giving the \n            image pyramid level to which the coordinates (`upper_left_yx`,\n            `lower_right_yx` and `size_yx`) refer to if `coordinate_unit=\"pixel\"`\n            (it is ignored otherwise). By default, this is `None`, which\n            indicates that coordinates refer to `pyramid_level`.\n        channels_labels (list[str], optional): The labels of the image\n            channel(s) to be plotted. This provides an alternative to\n            selecting `channels` by index.\n        scalebar_micrometer (int): If non-zero, add a scale bar corresponding\n            to `scalebar_micrometer` to the image.\n        show_scalebar_label (bool):  If `True`, add micrometer label to scale bar.\n        time_index (int): If the image contains a time axis, this argument\n            determines which time point (provided as the index to retain\n            along the time axis) is plotted. \n        verbose (bool): Whether to print out information messages.\n        **kwargs: Additional arguments for `plotting.plot_image`, for example\n            'channels', 'channel_colors', 'channel_ranges', 'z_projection_method',\n            'show_label_values', 'label_text_colour', 'label_fontsize', etc.\n            For a full list of available arguments, see\n            [plotting.plot_image documentation](plotting.md#src.ez_zarr.plotting.plot_image).\n    Examples:\n        Plot the first channel in cyan from the whole intensity image `img`.\n        &gt;&gt;&gt; img.plot(channels = [0], channel_colors = ['cyan'])\n    \"\"\"\n# digest arguments\nif isinstance(label_name, list):\nlabel_name = [ln for ln in label_name if ln in self.label_names]\nif len(label_name) == 0:\nlabel_name = None\nprint(f\"None of given `label_name`s found in image {self.name}\")\nelse:\nlabel_name = label_name[0]\nprint(f\"Using label_name='{label_name}' for image {self.name}\")\nassert label_name == None or label_name in self.label_names, (\nf\"Unknown label_name ({label_name}), should be `None` or one of \"\n', '.join(self.label_names)\n)\npyramid_level = self._digest_pyramid_level_argument(\npyramid_level=pyramid_level,\nlabel_name=None, verbose=verbose\n)\n# import optional modules\nplotting = importlib.import_module('ez_zarr.plotting')\n# get channel indices\nif channels_labels != None:\nif 'channels' in kwargs:\nwarnings.warn('`channels` will be ignored if `channels_labels` is given')\nkwargs['channels'] = self._digest_channels_labels(channels_labels)\n# extract `channel_colors`\nif 'channels' in kwargs and ('channel_colors' not in kwargs or  len(kwargs['channels']) != len(kwargs['channel_colors'])):\nprint(\"extracting `channel_colors` from image metadata\")\nkwargs['channel_colors'] = ['#' + self.channels[i]['color'] for i in kwargs['channels']]\n# extract `channel_ranges`\nif 'channels' in kwargs and ('channel_ranges' not in kwargs or len(kwargs['channels']) != len(kwargs['channel_ranges'])):\nprint(\"setting `channel_ranges` based on length of `channels`\")\nkwargs['channel_ranges'] = [[0.01, 0.95] for i in range(len(kwargs['channels']))]\n# get coordinates by `label_value` if needed\nif label_value != None:\nif upper_left_yx != None or lower_right_yx != None or size_yx != None:\nwarnings.warn(\"Ignoring provided coordinates since `label_value` was provided.\")\nif label_pyramid_level == None:\nfor label_pyramid_level in reversed(self.pyramid_levels_labels[label_name]):\ncurr_array = self.get_array_by_coordinate(label_name=label_name, pyramid_level=label_pyramid_level,\nverbose=verbose)\nif da.isin(label_value, curr_array).compute():\nbreak\nupper_left_yx, lower_right_yx = self.get_bounding_box_for_label_value(\nlabel_name=label_name,\nlabel_value=label_value,\nlabel_pyramid_level=label_pyramid_level,\nextend_pixels=0,\nlabel_name_output=None,\npyramid_level_output=pyramid_level,\nverbose=verbose\n)\nupper_left_yx = upper_left_yx[-2:]\nlower_right_yx = lower_right_yx[-2:]\nsize_yx = None\ncoordinate_unit = 'pixel'\npyramid_level_coord = None\n# padding\nupper_left_yx = tuple([max(0, upper_left_yx[i] - extend_pixels) for i in range(2)])\nlower_right_yx = tuple([min(self.array_dict[pyramid_level].shape[-2:][i], lower_right_yx[i] + extend_pixels) for i in range(2)])\n# get image and label arrays\nscale_img_spatial = self.get_scale(\npyramid_level=pyramid_level,\nspatial_axes_only=True,\nverbose=verbose\n)\nif label_name == None:\nimg = self.get_array_by_coordinate(\nlabel_name=None,\nupper_left_yx=upper_left_yx,\nlower_right_yx=lower_right_yx,\nsize_yx=size_yx,\ncoordinate_unit=coordinate_unit,\npyramid_level=pyramid_level,\npyramid_level_coord=pyramid_level_coord,\nas_NumPy=True,\nverbose=verbose\n)\nlab = None\nelse:\nimg, lab = self.get_array_pair_by_coordinate(\nlabel_name=label_name,\nupper_left_yx=upper_left_yx,\nlower_right_yx=lower_right_yx,\nsize_yx=size_yx,\ncoordinate_unit=coordinate_unit,\npyramid_level=pyramid_level,\npyramid_level_coord=pyramid_level_coord,\nverbose=verbose\n)\nlab = lab[label_name] # extract label array from dict\n# if there is a time axis, select a single timepoint and \n# remove the time axis for plotting\ntime_dim = [i for i in range(len(self.channel_info_image)) if self.channel_info_image[i] == 't']\nif len(time_dim) == 1:\n# make sure that only one timepoint is selected\nassert type(time_index) is int\n# select a single timepoint and squeeze time axis\nindex = [slice(None)] * img.ndim\nindex[time_dim[0]] = time_index\nimg = img[tuple(index)]\n# same for label image\nif label_name != None:\ntime_dim_lab = [i for i in range(len(self.channel_info_labels[label_name])) if self.channel_info_labels[label_name][i] == 't']\n# if there is a channel axis in the label image and it has \n# length 1, we will collapse it too\nchannel_dim_lab = [i for i in range(len(self.channel_info_labels[label_name])) if self.channel_info_labels[label_name][i] == 'c']\nif len(time_dim_lab) == 1 or len(channel_dim_lab) == 1:\nindex = [slice(None)] * lab.ndim\nif len(time_dim_lab) == 1:\n# make sure that only one timepoint is selected\nassert type(time_index) is int\n# select a single timepoint and squeeze time axis\nindex[time_dim_lab[0]] = time_index\nif len(channel_dim_lab) == 1:\n# make sure that there is only one channel\nassert lab.shape[channel_dim_lab[0]] == 1\n# squeeze the channel dimension\nindex[channel_dim_lab[0]] = 0\nlab = lab[tuple(index)]\n# calculate scalebar length in pixel in x direction\nif scalebar_micrometer != 0:\nkwargs['scalebar_pixel'] = convert_coordinates(\ncoords_from = (scalebar_micrometer,),\nscale_from = [1.0],\nscale_to = [self.get_scale(pyramid_level=pyramid_level, label_name=None)[-1]])[0]\nelse:\nkwargs['scalebar_pixel'] = 0\n# plot image\nif show_scalebar_label:\nkwargs['scalebar_label'] = str(scalebar_micrometer) + ' \u00b5m'\nelse:\nkwargs['scalebar_label'] = None\nkwargs['im'] = img\nkwargs['msk'] = lab\nkwargs['spacing_yx'] = scale_img_spatial[-2:]\nkwargs['verbose'] = verbose\nplotting.plot_image(**kwargs)\n</code></pre>"},{"location":"ome_zarr/#src.ez_zarr.ome_zarr.Image.tree","title":"<code>tree(**kwargs)</code>","text":"<p>Print zarr tree using zarr.hierarchy.Group.tree().</p> Source code in <code>src/ez_zarr/ome_zarr.py</code> <pre><code>def tree(self, **kwargs: Any) -&gt; Any:\n\"\"\"Print zarr tree using zarr.hierarchy.Group.tree().\"\"\"\nreturn self.zarr_group.tree(**kwargs)\n</code></pre>"},{"location":"ome_zarr/#src.ez_zarr.ome_zarr.ImageList","title":"<code>ImageList</code>","text":"<p>Represents a list of OME-Zarr images.</p> Source code in <code>src/ez_zarr/ome_zarr.py</code> <pre><code>class ImageList:\n\"\"\"Represents a list of OME-Zarr images.\"\"\"\n# constructor and helper functions ----------------------------------------\ndef __init__(self, paths: list[str],\nnames: Optional[list[str]]=None,\nlayout: Optional[Union[pd.DataFrame, str]]=None,\nnrow: Optional[int]=None,\nncol: Optional[int]=None,\nby_row: bool=False,\nfallback_name_function: Callable[[int, int], str]=create_name_row_col) -&gt; None:\n\"\"\"\n        Initializes an OME-Zarr image list from a list of paths, each\n        containing a single zarr group, possibly with multiple resolution levels,\n        derived labels or tables, but no further groups.\n        If provided, the elements in `names` and/or the rows in `layout`\n        need to be parallel to the element in `paths`.\n        If `nrow` and/or `ncol` are provided without `layout`, the layout\n        is automatically generated using `ImageList.set_layout()`.\n        Parameters:\n            paths (list of str): Paths containing the OME-Zarr images.\n            names (list of str, optional): Optional names for the images. If\n                `None`, the names are generated automatically using\n                `fallback_name_function` (see below).\n            layout (Pandas DataFrame or str, optional): Controls the plot layout.\n                Either a data frame with at least the columns 'row_index' and\n                'column_index'. The values in the 'row_index' and\n                'column_index' are 1-based integers. Alternatively, a string\n                specifying the type of layout to generate automatically.\n                Currently supported layout types are 'grid'.\n            nrow (int, optional): Number of rows in the layout.\n            ncol (int, optional): Number of columns in the layout.\n            by_row (bool, optional): If `True` and `layout` is not a data frame,\n                the layout is generated by row instead of by column.\n            fallback_name_function (Callable[[int, int], str]): Function that takes\n                two integer parameters (the 1-based row and column index of an\n                image) and returns a string representing the name for the image.\n                Image names are for example used as titles in plots, and\n                are only generated automatically as a fallback, if `names` is\n                `None` or when plotting empty images for row/column indices\n                that are not present in `layout`. `ez_zarr.ome_zarr` defines\n                a few pre-defined functions that can be used, such as\n                `create_name_row_col` and `create_name_plate_A01`.\n        Returns:\n            An `ImageList` object.\n        Examples:\n            Get an object corresponding to an image.\n            &gt;&gt;&gt; from ez_zarr import ome_zarr\n            &gt;&gt;&gt; listA = ome_zarr.ImageList(['path/to/image1', 'path/to/image2'])\n        \"\"\"\nself.paths: list = paths\nself.n_images = len(paths)\nself.layout: pd.DataFrame = pd.DataFrame({})\nself.nrow: int = 0\nself.ncol: int = 0\nself.fallback_name_function: Callable[[int, int], str] = fallback_name_function\nself.set_layout(layout=layout, nrow=nrow, ncol=ncol, by_row=by_row)\nif names is None:\nnames = [self.fallback_name_function(ri, ci) for ri, ci in zip(self.layout['row_index'].to_list(), self.layout['column_index'].to_list())]\nself.names: list = names\n# check arguments\nassert len(self.names) == self.n_images, (\nf\"Number of paths ({self.n_images}) and names ({len(self.names)}) must be the same.\"\n)\nif self.layout is not None:\nassert self.layout.shape[0] == self.n_images, (\nf\"Number of paths ({self.n_images}) and layout rows ({self.layout.shape[0]}) must be the same.\"\n)\n# initialize image objects\nself.images = [Image(path=path, name=name) for path, name in zip(self.paths, self.names)]\n# length ------------------------------------------------------------------\ndef __len__(self) -&gt; int:\n\"\"\"Returns the number of images.\"\"\"\nreturn self.n_images\n# string representation ---------------------------------------------------\ndef __str__(self) -&gt; str:\npaths_compact = \", \".join(self.paths)\nif len(paths_compact) &gt; 80:\npaths_compact = paths_compact[:80] + \"...\"\nnames_compact = \", \".join(self.names)\nif len(names_compact) &gt; 80:\nnames_compact = names_compact[:80] + \"...\"\nreturn f\"ImageList of {self.n_images} images\\n  paths: {paths_compact}\\n  names: {names_compact}\\n\"\ndef __repr__(self) -&gt; str:\nreturn str(self)\n# subsetting --------------------------------------------------------------\ndef __getitem__(self, idx: Union[int, list[int], slice]) -&gt; Union[Image, 'ImageList']:\n\"\"\"Returns the image(s) at index `idx`.\"\"\"\nif isinstance(idx, int):\nreturn self.images[idx]\nelif isinstance(idx, str):\nif len(set(self.names)) &lt; self.n_images:\nraise ValueError(f\"Image names are not unique - cannot subset by name.\")\nreturn self.images[self.names.index(idx)]\nelif isinstance(idx, list) or isinstance(idx, slice):\nif all(isinstance(element, str) for element in idx):\nif len(set(self.names)) &lt; self.n_images:\nraise ValueError(f\"Image names are not unique - cannot subset by names.\")\nreturn self[[self.names.index(nm) for nm in idx]]\nelse:\nif self.layout is not None:\nlayout_sub = self.layout.iloc[idx]\nelse:\nlayout_sub = None\nreturn ImageList(paths=[self.paths[i] for i in idx],\nnames=[self.names[i] for i in idx],\nlayout=layout_sub)\n# call Image attributes ---------------------------------------------------\ndef __getattr__(self, name):\n# remark: could catch \"forbidden\" attributes here\ntry:\nattr = getattr(self.images[0], name)\nexcept AttributeError:\nraise AttributeError(f\"'{type(self.images[0]).__name__}' objects have no attribute '{name}'\")\nif callable(attr):\ndef wrapper(*args, **kwargs):\nreturn [getattr(img, name)(*args, **kwargs) for img in self.images]\nreturn wrapper\nelse:\nreturn [getattr(img, name) for img in self.images]\n# accessors ---------------------------------------------------------------\ndef get_paths(self) -&gt; list[str]:\n\"\"\"Returns the paths of the images.\"\"\"\nreturn self.paths\ndef get_names(self) -&gt; list[str]:\n\"\"\"Returns the names of the images.\"\"\"\nreturn self.names\ndef get_layout(self) -&gt; Optional[pd.DataFrame]:\n\"\"\"Returns the layout of the images.\"\"\"\nreturn self.layout\n# setting the layout ------------------------------------------------------\n@staticmethod\ndef _create_layout_dataframe(nrow: int, ncol: int,\nn: int, by_row: bool) -&gt; pd.DataFrame:\nif by_row:\nri = list(np.repeat(np.arange(nrow) + 1, ncol))[:n]\nci = (list(np.arange(ncol) + 1) * nrow)[:n]\nelse:\nri = (list(np.arange(nrow) + 1) * ncol)[:n]\nci = list(np.repeat(np.arange(ncol) + 1, nrow))[:n]\nlayout = pd.DataFrame({'row_index': ri,\n'column_index': ci})\nreturn layout\ndef set_layout(self,\nlayout: Optional[Union[pd.DataFrame, str]]=None,\nnrow: Optional[int]=None,\nncol: Optional[int]=None,\nby_row: bool=False,\nreset_names: bool=False) -&gt; None:\n\"\"\"Sets the `layout`, `nrow` and `ncol` properties of the `ImageList` object.\"\"\"\n# set self.layout\nif isinstance(layout, pd.DataFrame):\nif layout.shape[0] != self.n_images:\nraise ValueError(f\"Number of layout rows ({layout.shape[0]}) must be the same as the number of images ({self.n_images}).\")\nself.layout = layout.copy()\nelif isinstance(layout, str):\nif nrow is not None or ncol is not None:\nwarnings.warn(\"Ignoring `nrow` and `ncol` when layout is provided as a string.\")\nif layout == 'grid':\nnrow = int(np.ceil(np.sqrt(self.n_images)))\nncol = int(np.ceil(self.n_images / nrow))\nself.layout = self._create_layout_dataframe(nrow=nrow, ncol=ncol, n=self.n_images, by_row=by_row)\nelse:\nraise ValueError(f\"Layout provided as a string must be one of 'grid'.\")\nelif layout is None:\nif ncol is None:\nif nrow is None:\nnrow = int(np.ceil(np.sqrt(self.n_images)))\nncol = int(np.ceil(self.n_images / nrow))\nif nrow is None:\nnrow = int(np.ceil(self.n_images / ncol))\nself.layout = self._create_layout_dataframe(nrow=nrow, ncol=ncol, n=self.n_images, by_row=by_row)\n# set self.nrow and self.ncol\nself.nrow = np.max(self.layout['row_index'].to_numpy()) if nrow is None else nrow\nself.ncol = np.max(self.layout['column_index'].to_numpy()) if ncol is None else ncol\n# set self.names\nif reset_names:\nself.names = [self.fallback_name_function(ri, ci) for ri, ci in zip(self.layout['row_index'].to_list(), self.layout['column_index'].to_list())]\n# plotting ----------------------------------------------------------------\ndef plot(self,\nfig_title: Optional[str]=None,\nfig_width_inch: Optional[float]=None,\nfig_height_inch: Optional[float]=None,\nfig_dpi: int=200,\nfig_style: str='dark_background',\nverbose: bool=False,\n**kwargs: Any) -&gt; None:\n\"\"\"\n        Plot the images in the `ImageList`.\n        The overall layout and the location of individual images are\n        defined by `layout`, `nrow` and `ncol` properties. The plotting of\n        individual images is can be controlled using `kwargs` and is\n        performed using `Image.plot()`.\n        Parameters:\n            fig_title (str, optional): String scalar to use as overall figure title\n                (default: do not add any title).\n            fig_width_inch (float, optional): Figure width (in inches). If `None`,\n                the number of rows multiplied by 2.0 will be used.\n            fig_height_inch (float, optional): Figure height (in inches). If `None`,\n                the number of columns multiplied by 2.0 will be used.\n            fig_dpi (int): Figure resolution (dots per inch).\n            fig_style (str): Style for the figure. Supported are 'brightfield', which\n                is a special mode for single-channel brightfield microscopic images\n                (it will automatically set `channels=[0]`, `channel_colors=['white']`\n                `z_projection_method='minimum'` and `fig_style='default'`), and any\n                other styles that can be passed to `matplotlib.pyplot.style.context`\n                (default: 'dark_background')\n            verbose (bool): Whether to print out information messages.\n            **kwargs: Additional arguments for `Image.plot_image`, for example\n                'label_name', 'pyramid_level', 'scalebar_micrometer', 'show_scalebar_label',\n                'channels', 'channel_colors', 'channel_ranges', 'z_projection_method',\n                'show_label_values', 'label_text_colour', 'label_fontsize', etc.\n                For a full list of available arguments, see\n                [ome_zarr.Image.plot documentation](ome_zarr.md#src.ez_zarr.ome_zarr.Image.plot)\n                and the underlying\n                [plotting.plot_image documentation](plotting.md#src.ez_zarr.plotting.plot_image).\n        Examples:\n            Plot the intensity images in the `ImageList` `imgL`.\n            &gt;&gt;&gt; imgL.plot()\n        \"\"\"\n# digest arguments\nfig_width_inch = fig_width_inch if fig_width_inch is not None else self.ncol * 2.0\nfig_height_inch = fig_height_inch if fig_height_inch is not None else self.nrow * 2.0\n# import optional modules\nplt = importlib.import_module('matplotlib.pyplot')\n# get the maximal image y,x coordinates\nchannel_info = [img.channel_info_image for img in self.images]\nassert all([channel_info[0] == ci for ci in channel_info]), f\"Not all images have the same channel info: {', '.join(channel_info)}\"\nspatial_dims = [i for i in range(len(channel_info[0])) if channel_info[0][i] in ['y', 'x']]\nimg_dims = [img.get_array_by_coordinate(verbose=verbose).shape for img in self.images]\nimg_dims_spatial = [[d[i] for i in spatial_dims] for d in img_dims]\nmax_yx = np.max(np.stack(img_dims_spatial), axis=0)\nkwargs['pad_to_yx'] = max_yx\n# adjust parameters for brightfield images\nif fig_style == 'brightfield':\nif verbose:\nprint(\"Adjusting parameters for brightfield image\")\nkwargs['channels'] = [0]\nkwargs['channel_colors'] = ['white']\nkwargs['z_projection_method'] = 'minimum'\nkwargs['pad_value'] = 1\nfig_style = 'default'\nempty_well = np.ones(max_yx)\nelse:\nkwargs['pad_value'] = 0\nempty_well = np.zeros(max_yx)\n# create figure\nwith plt.style.context(fig_style):\nfig = plt.figure(figsize=(fig_width_inch, fig_height_inch))\nfig.set_dpi(fig_dpi)\nif fig_title is not None:\nfig.suptitle(fig_title, size='xx-large') # default title size: 'large'\n# loop over images\nkwargs['call_show'] = False # don't create new figures for each image\nfor ri in range(self.nrow):\nfor ci in range(self.ncol):\nplt.subplot(self.nrow, self.ncol, ri * self.ncol + ci + 1)\n# check if we have an image for this row and column\ncondition = (self.layout['row_index'] == ri + 1) &amp; (self.layout['column_index'] == ci + 1)\nn_matching = np.sum(condition.to_numpy())\nif n_matching &gt; 1:\n# more than one image\nraise Exception(f\"More than one image at row {ri + 1}, column {ci + 1}\")\nelif n_matching == 1:\n# exactly one image, plot it\ni = self.layout[condition].index.to_list()[0]\nkwargs['title'] = self.names[i]\nself.images[i].plot(**kwargs)\nelse:\n# plot empty well\nplt.imshow(empty_well, cmap='gray', vmin=0, vmax=1)\nif 'axis_style' in kwargs and kwargs['axis_style'] != 'none':\nplt.xticks([]) # remove axis ticks\nplt.yticks([])\nelse:\nplt.axis('off')\nplt.title(self.fallback_name_function(ri + 1, ci + 1))\nfig.tight_layout()\nplt.show()\nplt.close()\n</code></pre>"},{"location":"ome_zarr/#src.ez_zarr.ome_zarr.ImageList.__getitem__","title":"<code>__getitem__(idx)</code>","text":"<p>Returns the image(s) at index <code>idx</code>.</p> Source code in <code>src/ez_zarr/ome_zarr.py</code> <pre><code>def __getitem__(self, idx: Union[int, list[int], slice]) -&gt; Union[Image, 'ImageList']:\n\"\"\"Returns the image(s) at index `idx`.\"\"\"\nif isinstance(idx, int):\nreturn self.images[idx]\nelif isinstance(idx, str):\nif len(set(self.names)) &lt; self.n_images:\nraise ValueError(f\"Image names are not unique - cannot subset by name.\")\nreturn self.images[self.names.index(idx)]\nelif isinstance(idx, list) or isinstance(idx, slice):\nif all(isinstance(element, str) for element in idx):\nif len(set(self.names)) &lt; self.n_images:\nraise ValueError(f\"Image names are not unique - cannot subset by names.\")\nreturn self[[self.names.index(nm) for nm in idx]]\nelse:\nif self.layout is not None:\nlayout_sub = self.layout.iloc[idx]\nelse:\nlayout_sub = None\nreturn ImageList(paths=[self.paths[i] for i in idx],\nnames=[self.names[i] for i in idx],\nlayout=layout_sub)\n</code></pre>"},{"location":"ome_zarr/#src.ez_zarr.ome_zarr.ImageList.__init__","title":"<code>__init__(paths, names=None, layout=None, nrow=None, ncol=None, by_row=False, fallback_name_function=create_name_row_col)</code>","text":"<p>Initializes an OME-Zarr image list from a list of paths, each containing a single zarr group, possibly with multiple resolution levels, derived labels or tables, but no further groups.</p> <p>If provided, the elements in <code>names</code> and/or the rows in <code>layout</code> need to be parallel to the element in <code>paths</code>.</p> <p>If <code>nrow</code> and/or <code>ncol</code> are provided without <code>layout</code>, the layout is automatically generated using <code>ImageList.set_layout()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>list of str</code> <p>Paths containing the OME-Zarr images.</p> required <code>names</code> <code>list of str</code> <p>Optional names for the images. If <code>None</code>, the names are generated automatically using <code>fallback_name_function</code> (see below).</p> <code>None</code> <code>layout</code> <code>Pandas DataFrame or str</code> <p>Controls the plot layout. Either a data frame with at least the columns 'row_index' and 'column_index'. The values in the 'row_index' and 'column_index' are 1-based integers. Alternatively, a string specifying the type of layout to generate automatically. Currently supported layout types are 'grid'.</p> <code>None</code> <code>nrow</code> <code>int</code> <p>Number of rows in the layout.</p> <code>None</code> <code>ncol</code> <code>int</code> <p>Number of columns in the layout.</p> <code>None</code> <code>by_row</code> <code>bool</code> <p>If <code>True</code> and <code>layout</code> is not a data frame, the layout is generated by row instead of by column.</p> <code>False</code> <code>fallback_name_function</code> <code>Callable[[int, int], str]</code> <p>Function that takes two integer parameters (the 1-based row and column index of an image) and returns a string representing the name for the image. Image names are for example used as titles in plots, and are only generated automatically as a fallback, if <code>names</code> is <code>None</code> or when plotting empty images for row/column indices that are not present in <code>layout</code>. <code>ez_zarr.ome_zarr</code> defines a few pre-defined functions that can be used, such as <code>create_name_row_col</code> and <code>create_name_plate_A01</code>.</p> <code>create_name_row_col</code> <p>Returns:</p> Type Description <code>None</code> <p>An <code>ImageList</code> object.</p> <p>Examples:</p> <p>Get an object corresponding to an image.</p> <pre><code>&gt;&gt;&gt; from ez_zarr import ome_zarr\n&gt;&gt;&gt; listA = ome_zarr.ImageList(['path/to/image1', 'path/to/image2'])\n</code></pre> Source code in <code>src/ez_zarr/ome_zarr.py</code> <pre><code>def __init__(self, paths: list[str],\nnames: Optional[list[str]]=None,\nlayout: Optional[Union[pd.DataFrame, str]]=None,\nnrow: Optional[int]=None,\nncol: Optional[int]=None,\nby_row: bool=False,\nfallback_name_function: Callable[[int, int], str]=create_name_row_col) -&gt; None:\n\"\"\"\n    Initializes an OME-Zarr image list from a list of paths, each\n    containing a single zarr group, possibly with multiple resolution levels,\n    derived labels or tables, but no further groups.\n    If provided, the elements in `names` and/or the rows in `layout`\n    need to be parallel to the element in `paths`.\n    If `nrow` and/or `ncol` are provided without `layout`, the layout\n    is automatically generated using `ImageList.set_layout()`.\n    Parameters:\n        paths (list of str): Paths containing the OME-Zarr images.\n        names (list of str, optional): Optional names for the images. If\n            `None`, the names are generated automatically using\n            `fallback_name_function` (see below).\n        layout (Pandas DataFrame or str, optional): Controls the plot layout.\n            Either a data frame with at least the columns 'row_index' and\n            'column_index'. The values in the 'row_index' and\n            'column_index' are 1-based integers. Alternatively, a string\n            specifying the type of layout to generate automatically.\n            Currently supported layout types are 'grid'.\n        nrow (int, optional): Number of rows in the layout.\n        ncol (int, optional): Number of columns in the layout.\n        by_row (bool, optional): If `True` and `layout` is not a data frame,\n            the layout is generated by row instead of by column.\n        fallback_name_function (Callable[[int, int], str]): Function that takes\n            two integer parameters (the 1-based row and column index of an\n            image) and returns a string representing the name for the image.\n            Image names are for example used as titles in plots, and\n            are only generated automatically as a fallback, if `names` is\n            `None` or when plotting empty images for row/column indices\n            that are not present in `layout`. `ez_zarr.ome_zarr` defines\n            a few pre-defined functions that can be used, such as\n            `create_name_row_col` and `create_name_plate_A01`.\n    Returns:\n        An `ImageList` object.\n    Examples:\n        Get an object corresponding to an image.\n        &gt;&gt;&gt; from ez_zarr import ome_zarr\n        &gt;&gt;&gt; listA = ome_zarr.ImageList(['path/to/image1', 'path/to/image2'])\n    \"\"\"\nself.paths: list = paths\nself.n_images = len(paths)\nself.layout: pd.DataFrame = pd.DataFrame({})\nself.nrow: int = 0\nself.ncol: int = 0\nself.fallback_name_function: Callable[[int, int], str] = fallback_name_function\nself.set_layout(layout=layout, nrow=nrow, ncol=ncol, by_row=by_row)\nif names is None:\nnames = [self.fallback_name_function(ri, ci) for ri, ci in zip(self.layout['row_index'].to_list(), self.layout['column_index'].to_list())]\nself.names: list = names\n# check arguments\nassert len(self.names) == self.n_images, (\nf\"Number of paths ({self.n_images}) and names ({len(self.names)}) must be the same.\"\n)\nif self.layout is not None:\nassert self.layout.shape[0] == self.n_images, (\nf\"Number of paths ({self.n_images}) and layout rows ({self.layout.shape[0]}) must be the same.\"\n)\n# initialize image objects\nself.images = [Image(path=path, name=name) for path, name in zip(self.paths, self.names)]\n</code></pre>"},{"location":"ome_zarr/#src.ez_zarr.ome_zarr.ImageList.__len__","title":"<code>__len__()</code>","text":"<p>Returns the number of images.</p> Source code in <code>src/ez_zarr/ome_zarr.py</code> <pre><code>def __len__(self) -&gt; int:\n\"\"\"Returns the number of images.\"\"\"\nreturn self.n_images\n</code></pre>"},{"location":"ome_zarr/#src.ez_zarr.ome_zarr.ImageList.get_layout","title":"<code>get_layout()</code>","text":"<p>Returns the layout of the images.</p> Source code in <code>src/ez_zarr/ome_zarr.py</code> <pre><code>def get_layout(self) -&gt; Optional[pd.DataFrame]:\n\"\"\"Returns the layout of the images.\"\"\"\nreturn self.layout\n</code></pre>"},{"location":"ome_zarr/#src.ez_zarr.ome_zarr.ImageList.get_names","title":"<code>get_names()</code>","text":"<p>Returns the names of the images.</p> Source code in <code>src/ez_zarr/ome_zarr.py</code> <pre><code>def get_names(self) -&gt; list[str]:\n\"\"\"Returns the names of the images.\"\"\"\nreturn self.names\n</code></pre>"},{"location":"ome_zarr/#src.ez_zarr.ome_zarr.ImageList.get_paths","title":"<code>get_paths()</code>","text":"<p>Returns the paths of the images.</p> Source code in <code>src/ez_zarr/ome_zarr.py</code> <pre><code>def get_paths(self) -&gt; list[str]:\n\"\"\"Returns the paths of the images.\"\"\"\nreturn self.paths\n</code></pre>"},{"location":"ome_zarr/#src.ez_zarr.ome_zarr.ImageList.plot","title":"<code>plot(fig_title=None, fig_width_inch=None, fig_height_inch=None, fig_dpi=200, fig_style='dark_background', verbose=False, **kwargs)</code>","text":"<p>Plot the images in the <code>ImageList</code>.</p> <p>The overall layout and the location of individual images are defined by <code>layout</code>, <code>nrow</code> and <code>ncol</code> properties. The plotting of individual images is can be controlled using <code>kwargs</code> and is performed using <code>Image.plot()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>fig_title</code> <code>str</code> <p>String scalar to use as overall figure title (default: do not add any title).</p> <code>None</code> <code>fig_width_inch</code> <code>float</code> <p>Figure width (in inches). If <code>None</code>, the number of rows multiplied by 2.0 will be used.</p> <code>None</code> <code>fig_height_inch</code> <code>float</code> <p>Figure height (in inches). If <code>None</code>, the number of columns multiplied by 2.0 will be used.</p> <code>None</code> <code>fig_dpi</code> <code>int</code> <p>Figure resolution (dots per inch).</p> <code>200</code> <code>fig_style</code> <code>str</code> <p>Style for the figure. Supported are 'brightfield', which is a special mode for single-channel brightfield microscopic images (it will automatically set <code>channels=[0]</code>, <code>channel_colors=['white']</code> <code>z_projection_method='minimum'</code> and <code>fig_style='default'</code>), and any other styles that can be passed to <code>matplotlib.pyplot.style.context</code> (default: 'dark_background')</p> <code>'dark_background'</code> <code>verbose</code> <code>bool</code> <p>Whether to print out information messages.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments for <code>Image.plot_image</code>, for example 'label_name', 'pyramid_level', 'scalebar_micrometer', 'show_scalebar_label', 'channels', 'channel_colors', 'channel_ranges', 'z_projection_method', 'show_label_values', 'label_text_colour', 'label_fontsize', etc. For a full list of available arguments, see ome_zarr.Image.plot documentation and the underlying plotting.plot_image documentation.</p> <code>{}</code> <p>Examples:</p> <p>Plot the intensity images in the <code>ImageList</code> <code>imgL</code>.</p> <pre><code>&gt;&gt;&gt; imgL.plot()\n</code></pre> Source code in <code>src/ez_zarr/ome_zarr.py</code> <pre><code>def plot(self,\nfig_title: Optional[str]=None,\nfig_width_inch: Optional[float]=None,\nfig_height_inch: Optional[float]=None,\nfig_dpi: int=200,\nfig_style: str='dark_background',\nverbose: bool=False,\n**kwargs: Any) -&gt; None:\n\"\"\"\n    Plot the images in the `ImageList`.\n    The overall layout and the location of individual images are\n    defined by `layout`, `nrow` and `ncol` properties. The plotting of\n    individual images is can be controlled using `kwargs` and is\n    performed using `Image.plot()`.\n    Parameters:\n        fig_title (str, optional): String scalar to use as overall figure title\n            (default: do not add any title).\n        fig_width_inch (float, optional): Figure width (in inches). If `None`,\n            the number of rows multiplied by 2.0 will be used.\n        fig_height_inch (float, optional): Figure height (in inches). If `None`,\n            the number of columns multiplied by 2.0 will be used.\n        fig_dpi (int): Figure resolution (dots per inch).\n        fig_style (str): Style for the figure. Supported are 'brightfield', which\n            is a special mode for single-channel brightfield microscopic images\n            (it will automatically set `channels=[0]`, `channel_colors=['white']`\n            `z_projection_method='minimum'` and `fig_style='default'`), and any\n            other styles that can be passed to `matplotlib.pyplot.style.context`\n            (default: 'dark_background')\n        verbose (bool): Whether to print out information messages.\n        **kwargs: Additional arguments for `Image.plot_image`, for example\n            'label_name', 'pyramid_level', 'scalebar_micrometer', 'show_scalebar_label',\n            'channels', 'channel_colors', 'channel_ranges', 'z_projection_method',\n            'show_label_values', 'label_text_colour', 'label_fontsize', etc.\n            For a full list of available arguments, see\n            [ome_zarr.Image.plot documentation](ome_zarr.md#src.ez_zarr.ome_zarr.Image.plot)\n            and the underlying\n            [plotting.plot_image documentation](plotting.md#src.ez_zarr.plotting.plot_image).\n    Examples:\n        Plot the intensity images in the `ImageList` `imgL`.\n        &gt;&gt;&gt; imgL.plot()\n    \"\"\"\n# digest arguments\nfig_width_inch = fig_width_inch if fig_width_inch is not None else self.ncol * 2.0\nfig_height_inch = fig_height_inch if fig_height_inch is not None else self.nrow * 2.0\n# import optional modules\nplt = importlib.import_module('matplotlib.pyplot')\n# get the maximal image y,x coordinates\nchannel_info = [img.channel_info_image for img in self.images]\nassert all([channel_info[0] == ci for ci in channel_info]), f\"Not all images have the same channel info: {', '.join(channel_info)}\"\nspatial_dims = [i for i in range(len(channel_info[0])) if channel_info[0][i] in ['y', 'x']]\nimg_dims = [img.get_array_by_coordinate(verbose=verbose).shape for img in self.images]\nimg_dims_spatial = [[d[i] for i in spatial_dims] for d in img_dims]\nmax_yx = np.max(np.stack(img_dims_spatial), axis=0)\nkwargs['pad_to_yx'] = max_yx\n# adjust parameters for brightfield images\nif fig_style == 'brightfield':\nif verbose:\nprint(\"Adjusting parameters for brightfield image\")\nkwargs['channels'] = [0]\nkwargs['channel_colors'] = ['white']\nkwargs['z_projection_method'] = 'minimum'\nkwargs['pad_value'] = 1\nfig_style = 'default'\nempty_well = np.ones(max_yx)\nelse:\nkwargs['pad_value'] = 0\nempty_well = np.zeros(max_yx)\n# create figure\nwith plt.style.context(fig_style):\nfig = plt.figure(figsize=(fig_width_inch, fig_height_inch))\nfig.set_dpi(fig_dpi)\nif fig_title is not None:\nfig.suptitle(fig_title, size='xx-large') # default title size: 'large'\n# loop over images\nkwargs['call_show'] = False # don't create new figures for each image\nfor ri in range(self.nrow):\nfor ci in range(self.ncol):\nplt.subplot(self.nrow, self.ncol, ri * self.ncol + ci + 1)\n# check if we have an image for this row and column\ncondition = (self.layout['row_index'] == ri + 1) &amp; (self.layout['column_index'] == ci + 1)\nn_matching = np.sum(condition.to_numpy())\nif n_matching &gt; 1:\n# more than one image\nraise Exception(f\"More than one image at row {ri + 1}, column {ci + 1}\")\nelif n_matching == 1:\n# exactly one image, plot it\ni = self.layout[condition].index.to_list()[0]\nkwargs['title'] = self.names[i]\nself.images[i].plot(**kwargs)\nelse:\n# plot empty well\nplt.imshow(empty_well, cmap='gray', vmin=0, vmax=1)\nif 'axis_style' in kwargs and kwargs['axis_style'] != 'none':\nplt.xticks([]) # remove axis ticks\nplt.yticks([])\nelse:\nplt.axis('off')\nplt.title(self.fallback_name_function(ri + 1, ci + 1))\nfig.tight_layout()\nplt.show()\nplt.close()\n</code></pre>"},{"location":"ome_zarr/#src.ez_zarr.ome_zarr.ImageList.set_layout","title":"<code>set_layout(layout=None, nrow=None, ncol=None, by_row=False, reset_names=False)</code>","text":"<p>Sets the <code>layout</code>, <code>nrow</code> and <code>ncol</code> properties of the <code>ImageList</code> object.</p> Source code in <code>src/ez_zarr/ome_zarr.py</code> <pre><code>def set_layout(self,\nlayout: Optional[Union[pd.DataFrame, str]]=None,\nnrow: Optional[int]=None,\nncol: Optional[int]=None,\nby_row: bool=False,\nreset_names: bool=False) -&gt; None:\n\"\"\"Sets the `layout`, `nrow` and `ncol` properties of the `ImageList` object.\"\"\"\n# set self.layout\nif isinstance(layout, pd.DataFrame):\nif layout.shape[0] != self.n_images:\nraise ValueError(f\"Number of layout rows ({layout.shape[0]}) must be the same as the number of images ({self.n_images}).\")\nself.layout = layout.copy()\nelif isinstance(layout, str):\nif nrow is not None or ncol is not None:\nwarnings.warn(\"Ignoring `nrow` and `ncol` when layout is provided as a string.\")\nif layout == 'grid':\nnrow = int(np.ceil(np.sqrt(self.n_images)))\nncol = int(np.ceil(self.n_images / nrow))\nself.layout = self._create_layout_dataframe(nrow=nrow, ncol=ncol, n=self.n_images, by_row=by_row)\nelse:\nraise ValueError(f\"Layout provided as a string must be one of 'grid'.\")\nelif layout is None:\nif ncol is None:\nif nrow is None:\nnrow = int(np.ceil(np.sqrt(self.n_images)))\nncol = int(np.ceil(self.n_images / nrow))\nif nrow is None:\nnrow = int(np.ceil(self.n_images / ncol))\nself.layout = self._create_layout_dataframe(nrow=nrow, ncol=ncol, n=self.n_images, by_row=by_row)\n# set self.nrow and self.ncol\nself.nrow = np.max(self.layout['row_index'].to_numpy()) if nrow is None else nrow\nself.ncol = np.max(self.layout['column_index'].to_numpy()) if ncol is None else ncol\n# set self.names\nif reset_names:\nself.names = [self.fallback_name_function(ri, ci) for ri, ci in zip(self.layout['row_index'].to_list(), self.layout['column_index'].to_list())]\n</code></pre>"},{"location":"ome_zarr/#src.ez_zarr.ome_zarr.create_name_plate_A01","title":"<code>create_name_plate_A01(ri, ci)</code>","text":"<p>Create name corresponding the wells in a microwell plate.</p> <p>Parameters:</p> Name Type Description Default <code>ri</code> <code>int</code> <p>Row index (1-based)</p> required <code>ci</code> <code>int</code> <p>Column index (1-based)</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Name (<code>ci</code> always using two digits, with pre-fixed zeros)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; create_name_plate_A01(3, 4)\n'C04'\n</code></pre> Source code in <code>src/ez_zarr/ome_zarr.py</code> <pre><code>def create_name_plate_A01(ri: int, ci: int) -&gt; str:\n\"\"\"\n    Create name corresponding the wells in a microwell plate.\n    Parameters:\n        ri (int): Row index (1-based)\n        ci (int): Column index (1-based)\n    Returns:\n        str: Name (`ci` always using two digits, with pre-fixed zeros)\n    Examples:\n        &gt;&gt;&gt; create_name_plate_A01(3, 4)\n        'C04'\n    \"\"\"\nreturn f\"{chr(ord('A') + ri - 1)}{ci:02}\"\n</code></pre>"},{"location":"ome_zarr/#src.ez_zarr.ome_zarr.create_name_row_col","title":"<code>create_name_row_col(ri, ci)</code>","text":"<p>Create name by pasting row and column indices, separated by '_'.</p> <p>Parameters:</p> Name Type Description Default <code>ri</code> <code>int</code> <p>Row index (1-based)</p> required <code>ci</code> <code>int</code> <p>Column index (1-based)</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Name constructed as f\"{ri}_{ci}\"</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; create_name_row_col(1, 2)\n'1_2'\n</code></pre> Source code in <code>src/ez_zarr/ome_zarr.py</code> <pre><code>def create_name_row_col(ri: int, ci: int) -&gt; str:\n\"\"\"\n    Create name by pasting row and column indices, separated by '_'.\n    Parameters:\n        ri (int): Row index (1-based)\n        ci (int): Column index (1-based)\n    Returns:\n        str: Name constructed as f\"{ri}_{ci}\"\n    Examples:\n        &gt;&gt;&gt; create_name_row_col(1, 2)\n        '1_2'\n    \"\"\"\nreturn f\"{ri}_{ci}\"\n</code></pre>"},{"location":"ome_zarr/#src.ez_zarr.ome_zarr.import_plate","title":"<code>import_plate(path, image_name='0', verbose=False)</code>","text":"<p>Create an ImageList object from a OME-Zarr image set corresponding to a plate.</p> Description <p>The image set is assumed to correspond to images corresponding to the wells of a microwell plate, and the folder names below <code>path</code> are expected to correspond to plate rows and columns, respectively (example the image in 'path/B/03/0' corresponds to well 'B03'). Row and column names are read from the plate metadata (https://ngff.openmicroscopy.org/latest/index.html#plate-md).</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to a folder containing the well images.</p> required <code>image_name</code> <code>str</code> <p>The name of the image to read for each well. </p> <code>'0'</code> <code>verbose</code> <code>bool</code> <p>Whether to print out information messages.</p> <code>False</code> <p>Returns:</p> Type Description <code>ImageList</code> <p>ImageList object</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; imgL = import_plate('path/to/images')\n&gt;&gt;&gt; imgL\nImageList of 2 images\npaths: path/to/images/B/03/0, path/to/images/C/03/0\nnames: B03, C03\n</code></pre> Source code in <code>src/ez_zarr/ome_zarr.py</code> <pre><code>def import_plate(path: str, image_name: str = '0',\nverbose: bool = False) -&gt; \"ImageList\":\n\"\"\"\n    Create an ImageList object from a OME-Zarr image set corresponding\n    to a plate.\n    Description:\n        The image set is assumed to correspond to images corresponding to\n        the wells of a microwell plate, and the folder names below `path`\n        are expected to correspond to plate rows and columns, respectively\n        (example the image in 'path/B/03/0' corresponds to well 'B03').\n        Row and column names are read from the plate metadata\n        (https://ngff.openmicroscopy.org/latest/index.html#plate-md).\n    Parameters:\n        path (str): Path to a folder containing the well images.\n        image_name (str): The name of the image to read for each well. \n        verbose (bool): Whether to print out information messages.\n    Returns:\n        ImageList object\n    Examples:\n        &gt;&gt;&gt; imgL = import_plate('path/to/images')\n        &gt;&gt;&gt; imgL\n        ImageList of 2 images\n        paths: path/to/images/B/03/0, path/to/images/C/03/0\n        names: B03, C03\n    \"\"\"\n# check arguments\nassert isinstance(path, str), f\"path ({path}) must be a string.\"\nassert os.path.isdir(path), f\"Path {path} does not exist.\"\nassert isinstance(image_name, str), f\"image_name ({image_name}) must be a string.\"\n# list image paths from metadata\nimg_paths = []\nrow_index = []\ncolumn_index = []\nwell_names = []\nplate_zarr = zarr.open(store = path, mode='r')\nplate_metadata = plate_zarr.attrs.asdict()['plate']\nfor well in plate_metadata['wells']:\nimg_path = os.path.join(path, well['path'], image_name)\nif os.path.isdir(img_path):\nimg_paths.append(img_path)\nrow_name = plate_metadata['rows'][well['rowIndex']]['name']\ncolumn_name = plate_metadata['columns'][well['columnIndex']]['name']\nwell_names.append(row_name + column_name)\nrow_index.append(ord(row_name) - ord('A') + 1)\ncolumn_index.append(int(column_name))\nelse:\nwarnings.warn(f\"Image path {img_path} does not exist.\")\nif len(img_paths) == 0:\nraise Exception(f\"No images found in {path}.\")\n# build layout\nlayout = pd.DataFrame({'row_index': row_index,\n'column_index': column_index,\n'img_paths': img_paths,\n'well_names': well_names})\nlayout = layout.sort_values(by=['row_index', 'column_index']).reset_index(drop=True)\nimg_paths = layout.img_paths.tolist()\nwell_names = layout.well_names.tolist()\nlayout = layout.drop(['img_paths', 'well_names'], axis='columns')\n# set nrow, ncol\nknown_plate_dims = [(2, 3), (4, 6), (8, 12), (16, 24)]\nmx_row = max(layout['row_index'])\nmx_column = max(layout['column_index'])\nnrow, ncol = known_plate_dims[min([i for i in range(len(known_plate_dims)) if known_plate_dims[i][0] &gt;= mx_row and known_plate_dims[i][1] &gt;= mx_column])]\nif verbose:\nprint(f\"Identified plate format: {nrow} x {ncol}\")\n# create ImageList object\nimgL = ImageList(paths = img_paths, names = well_names,\nlayout=layout, nrow=nrow, ncol=ncol,\nfallback_name_function=create_name_plate_A01)\n# return\nreturn imgL\n</code></pre>"},{"location":"plotting/","title":"Helpful functions for plotting and working with image arrays","text":"<p>Helpful functions for plotting and working with image arrays.</p>"},{"location":"plotting/#src.ez_zarr.plotting.convert_to_rgb","title":"<code>convert_to_rgb(im, channel_colors=['white'], channel_ranges=[[0.01, 0.99]], verbose=False)</code>","text":"<p>Convert a (channels, y, x) array to an RGB array of shape (y, x, 3).</p> <p>This function will return a copy of <code>im</code> in order not to affect the input.</p> <p>Parameters:</p> Name Type Description Default <code>im</code> <code>array or ndarray</code> <p>Input image of shape (channels, y, x).</p> required <code>channel_colors</code> <code>list[str]</code> <p>A list with python color strings (e.g. 'red') corresponding with the color for each channel in <code>im</code>.</p> <code>['white']</code> <code>channel_ranges</code> <code>list[list[float]]</code> <p>A list of 2-element lists (e.g. [0.01, 0.99]) giving the value ranges that should be mapped to colors for each channel. If the given numerical values are less or equal to 1.0, they are interpreted as quantiles and the corresponding intensity values are calculated on the channel non-zero values, otherwise they are directly used as intensities. Values outside of this range will be clipped.</p> <code>[[0.01, 0.99]]</code> <code>verbose</code> <code>bool</code> <p>Whether to print out information messages.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>An RGB image of shape (y, x, 3), where the third axis corresponds to red, green and blue channels. The image is suitable for plotting with <code>matplotlib.pyplot.imshow</code> and oriented such that it results in the same orentiation as when directly plotting a single channel.</p> <p>Examples:</p> <p>Convert an image <code>img</code> from (2, y, x) to (y, x, 3), using the channels as yellow and blue intensities:</p> <pre><code>&gt;&gt;&gt; img_rgb = convert_to_rgb(img, ['yellow', 'blue'])\n</code></pre> Source code in <code>src/ez_zarr/plotting.py</code> <pre><code>def convert_to_rgb(im: Union[dask.array.Array, np.ndarray],\nchannel_colors: list[str]=['white'],\nchannel_ranges: list[list[float]]=[[0.01, 0.99]],\nverbose: bool=False) -&gt; np.ndarray:\n\"\"\"\n    Convert a (channels, y, x) array to an RGB array of shape (y, x, 3).\n    This function will return a copy of `im` in order not to affect the input.\n    Parameters:\n        im (dask.array or numpy.ndarray): Input image of shape (channels, y, x).\n        channel_colors (list[str]): A list with python color strings (e.g. 'red')\n            corresponding with the color for each channel in `im`.\n        channel_ranges (list[list[float]]): A list of 2-element lists (e.g. [0.01, 0.99])\n            giving the value ranges that should be mapped to colors for each\n            channel. If the given numerical values are less or equal to 1.0,\n            they are interpreted as quantiles and the corresponding intensity\n            values are calculated on the channel non-zero values, otherwise they\n            are directly used as intensities. Values outside of this range will\n            be clipped.\n        verbose (bool): Whether to print out information messages.\n    Returns:\n        An RGB image of shape (y, x, 3), where the third axis corresponds to\n            red, green and blue channels. The image is suitable for plotting with\n            `matplotlib.pyplot.imshow` and oriented such that it results in the\n            same orentiation as when directly plotting a single channel.\n    Examples:\n        Convert an image `img` from (2, y, x) to (y, x, 3), using the\n        channels as yellow and blue intensities:\n        &gt;&gt;&gt; img_rgb = convert_to_rgb(img, ['yellow', 'blue'])   \n    \"\"\"\n# digest arguments\nassert len(im.shape) == 3, f\"`im` has shape {im.shape} but must have three dimensions\"\nassert len(channel_colors) == im.shape[0], (\nf\"`channel_colors` must be of the same length as the first axis in `im` ({im.shape[0]})\"\n)\nassert len(channel_ranges) == len(channel_colors), (\nf\"`channel_ranges` must be of the same length as `channel_colors` ({len(channel_colors)})\"\n)\n# make a copy of the input argument\nif isinstance(im, dask.array.Array):\nim = im.compute()\nim = deepcopy(im).astype(np.float64)\n# clip and normalize each channel according to the channel_ranges (im: (ch,y,x))\nranges_used = []\nfor i in range(len(channel_ranges)):\nif max(channel_ranges[i]) &lt;= 1.0:\n# ranges are given as quantiles -&gt; calculate corresponding intensities\nnonzero = im[i] &gt; 0\nif np.any(nonzero):\nrng = np.quantile(a=im[i][nonzero], q=channel_ranges[i], overwrite_input=False)\nelse:\nrng = [0.0, 0.0]\nif verbose:\nprint(f\"Interpreting ranges for channel {i} as quantiles, corresponding to absolute intensities {rng[0]} and {rng[1]}\")\nelse:\nrng = channel_ranges[i]\nranges_used.append(rng)\nim[i] = np.clip(im[i], rng[0], rng[1])\nim[i] = (im[i] - rng[0]) / (rng[1] - rng[0])\n# convert the color strings to RGB values\nrgb_colors = np.array([mcolors.to_rgb(c) for c in channel_colors])    \n# multiply channels with channel_colors and create weighted sum to (y,x,3)\nrgb_im = np.einsum('cyx,cr-&gt;yxr', im, rgb_colors)\n# clip to [0,1], map to [0, 255] and convert to uint8 type\nrgb_im = np.clip(rgb_im, 0, 1)\nrgb_im = (rgb_im * 255.0).astype(np.uint8)\nreturn rgb_im\n</code></pre>"},{"location":"plotting/#src.ez_zarr.plotting.get_shuffled_cmap","title":"<code>get_shuffled_cmap(cmap_name='hsv', seed=42)</code>","text":"<p>Create shuffled color map.</p> <p>Parameters:</p> Name Type Description Default <code>cmap_name</code> <code>str</code> <p>The name of the color map (passed to <code>cmap</code> argument of matplotlib.colormaps.get_cmap).</p> <code>'hsv'</code> <code>seed</code> <code>int</code> <p>Used to seed the random number generator with numpy.random.seed.</p> <code>42</code> <p>Examples:</p> <p>Obtain a matplotlib.colors.ListedColormap with randomized color ordering:</p> <pre><code>&gt;&gt;&gt; cm = plotting.get_shuffled_cmap()\n</code></pre> Source code in <code>src/ez_zarr/plotting.py</code> <pre><code>def get_shuffled_cmap(cmap_name: str='hsv', seed: int=42) -&gt; mcolors.ListedColormap:\n\"\"\"\n    Create shuffled color map.\n    Parameters:\n        cmap_name (str): The name of the color map (passed to `cmap` argument\n            of matplotlib.colormaps.get_cmap).\n        seed (int): Used to seed the random number generator with\n            numpy.random.seed.\n    Examples:\n        Obtain a matplotlib.colors.ListedColormap with randomized color ordering:\n        &gt;&gt;&gt; cm = plotting.get_shuffled_cmap()\n    \"\"\"\ncmap = plt.colormaps.get_cmap(cmap_name)\nall_colors = cmap(np.linspace(0, 1, cmap.N))\nnp.random.seed(seed)\nnp.random.shuffle(all_colors)\nshuffled_cmap = mcolors.ListedColormap(all_colors)\nreturn shuffled_cmap\n</code></pre>"},{"location":"plotting/#src.ez_zarr.plotting.pad_image","title":"<code>pad_image(im, output_shape, constant_value=0)</code>","text":"<p>Pad an image by adding pixels of <code>constant_value</code> symmetrically around it to make it shape <code>output_shape</code>.</p> <p>Parameters:</p> Name Type Description Default <code>im</code> <code>array or ndarray</code> <p>Input image.</p> required <code>output_shape</code> <code>tuple[int]</code> <p>Desired output shape after padding (must be greater or equal to im.shape).</p> required <code>constant_value</code> <code>int</code> <p>Value for added pixels.</p> <code>0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray with padded image of shape <code>output_shape</code>.</p> <p>Examples:</p> <p>Make the image <code>im</code> (100, 100) in shape:</p> <pre><code>&gt;&gt;&gt; pad_image(im, (100, 100))\n</code></pre> Source code in <code>src/ez_zarr/plotting.py</code> <pre><code>def pad_image(im: Union[dask.array.Array, np.ndarray],\noutput_shape: tuple,\nconstant_value: int=0) -&gt; np.ndarray:\n\"\"\"\n    Pad an image by adding pixels of `constant_value` symmetrically around it\n    to make it shape `output_shape`.\n    Parameters:\n        im (dask.array or numpy.ndarray): Input image.\n        output_shape (tuple[int]): Desired output shape after padding (must be greater\n            or equal to im.shape).\n        constant_value (int): Value for added pixels.\n    Returns:\n        np.ndarray with padded image of shape `output_shape`.\n    Examples:\n        Make the image `im` (100, 100) in shape:\n        &gt;&gt;&gt; pad_image(im, (100, 100))\n    \"\"\"\n# digest arguments\nassert len(im.shape) == len(output_shape), f\"output_shape {output_shape} should be of length {len(im.shape)}\"\nassert all([im.shape[i] &lt;= output_shape[i] for i in range(len(output_shape))]), f\"output_shape {output_shape} must be greater or equal to image shape {im.shape}\"\nassert isinstance(constant_value, int)\n# calculate padding size\npad_total = np.subtract(output_shape, im.shape)\npad_before = [int(x) for x in pad_total / 2]\npad_after = pad_total - pad_before\npad_size = tuple([(pad_before[i], pad_after[i]) for i in range(len(pad_total))])\n# add padding\nim = np.pad(im, pad_width=pad_size, mode='constant', constant_values=constant_value)\nreturn im\n</code></pre>"},{"location":"plotting/#src.ez_zarr.plotting.plot_image","title":"<code>plot_image(im, msk=None, msk_alpha=0.3, show_label_values=False, restrict_to_label_values=[], label_text_colour='white', label_fontsize='xx-large', channels=[0], channel_colors=['white'], channel_ranges=[[0.01, 0.95]], z_projection_method='maximum', pad_to_yx=[0, 0], pad_value=0, image_transform=None, axis_style='none', spacing_yx=None, title=None, title_fontsize='large', scalebar_pixel=0, scalebar_color='white', scalebar_position='bottomright', scalebar_label=None, scalebar_fontsize='large', call_show=True, fig_width_inch=24.0, fig_height_inch=16.0, fig_dpi=150, fig_style='dark_background', verbose=False)</code>","text":"<p>Plot an image array, optionally overlaid with a segmentation mask.</p> <p>Plot an image (provided as an array with shape (ch,z,y,x), (ch,y,x) or (y,x)) by summarizing multiple z planes using <code>z_projection_method</code> (if needed), mapping channels values (in the range of <code>channel_ranges</code>) to colors (given by <code>channel_colors</code>), converting it to an RGB array of shape (x,y,3) and plotting it using <code>matplotlib.pyplot.imshow</code>. If <code>msk</code> is provided, it is assumed to contain a compatible segmentation mask and will be plotted transparently (controlled by <code>msk_alpha</code>) on top of the image.</p> <p>Parameters:</p> Name Type Description Default <code>im</code> <code>ndarray</code> <p>An array with four (ch,z,y,x), three (ch,y,x) or two (y,x) dimensions with image intensities.</p> required <code>msk</code> <code>ndarray</code> <p>An optional cooresponding mask array with a shape compatible to <code>im</code> (typically without <code>ch</code> axis). If given, label values will be mapped to discrete colors and plotted transparently on top of the image.</p> <code>None</code> <code>msk_alpha</code> <code>float</code> <p>A scalar value between 0 (fully transparent) and 1 (solid) defining the transparency of the mask.</p> <code>0.3</code> <code>show_label_values</code> <code>bool</code> <p>Whether to show the label values at the centroid of each label.</p> <code>False</code> <code>restrict_to_label_values</code> <code>list or scalar</code> <p>A scalar or a (possibly empty) list of label values. Only has an effect if <code>msk</code> is provided. In that case, pixels with values not in <code>restrict_to_label_values</code> will be set to <code>pad_value</code> in <code>img</code> (see below), and to 0 in <code>msk</code>. If empty, all data within the image is shown without restriction.</p> <code>[]</code> <code>label_text_colour</code> <code>str</code> <p>The colour of the label text, if <code>show_label_values</code> is True. Ignored otherwise.</p> <code>'white'</code> <code>label_fontsize</code> <code>float or str</code> <p>The font size of the label text, if <code>show_label_values</code> is True. Ignored otherwise. Values accepted by <code>matplotlib.axes.Axes.text</code> are supported, such a the size in points (e.g. <code>12.5</code>) or a relative size (e.g. <code>'xx-large'</code>).</p> <code>'xx-large'</code> <code>channels</code> <code>list[int]</code> <p>The image channel(s) to be plotted. For example, to plot the first and third channel of a 4-channel image with shape (4,1,500,600), you can use <code>channels=[0, 2]</code>. If several channels are given, they will be mapped to colors using <code>channel_colors</code>. In the case of a single channel, <code>channel_colors</code> can also be the name of a supported colormap.</p> <code>[0]</code> <code>channel_colors</code> <code>list[str]</code> <p>A list with python color strings (e.g. 'red') defining the color for each channel in <code>channels</code>. For example, to map the selected <code>channels=[0, 2]</code> to cyan and magenta, respectively, you can use <code>channel_colors=['cyan', 'magenta']</code>. If a single channel is given (e.g. <code>channels=[0]</code>), this can also be one of the following colormaps: 'viridis', 'plasma', 'inferno', 'magma', 'cividis'.</p> <code>['white']</code> <code>channel_ranges</code> <code>list[list[float]]</code> <p>A list of 2-element lists (e.g. [0.01, 0.95]) giving the the value ranges that should be mapped to colors for each channel. If the given numerical values are less or equal to 1.0, they are interpreted as quantiles and the corresponding intensity values are calculated on the channel non-zero values, otherwise they are directly used as intensities. Values outside of this range will be clipped.</p> <code>[[0.01, 0.95]]</code> <code>z_projection_method</code> <code>str</code> <p>Method for combining multiple z planes. For available methods, see ez_zarr.plotting.zproject (default: 'maximum').</p> <code>'maximum'</code> <code>pad_to_yx</code> <code>list[int]</code> <p>If the image or label mask are smaller, pad them by <code>pad_value</code> to this total y and x size. </p> <code>[0, 0]</code> <code>pad_value</code> <code>int</code> <p>Value to use for constant-value image padding.</p> <code>0</code> <code>image_transform</code> <code>Callable</code> <p>A function to transform the image values before conversion to RGB and plotting. If <code>None</code>, no transform is applied.</p> <code>None</code> <code>axis_style</code> <code>str</code> <p>A string scalar defining how to draw the axis. Should be one of 'none' (no axis, the default), 'pixel' (show pixel labels), 'frame' (show just a frame around the plot without ticks) or 'micrometer' (show micrometer labels). If <code>axis_style='micrometer'</code>, <code>spacing_yx</code> is used to convert pixel to micrometer.</p> <code>'none'</code> <code>spacing_yx</code> <code>list[float]</code> <p>The spacing of pixels in y and x direction, in micrometer, used to convert pixels to micrometer when <code>axis_style='micrometer'</code>.</p> <code>None</code> <code>title</code> <code>str</code> <p>String to add as a title on top of the image. If <code>None</code> (the default), no title will be added.</p> <code>None</code> <code>title_fontsize</code> <code>float or str</code> <p>Font size of the title. Values accepted by <code>matplotlib.axes.Axes.text</code> are supported, such a the size in points (e.g. <code>12.5</code>) or a relative size (e.g. <code>'xx-large'</code>).</p> <code>'large'</code> <code>scalebar_pixel</code> <code>int</code> <p>If non-zero, draw a scalebar of size <code>scalebar_pixel</code> in the corner of the image defined by <code>scalebar_position</code>.</p> <code>0</code> <code>scalebar_color</code> <code>str</code> <p>Scalebar color.</p> <code>'white'</code> <code>scalebar_position</code> <code>str</code> <p>position of the scale bar, one of 'topleft', 'topright', 'bottomleft' or 'bottomright'</p> <code>'bottomright'</code> <code>scalebar_label</code> <code>str</code> <p>If not <code>None</code> (default), a string scalar to show as a label for the scale bar.</p> <code>None</code> <code>scalebar_fontsize</code> <code>float or str</code> <p>Font size of the scalebar label. Values accepted by <code>matplotlib.axes.Axes.text</code> are supported, such a the size in points (e.g. <code>12.5</code>) or a relative size (e.g. <code>'xx-large'</code>).</p> <code>'large'</code> <code>call_show</code> <code>bool</code> <p>If <code>True</code>, the call to <code>matplotlib.pyplot.imshow</code> is embedded between <code>matplotlib.pyplot.figure</code> and <code>matplotlib.pyplot.show</code>/<code>matplotlib.pyplot.close</code> calls. This is the default behaviour and typically used when an individual image should be plotted and displayed. It can be set to <code>False</code> if multiple images should be plotted and their arrangement is controlled outside of <code>plotting.plot_image</code>. The parameters <code>fig_width_inch</code>, <code>fig_height_inch</code> and <code>fig_dpi</code> are ignored in that case.</p> <code>True</code> <code>fig_width_inch</code> <code>float</code> <p>Figure width (in inches).</p> <code>24.0</code> <code>fig_height_inch</code> <code>float</code> <p>Figure height (in inches).</p> <code>16.0</code> <code>fig_dpi</code> <code>int</code> <p>Figure resolution (dots per inch).</p> <code>150</code> <code>fig_style</code> <code>str</code> <p>Style for the figure. Supported are 'brightfield', which is a special mode for single-channel brightfield microscopic images (it will automatically set <code>channels=[0]</code>, <code>channel_colors=['white']</code> <code>z_projection_method='minimum'</code>, <code>pad_value=max_int</code> and <code>fig_style='default'</code>), where <code>max_int</code> is the maximal value for the dtype of <code>im</code>, and any other styles that can be passed to <code>matplotlib.pyplot.style.context</code> (default: 'dark_background')</p> <code>'dark_background'</code> <code>verbose</code> <code>bool</code> <p>Whether to print out information messages.</p> <code>False</code> <p>Examples:</p> <p>Plot the first channel of <code>img</code> in gray-scale.</p> <pre><code>&gt;&gt;&gt; plot_image(img, channels=[0], channel_colors=['white'])\n</code></pre> Source code in <code>src/ez_zarr/plotting.py</code> <pre><code>def plot_image(im: np.ndarray,\nmsk: Optional[np.ndarray]=None,\nmsk_alpha: float=0.3,\nshow_label_values: bool=False,\nrestrict_to_label_values: Union[list,int,float,bool,str]=[],\nlabel_text_colour: str='white',\nlabel_fontsize: Union[float, str]='xx-large',\nchannels: list[int]=[0],\nchannel_colors: list[str]=['white'],\nchannel_ranges: list[list[float]]=[[0.01, 0.95]],\nz_projection_method: str='maximum',\npad_to_yx: list[int]=[0, 0],\npad_value: int=0,\nimage_transform: Optional[Callable]=None,\naxis_style: str='none',\nspacing_yx: Optional[list[float]]=None,\ntitle: Optional[str]=None,\ntitle_fontsize: Union[float, str]='large',\nscalebar_pixel: int=0,\nscalebar_color: str='white',\nscalebar_position: str='bottomright',\nscalebar_label: Optional[str]=None,\nscalebar_fontsize: Union[float, str]='large',\ncall_show: bool=True,\nfig_width_inch: float=24.0,\nfig_height_inch: float=16.0,\nfig_dpi: int=150,\nfig_style: str='dark_background',\nverbose: bool=False):\n\"\"\"\n        Plot an image array, optionally overlaid with a segmentation mask.\n        Plot an image (provided as an array with shape (ch,z,y,x), (ch,y,x) or (y,x))\n        by summarizing multiple z planes using `z_projection_method` (if needed),\n        mapping channels values (in the range of `channel_ranges`) to colors\n        (given by `channel_colors`), converting it to an RGB array of shape\n        (x,y,3) and plotting it using `matplotlib.pyplot.imshow`.\n        If `msk` is provided, it is assumed to contain a compatible segmentation\n        mask and will be plotted transparently (controlled by `msk_alpha`)\n        on top of the image.\n        Parameters:\n            im (numpy.ndarray): An array with four (ch,z,y,x), three (ch,y,x)\n                or two (y,x) dimensions with image intensities.\n            msk (numpy.ndarray): An optional cooresponding mask array with\n                a shape compatible to `im` (typically without `ch` axis).\n                If given, label values will be mapped to discrete colors\n                and plotted transparently on top of the image.\n            msk_alpha (float): A scalar value between 0 (fully transparent)\n                and 1 (solid) defining the transparency of the mask.\n            show_label_values (bool): Whether to show the label values at\n                the centroid of each label.\n            restrict_to_label_values (list or scalar): A scalar or a (possibly\n                empty) list of label values. Only has an effect if `msk` is provided.\n                In that case, pixels with values not in `restrict_to_label_values`\n                will be set to `pad_value` in `img` (see below), and to 0 in `msk`.\n                If empty, all data within the image is shown without restriction.\n            label_text_colour (str): The colour of the label text, if\n                `show_label_values` is True. Ignored otherwise.\n            label_fontsize (float or str): The font size of the label text, if\n                `show_label_values` is True. Ignored otherwise. Values accepted\n                by `matplotlib.axes.Axes.text` are supported, such a the size\n                in points (e.g. `12.5`) or a relative size (e.g. `'xx-large'`).\n            channels (list[int]): The image channel(s) to be plotted. For example,\n                to plot the first and third channel of a 4-channel image with\n                shape (4,1,500,600), you can use `channels=[0, 2]`. If several\n                channels are given, they will be mapped to colors using\n                `channel_colors`. In the case of a single channel, `channel_colors`\n                can also be the name of a supported colormap.\n            channel_colors (list[str]): A list with python color strings\n                (e.g. 'red') defining the color for each channel in `channels`.\n                For example, to map the selected `channels=[0, 2]` to\n                cyan and magenta, respectively, you can use\n                `channel_colors=['cyan', 'magenta']`. If a single channel is\n                given (e.g. `channels=[0]`), this can also be one of the following\n                colormaps: 'viridis', 'plasma', 'inferno', 'magma', 'cividis'.\n            channel_ranges (list[list[float]]): A list of 2-element lists\n                (e.g. [0.01, 0.95]) giving the the value ranges that should\n                be mapped to colors for each channel. If the given numerical\n                values are less or equal to 1.0, they are interpreted as quantiles\n                and the corresponding intensity values are calculated on the\n                channel non-zero values, otherwise they are directly used as\n                intensities. Values outside of this range will be clipped.\n            z_projection_method (str): Method for combining multiple z planes.\n                For available methods, see ez_zarr.plotting.zproject\n                (default: 'maximum').\n            pad_to_yx (list[int]): If the image or label mask are smaller, pad\n                them by `pad_value` to this total y and x size. \n            pad_value (int): Value to use for constant-value image padding.\n            image_transform (Callable): A function to transform the image values\n                before conversion to RGB and plotting. If `None`, no transform is applied.\n            axis_style (str): A string scalar defining how to draw the axis. Should\n                be one of 'none' (no axis, the default), 'pixel' (show pixel labels),\n                'frame' (show just a frame around the plot without ticks)\n                or 'micrometer' (show micrometer labels). If `axis_style='micrometer'`,\n                `spacing_yx` is used to convert pixel to micrometer.\n            spacing_yx (list[float]): The spacing of pixels in y and x direction,\n                in micrometer, used to convert pixels to micrometer when\n                `axis_style='micrometer'`.\n            title (str): String to add as a title on top of the image. If `None`\n                (the default), no title will be added.\n            title_fontsize (float or str): Font size of the title. Values accepted\n                by `matplotlib.axes.Axes.text` are supported, such a the size\n                in points (e.g. `12.5`) or a relative size (e.g. `'xx-large'`).\n            scalebar_pixel (int): If non-zero, draw a scalebar of size `scalebar_pixel`\n                in the corner of the image defined by `scalebar_position`.\n            scalebar_color (str): Scalebar color.\n            scalebar_position (str): position of the scale bar, one of 'topleft',\n                'topright', 'bottomleft' or 'bottomright'\n            scalebar_label (str): If not `None` (default), a string scalar to show\n                as a label for the scale bar.\n            scalebar_fontsize (float or str): Font size of the scalebar label. Values\n                accepted by `matplotlib.axes.Axes.text` are supported, such a the size\n                in points (e.g. `12.5`) or a relative size (e.g. `'xx-large'`).\n            call_show (bool): If `True`, the call to `matplotlib.pyplot.imshow` is\n                embedded between `matplotlib.pyplot.figure` and\n                `matplotlib.pyplot.show`/`matplotlib.pyplot.close` calls.\n                This is the default behaviour and typically used when an individual\n                image should be plotted and displayed. It can be set to `False`\n                if multiple images should be plotted and their arrangement\n                is controlled outside of `plotting.plot_image`. The parameters\n                `fig_width_inch`, `fig_height_inch` and `fig_dpi` are ignored\n                in that case.\n            fig_width_inch (float): Figure width (in inches).\n            fig_height_inch (float): Figure height (in inches).\n            fig_dpi (int): Figure resolution (dots per inch).\n            fig_style (str): Style for the figure. Supported are 'brightfield', which\n                is a special mode for single-channel brightfield microscopic images\n                (it will automatically set `channels=[0]`, `channel_colors=['white']`\n                `z_projection_method='minimum'`, `pad_value=max_int` and `fig_style='default'`),\n                where `max_int` is the maximal value for the dtype of `im`,\n                and any other styles that can be passed to `matplotlib.pyplot.style.context`\n                (default: 'dark_background')\n            verbose (bool): Whether to print out information messages.\n        Examples:\n            Plot the first channel of `img` in gray-scale.\n            &gt;&gt;&gt; plot_image(img, channels=[0], channel_colors=['white'])\n        \"\"\"\n# digest arguments\nif im.ndim == 2:\nim = im[np.newaxis, :]\nndim = len(im.shape)\nassert ndim == 3 or ndim == 4, (\nf\"Unsupported image dimension ({im.shape}), \",\n\"should be either (ch,z,y,x) or (ch,y,x)\"\n)\nassert msk is None or msk.shape == im.shape[1:], (\nf\"`msk` dimension ({msk.shape}) is not compatible with `im` \"\nf\"dimension, should be ({im.shape[1:]})\"\n)\nnch = im.shape[0]\nassert all([ch &lt;= nch for ch in channels]), (\nf\"Invalid `channels` parameter, must be less or equal to {nch}\"\n)\nassert len(channels) == len(channel_colors), (\nf\"`channels` and `channel_colors` must have the same length, \"\nf\"but are {len(channels)} and {len(channel_colors)}\"\n)\nassert axis_style != 'micrometer' or spacing_yx != None, (\n\"For `axis_style='micrometer', the parameter `spacing_yx` needs to be provided.\"\n)\nif isinstance(restrict_to_label_values, np.ScalarType):\nrestrict_to_label_values = [restrict_to_label_values]\nassert isinstance(restrict_to_label_values, list), (\nf\"`restrict_to_label_values` must be a list of values, but is {restrict_to_label_values}\"\n)\n# adjust parameters for brightfield images\nif fig_style == 'brightfield':\nif verbose:\nprint(\"Adjusting parameters for brightfield image\")\nchannels = [0]\nchannel_colors = ['white']\npad_value = np.issubdtype(im.dtype, np.integer) and np.iinfo(im.dtype).max or np.finfo(im.dtype).max\nz_projection_method = 'minimum'\nfig_style = 'default'\nif label_text_colour == 'white':\nlabel_text_colour = 'black'\n# combine z planes if needed\nif ndim == 4:\n# im: (ch,z,y,x) -&gt; (ch,y,x))\nif verbose:\nprint(f\"Applying z-projection ({z_projection_method} method)\")\nim = zproject(im=im, method=z_projection_method,\naxis=1, keepdims=False)\nif not msk is None:\n# msk: (z,y,x) -&gt; (y,x)\nmsk = zproject(im=msk, method='maximum', # always use 'maximum' for labels\naxis=0, keepdims=False)\n# restrict to label values if needed\nif len(restrict_to_label_values) &gt; 0 and not msk is None:\nif verbose:\nprint(\"Restricting to provided label values\")\nkeep_elements = np.isin(msk, restrict_to_label_values)\nim = np.where(keep_elements, im, pad_value)\nmsk = np.where(keep_elements, msk, 0)\n# pad if necessary\nif any([v &gt; 0 for v in pad_to_yx]) and (im.shape[1] &lt;= pad_to_yx[0] and im.shape[2] &lt;= pad_to_yx[1]):\nif verbose:\nprint(\"Padding to requested size\")\nim = pad_image(im=im,\noutput_shape=[nch, pad_to_yx[0], pad_to_yx[1]],\nconstant_value=pad_value)\nif not msk is None:\nmsk = pad_image(im=msk,\noutput_shape=pad_to_yx,\nconstant_value=pad_value)\n# transform image\nif not image_transform is None:\nif verbose:\nprint(\"Transforming image values\")\nim = image_transform(im)\n# convert (ch,y,x) to rgb (y,x,3)\nif len(channels) == 1 and channel_colors[0] in ['viridis', 'plasma', 'inferno',\n'magma', 'cividis']:\nif verbose:\nprint(f\"Using colormap {channel_colors[0]}\")\n# map to colormap\nim_rgb = np.squeeze(im[channels], axis=0)\ncmap = channel_colors[0]\nelse:\nif verbose:\nprint(\"Mapping channel colors to rgb space\")\n# map to rgb\nim_rgb = convert_to_rgb(im=im[channels],\nchannel_colors=channel_colors,\nchannel_ranges=channel_ranges)\ncmap = None\n# define nested function with main plotting code\ndef _do_plot():\nplt.imshow(im_rgb, cmap=cmap)\nif not msk is None and np.max(msk) &gt; 0:\nplt.imshow(msk,\ninterpolation='none',\ncmap=get_shuffled_cmap(),\nalpha=np.multiply(float(msk_alpha), msk &gt; 0))\nif show_label_values:\nskim = importlib.import_module('skimage.measure')\nprops = skim.regionprops(msk)\nfor j in range(len(props)):\nplt.text(x=props[j].centroid[1],\ny=props[j].centroid[0],\ns=props[j].label,\nha='center',\nva='center',\ncolor=label_text_colour,\nfontsize=label_fontsize)\nif axis_style == 'none':\nplt.axis('off')\nelif axis_style == 'pixel':\npass\nelif axis_style == 'frame':\nplt.xticks([]) # remove axis ticks\nplt.yticks([])\nelif axis_style == 'micrometer':\nax = plt.gca() # get current axes\nyticks = ticker.FuncFormatter(lambda y, pos: '{0:g}'.format(y * spacing_yx[0]))\nxticks = ticker.FuncFormatter(lambda x, pos: '{0:g}'.format(x * spacing_yx[1]))\nax.yaxis.set_major_formatter(yticks)\nax.xaxis.set_major_formatter(xticks)\nelse:\nraise ValueError(f\"Unknown `axis_style` ({axis_style}), should be one of 'none', 'pixel', 'frame' or 'micrometer'\")\nif title != None:\nplt.title(title, fontsize=title_fontsize)\nif scalebar_pixel != 0:\nimg_yx = im_rgb.shape[0:2]\nd = min([round(img_yx[i] * 0.05) for i in range(2)]) # 5% margin\nscalebar_height = round(img_yx[0] * 0.0075)\nif scalebar_position == 'bottomright':\npos_xy = (img_yx[1] - d - scalebar_pixel, img_yx[0] - d)\npos_text_xy = (pos_xy[0] + scalebar_pixel/2, pos_xy[1] - scalebar_height - d/10)\nva_text = 'bottom'\nelif scalebar_position == 'bottomleft':\npos_xy = (d, img_yx[0] - d)\npos_text_xy = (pos_xy[0] + scalebar_pixel/2, pos_xy[1] - scalebar_height - d/10)\nva_text = 'bottom'\nelif scalebar_position == 'topleft':\npos_xy = (d, d + scalebar_height)\npos_text_xy = (pos_xy[0] + scalebar_pixel/2, pos_xy[1] + 0.5*d)\nva_text = 'top'\nelif scalebar_position == 'topright':\npos_xy = (img_yx[1] - d - scalebar_pixel, d - scalebar_height)\npos_text_xy = (pos_xy[0] + scalebar_pixel/2, pos_xy[1] + 0.5*d)\nva_text = 'top'\nelse:\nraise ValueError(f\"Unknown scalebar_position ({scalebar_position}), should be one of 'bottomright', 'bottomleft', 'topright', or 'topleft'\")\nrect = patches.Rectangle(xy=pos_xy, width=scalebar_pixel,\nheight=scalebar_height,\nedgecolor=scalebar_color,\nfacecolor=scalebar_color)\nax = plt.gca() # get current axes\nax.add_patch(rect) # add the patch to the axes\nif scalebar_label != None:\nplt.text(x=pos_text_xy[0], y=pos_text_xy[1], s=scalebar_label,\ncolor=scalebar_color, ha='center', va=va_text,\nfontsize=scalebar_fontsize)\n# create the plot\nif call_show:\nwith plt.style.context(fig_style):\nfig = plt.figure(figsize=(fig_width_inch, fig_height_inch))\nfig.set_dpi(fig_dpi)\n_do_plot()\nplt.show()\nplt.close()\nelse:\n_do_plot()\n</code></pre>"},{"location":"plotting/#src.ez_zarr.plotting.zproject","title":"<code>zproject(im, axis=1, method='maximum', keepdims=True, img_bit=16)</code>","text":"<p>Project a 4D or 3D image along z-axis according to desired projection method.</p> <p>Helper function to conveniently project multi-dimensional images along z-axis according to desired projection method. </p> <p>Parameters:</p> Name Type Description Default <code>im</code> <code>array or ndarray</code> <p>The array to be projected.</p> required <code>axis</code> <code>int</code> <p>The axis on which to perform the projection (typically the z-axis). Unless otherwise specified, it defaults to axis 1 (by convention Fractal  outputs have shape ch,z,y,x). Note: if masks are projected, Fractal output have usually  shape z,y,x, so use <code>axis=0</code> in that case.</p> <code>1</code> <code>method</code> <code>str</code> <p>The projection method of choice. Available options are  'maximum' (default), 'minimum' (typically used for brightfield images), 'sum', 'average'.</p> <code>'maximum'</code> <code>keepdims</code> <code>bool</code> <p>Should the output array keep the same dimensions  as the input array (<code>True</code>), or should the z-axis been squeezed  (<code>False</code>, default behaviour of e.g. np.min())</p> <code>True</code> <code>img_bit</code> <code>int</code> <p>Is the image 8- or 16-bit? Relevant for 'sum'  projection, where clipping might be necessary.</p> <code>16</code> <p>Returns:</p> Type Description <code>Union[Array, ndarray]</code> <p>The input array where the z-axis has been projected according to the method of choice.</p> <p>Examples:</p> <p>Project np.array along z-axis:</p> <pre><code>&gt;&gt;&gt; zproject(im=np.array([[[1,2,4],[1,3,5],[1,6,7]],[[1,2,4],[1,3,5],[1,6,7]]]), method='maximum', axis=1)\n</code></pre> Source code in <code>src/ez_zarr/plotting.py</code> <pre><code>def zproject(im: Union[dask.array.Array, np.ndarray],\naxis: Optional[int]=1,\nmethod: Optional[str]='maximum',\nkeepdims: Optional[bool]=True,\nimg_bit: Optional[int]=16) -&gt; Union[dask.array.Array, np.ndarray]:\n\"\"\"\n    Project a 4D or 3D image along z-axis according to desired projection method.\n    Helper function to conveniently project multi-dimensional images along z-axis according to desired projection method. \n    Parameters:\n        im (dask.array or np.ndarray): The array to be projected.\n        axis (int): The axis on which to perform the projection (typically\n            the z-axis). Unless otherwise specified, it defaults to axis 1 (by convention Fractal \n            outputs have shape ch,z,y,x). Note: if masks are projected, Fractal output have usually \n            shape z,y,x, so use `axis=0` in that case.\n        method (str): The projection method of choice. Available options are \n            'maximum' (default), 'minimum' (typically used for brightfield images), 'sum', 'average'.\n        keepdims (bool): Should the output array keep the same dimensions \n            as the input array (`True`), or should the z-axis been squeezed \n            (`False`, default behaviour of e.g. np.min())\n        img_bit (int): Is the image 8- or 16-bit? Relevant for 'sum' \n            projection, where clipping might be necessary.\n    Returns:\n        The input array where the z-axis has been projected according to the method of choice.\n    Examples:\n        Project np.array along z-axis:\n        &gt;&gt;&gt; zproject(im=np.array([[[1,2,4],[1,3,5],[1,6,7]],[[1,2,4],[1,3,5],[1,6,7]]]), method='maximum', axis=1)\n    \"\"\"\nmethods = {\n'maximum': np.max,\n'minimum': np.min,\n'sum': np.sum,\n'average': np.mean,\n}\nif not method in methods:\nraise ValueError(f\"Unknown method ({method}), should be one of: \" + ', '.join(list(methods.keys())))\nim = methods[method](im, axis=axis, keepdims=keepdims) \nif method == 'sum':\nmax_value = (2**img_bit) - 1\nim = np.clip(im, 0, max_value)\nreturn im\n</code></pre>"},{"location":"testing/","title":"Unit tests","text":""},{"location":"testing/#ome_zarr","title":"ome_zarr","text":""},{"location":"testing/#tests.test_ome_zarr.img2d","title":"<code>img2d()</code>","text":"<p>A <code>ome_zarr.Image</code> object representing a 2D image</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>@pytest.fixture\ndef img2d():\n\"\"\"A `ome_zarr.Image` object representing a 2D image\"\"\"\nreturn ome_zarr.Image('tests/example_data/plate_ones_mip.zarr/B/03/0', name=\"test\")\n</code></pre>"},{"location":"testing/#tests.test_ome_zarr.img3d","title":"<code>img3d()</code>","text":"<p>A <code>ome_zarr.Image</code> object representing a 3D image</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>@pytest.fixture\ndef img3d():\n\"\"\"A `ome_zarr.Image` object representing a 3D image\"\"\"\nreturn ome_zarr.Image('tests/example_data/plate_ones.zarr/B/03/0')\n</code></pre>"},{"location":"testing/#tests.test_ome_zarr.img3dv3","title":"<code>img3dv3()</code>","text":"<p>A <code>ome_zarr.Image</code> object representing a 3D Zarr v3 image</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>@pytest.fixture\ndef img3dv3():\n\"\"\"A `ome_zarr.Image` object representing a 3D Zarr v3 image\"\"\"\nreturn ome_zarr.Image('tests/example_data_zarr3/6001240_labels_v0.5.zarr', name=\"testv3\")\n</code></pre>"},{"location":"testing/#tests.test_ome_zarr.img4d","title":"<code>img4d()</code>","text":"<p>A <code>ome_zarr.Image</code> object representing a 4D image</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>@pytest.fixture\ndef img4d():\n\"\"\"A `ome_zarr.Image` object representing a 4D image\"\"\"\nreturn ome_zarr.Image('tests/example_data_5d/tubhiswt4D_sub.zarr')\n</code></pre>"},{"location":"testing/#tests.test_ome_zarr.imgL","title":"<code>imgL()</code>","text":"<p>A <code>ome_zarr.ImageList</code> object with one image</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>@pytest.fixture\ndef imgL():\n\"\"\"A `ome_zarr.ImageList` object with one image\"\"\"\nreturn ome_zarr.ImageList(['tests/example_data/plate_ones_mip.zarr/B/03/0'])\n</code></pre>"},{"location":"testing/#tests.test_ome_zarr.imgL2","title":"<code>imgL2()</code>","text":"<p>A <code>ome_zarr.ImageList</code> object with two images</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>@pytest.fixture\ndef imgL2():\n\"\"\"A `ome_zarr.ImageList` object with two images\"\"\"\nreturn ome_zarr.ImageList(['tests/example_data/plate_ones_mip.zarr/B/03/0', 'tests/example_data/plate_ones_mip.zarr/B/03/0'])\n</code></pre>"},{"location":"testing/#tests.test_ome_zarr.test_compare_multiscale_dicts","title":"<code>test_compare_multiscale_dicts()</code>","text":"<p>Test <code>Image._compare_multiscale_dicts</code>.</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>def test_compare_multiscale_dicts():\n\"\"\"Test `Image._compare_multiscale_dicts`.\"\"\"\ndatasets = [{'path': 1, 'coordinateTransformations': [{'type': 'scale',\n'scale': [1.0, 0.325, 0.325]}]},\n{'path': 2, 'coordinateTransformations': [{'type': 'scale',\n'scale': [1.0, 0.65, 0.65]}]},\n{'path': 0, 'coordinateTransformations': [{'type': 'scale',\n'scale': [1.0, 0.1625, 0.1625]}]}]\nassert ome_zarr.Image._compare_multiscale_dicts(datasets[0], datasets[0]) == 0\nassert ome_zarr.Image._compare_multiscale_dicts(datasets[0], datasets[1]) == -1\nassert ome_zarr.Image._compare_multiscale_dicts(datasets[1], datasets[2]) == 1\n</code></pre>"},{"location":"testing/#tests.test_ome_zarr.test_constructor","title":"<code>test_constructor(img2d, img3d, img4d, img3dv3, tmpdir)</code>","text":"<p>Test <code>ome_zarr.Image</code> object constructor.</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>def test_constructor(img2d: ome_zarr.Image, img3d: ome_zarr.Image, img4d: ome_zarr.Image, img3dv3: ome_zarr.Image, tmpdir: str):\n\"\"\"Test `ome_zarr.Image` object constructor.\"\"\"\n# non-conforming input\n# ... multiple zarr groups\nassert tmpdir.check()\nshutil.copytree('tests/example_data/plate_ones_mip.zarr/B/03/0',\nstr(tmpdir) + '/example_img')\nshutil.copytree('tests/example_data/plate_ones_mip.zarr/B/03/0/labels',\nstr(tmpdir) + '/example_img/labels_copy')\nwith pytest.raises(Exception) as e_info:\nome_zarr.Image(str(tmpdir) + '/example_img')\nshutil.rmtree(str(tmpdir) + '/example_img/labels_copy')\n# ... path without array\nwith pytest.raises(Exception) as e_info:\nome_zarr.Image('tests/example_data/')\n# ... missing omero\nzattr_file = str(tmpdir) + '/example_img/.zattrs'\nshutil.copyfile(zattr_file, str(tmpdir) + 'zattr.orig')\nwith open(zattr_file) as f:\nzattr = json.load(f)\ndel zattr['omero']\nwith open(zattr_file, \"w\") as jsonfile:\njson.dump(zattr, jsonfile, indent=4)\nimg_no_omero = ome_zarr.Image(str(tmpdir) + '/example_img')\nassert img_no_omero.channels == [{'label': 'channel-1', 'color': '00FFFF'}, {'label': 'channel-2', 'color': '00FFFF'}]\nshutil.move(str(tmpdir) + 'zattr.orig', zattr_file)\n# ... unsupported version\nzattr_file = str(tmpdir) + '/example_img/.zattrs'\nshutil.copyfile(zattr_file, str(tmpdir) + 'zattr.orig')\nwith open(zattr_file) as f:\nzattr = json.load(f)\nzattr['multiscales'][0]['version'] = \"0.3\"\nwith open(zattr_file, \"w\") as jsonfile:\njson.dump(zattr, jsonfile, indent=4)\nwith pytest.raises(Exception) as e_info:\nome_zarr.Image(str(tmpdir) + '/example_img')\nshutil.move(str(tmpdir) + 'zattr.orig', zattr_file)\n# ... missing version\nzattr_file = str(tmpdir) + '/example_img/.zattrs'\nshutil.copyfile(zattr_file, str(tmpdir) + 'zattr.orig')\nwith open(zattr_file) as f:\nzattr = json.load(f)\ndel zattr['multiscales'][0]['version']\nwith open(zattr_file, \"w\") as jsonfile:\njson.dump(zattr, jsonfile, indent=4)\nwith pytest.warns(UserWarning):\nimg_no_version = ome_zarr.Image(str(tmpdir) + '/example_img')\nassert img_no_version.ndim == 4\nshutil.move(str(tmpdir) + 'zattr.orig', zattr_file)\n# ... clean up\nshutil.rmtree(str(tmpdir) + '/example_img')\n# ... missing version, Zarr v3\nshutil.copytree('tests/example_data_zarr3/6001240_labels_v0.5.zarr',\nstr(tmpdir) + '/example_img_v3')\nzjson_file = str(tmpdir) + '/example_img_v3/zarr.json'\nshutil.copyfile(zjson_file, str(tmpdir) + 'zjson.orig')\nwith open(zjson_file) as f:\nzattr = json.load(f)\ndel zattr['attributes']['ome']['version']\nwith open(zjson_file, \"w\") as jsonfile:\njson.dump(zattr, jsonfile, indent=4)\nwith pytest.warns(UserWarning):\nimg_no_version = ome_zarr.Image(str(tmpdir) + '/example_img_v3')\nshutil.move(str(tmpdir) + 'zjson.orig', zjson_file)\nshutil.rmtree(str(tmpdir) + '/example_img_v3')\n# 2D image with labels\nassert isinstance(img2d, ome_zarr.Image)\nassert img2d.path == 'tests/example_data/plate_ones_mip.zarr/B/03/0'\nassert img2d.name == 'test'\nassert isinstance(img2d.zarr_group, zarr.Group)\nassert all([isinstance(x, zarr.Array) for x in img2d.array_dict.values()])\nassert img2d.ndim == 4\nassert img2d.label_names == ['organoids']\nassert img2d.table_names == ['FOV_ROI_table']\nassert img2d.axes_unit_image == 'micrometer'\nassert img2d.channel_info_image == 'czyx'\nassert img2d.channel_info_labels == {'organoids': 'zyx'}\nassert img2d.nchannels_image == 2\nassert isinstance(img2d.channels, list)\nassert all([isinstance(img2d.channels[i], dict) for i in range(img2d.nchannels_image)])\n# 3D image without labels\nassert isinstance(img3d, ome_zarr.Image)\nassert img3d.path == 'tests/example_data/plate_ones.zarr/B/03/0'\nassert img3d.name == '0'\nassert isinstance(img3d.zarr_group, zarr.Group)\nassert all([isinstance(x, zarr.Array) for x in img3d.array_dict.values()])\nassert img3d.ndim == 4\nassert img3d.label_names == []\nassert img3d.table_names == ['FOV_ROI_table']\nassert img3d.axes_unit_image == 'micrometer'\nassert img3d.channel_info_image == 'czyx'\nassert img3d.channel_info_labels == {}\nassert img3d.nchannels_image == 2\nassert isinstance(img3d.channels, list)\nassert all([isinstance(img3d.channels[i], dict) for i in range(img3d.nchannels_image)])\n# 4D image with labels\nassert isinstance(img4d, ome_zarr.Image)\nassert img4d.path == 'tests/example_data_5d/tubhiswt4D_sub.zarr'\nassert img4d.name == 'tubhiswt4D_sub.zarr'\nassert isinstance(img4d.zarr_group, zarr.Group)\nassert all([isinstance(x, zarr.Array) for x in img4d.array_dict.values()])\nassert img4d.ndim == 5\nassert img4d.label_names == ['embryo']\nassert img4d.table_names == []\nassert img4d.axes_unit_image == 'micrometer'\nassert img4d.channel_info_image == 'tczyx'\nassert img4d.channel_info_labels == {'embryo': 'tzyx'}\nassert img4d.nchannels_image == 1\nassert isinstance(img4d.channels, list)\nassert all([isinstance(img4d.channels[i], dict) for i in range(img4d.nchannels_image)])\n# 3D image with labels, Zarr v3\nassert isinstance(img3dv3, ome_zarr.Image)\nassert img3dv3.path == 'tests/example_data_zarr3/6001240_labels_v0.5.zarr'\nassert img3dv3.name == 'testv3'\nassert isinstance(img3dv3.zarr_group, zarr.Group)\nassert all([isinstance(x, zarr.Array) for x in img3dv3.array_dict.values()])\nassert img3dv3.ndim == 4\nassert img3dv3.label_names == ['0']\nassert img3dv3.table_names == []\nassert img3dv3.axes_unit_image == 'micrometer'\nassert img3dv3.channel_info_image == 'czyx'\nassert img3dv3.channel_info_labels == {'0': 'czyx'}\nassert img3dv3.nchannels_image == 2\nassert isinstance(img3dv3.channels, list)\nassert all([isinstance(img3dv3.channels[i], dict) for i in range(img3dv3.nchannels_image)])\n</code></pre>"},{"location":"testing/#tests.test_ome_zarr.test_create_name_plate_A01","title":"<code>test_create_name_plate_A01()</code>","text":"<p>Test <code>ome_zarr.create_name_plate_A01</code> function.</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>def test_create_name_plate_A01():\n\"\"\"Test `ome_zarr.create_name_plate_A01` function.\"\"\"\nwith pytest.raises(Exception) as e_info:\nome_zarr.create_name_plate_A01(1)\nwith pytest.raises(Exception) as e_info:\nome_zarr.create_name_plate_A01(1, 2, 3)\nassert ome_zarr.create_name_plate_A01(1, 2) == 'A02'\nassert ome_zarr.create_name_plate_A01(3, 4) == 'C04'\nassert ome_zarr.create_name_plate_A01(5, 11) == 'E11'\n</code></pre>"},{"location":"testing/#tests.test_ome_zarr.test_create_name_row_col","title":"<code>test_create_name_row_col()</code>","text":"<p>Test <code>ome_zarr.create_name_row_col</code> function.</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>def test_create_name_row_col():\n\"\"\"Test `ome_zarr.create_name_row_col` function.\"\"\"\nwith pytest.raises(Exception) as e_info:\nome_zarr.create_name_row_col(1)\nwith pytest.raises(Exception) as e_info:\nome_zarr.create_name_row_col(1, 2, 3)\nassert ome_zarr.create_name_row_col(1, 2) == '1_2'\nassert ome_zarr.create_name_row_col(3, 4) == '3_4'\n</code></pre>"},{"location":"testing/#tests.test_ome_zarr.test_digest_bounding_box","title":"<code>test_digest_bounding_box(img2d)</code>","text":"<p>Test <code>Image._digest_bounding_box</code>.</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>def test_digest_bounding_box(img2d: ome_zarr.Image):\n\"\"\"Test `Image._digest_bounding_box`.\"\"\"\n# invalid input\nwith pytest.raises(Exception) as e_info: # unknown label\nimg2d._digest_bounding_box(label_name='error')\nwith pytest.raises(Exception) as e_info: # missing coordinates\nimg2d._digest_bounding_box(upper_left_yx=(5, 10))\nwith pytest.raises(Exception) as e_info: # wrong dimensions\nimg2d._digest_bounding_box(upper_left_yx=(5, 10, 10), size_yx=(1, 1, 1))\nwith pytest.raises(Exception) as e_info: # unknown pyramid level\nimg2d._digest_bounding_box(upper_left_yx=(5, 10), lower_right_yx=(20, 50), pyramid_level=7)\nwith pytest.raises(Exception) as e_info: # unknown coord pyramid level\nimg2d._digest_bounding_box(upper_left_yx=(5, 10), lower_right_yx=(20, 50), pyramid_level_coord=7, coordinate_unit='pixel')\nwith pytest.raises(Exception) as e_info: # unknown coordinate unit\nimg2d._digest_bounding_box(upper_left_yx=(5, 10), lower_right_yx=(20, 50), coordinate_unit = 'error')\n# expected results\n# ... full array\nassert img2d._digest_bounding_box(verbose=True) == [(0, 0), (270, 320)]\n# ... corners from different inputs\nassert img2d._digest_bounding_box(upper_left_yx=(5, 10),\nlower_right_yx=(20, 50),\ncoordinate_unit='pixel',\nverbose=True) == [(5, 10), (20, 50)]\nassert img2d._digest_bounding_box(upper_left_yx=(5, 10),\nsize_yx=(15, 40),\ncoordinate_unit='pixel',\nverbose=True) == [(5, 10), (20, 50)]\nassert img2d._digest_bounding_box(size_yx=(15, 40),\nlower_right_yx=(20, 50),\ncoordinate_unit='pixel',\nverbose=True) == [(5, 10), (20, 50)]\n# ... different pyramid levels\nassert img2d._digest_bounding_box(upper_left_yx=(5, 10),\nlower_right_yx=(20, 50),\npyramid_level=1,\npyramid_level_coord=2,\ncoordinate_unit='pixel') == [(10, 20), (40, 100)]\n# ... micrometer coordinates\ns = img2d.get_scale(pyramid_level=1)\nassert img2d._digest_bounding_box(upper_left_yx=(0, 0),\nlower_right_yx=(s[-2] * 1000, s[-1] * 1000),\npyramid_level=1,\ncoordinate_unit='micrometer') == [(0, 0), (1000, 1000)]\n# ... label array\nassert img2d._digest_bounding_box(label_name='organoids') == [(0, 0), (270, 320)]\n</code></pre>"},{"location":"testing/#tests.test_ome_zarr.test_digest_channels_labels","title":"<code>test_digest_channels_labels(img2d)</code>","text":"<p>Test <code>Image._digest_channels_labels</code>.</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>def test_digest_channels_labels(img2d: ome_zarr.Image):\n\"\"\"Test `Image._digest_channels_labels`.\"\"\"\n# invalid input\nwith pytest.raises(Exception) as e_info:\nimg2d._digest_channels_labels(None)\nwith pytest.raises(Exception) as e_info:\nimg2d._digest_channels_labels(['error'])\n# expected results\nassert img2d._digest_channels_labels(['some-label-1']) == [0]\nassert img2d._digest_channels_labels(['some-label-2', 'some-label-1']) == [1, 0]\n</code></pre>"},{"location":"testing/#tests.test_ome_zarr.test_digest_pyramid_level_argument","title":"<code>test_digest_pyramid_level_argument(img2d, img3d)</code>","text":"<p>Test <code>Image._digest_pyramid_level_argument</code>.</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>def test_digest_pyramid_level_argument(img2d: ome_zarr.Image, img3d: ome_zarr.Image):\n\"\"\"Test `Image._digest_pyramid_level_argument`.\"\"\"\n# invalid input\nwith pytest.raises(Exception) as e_info:\nimg2d._digest_pyramid_level_argument(6)\nwith pytest.raises(Exception) as e_info:\nimg2d._digest_pyramid_level_argument(None, 'error')\n# 2D image with labels    \nassert img2d._digest_pyramid_level_argument(None) == '2'\nassert img2d._digest_pyramid_level_argument(1, None) == '1'\nassert img2d._digest_pyramid_level_argument(1, 'organoids') == '1'\nassert img2d._digest_pyramid_level_argument('1', 'organoids') == '1'\nassert img2d._digest_pyramid_level_argument(None, 'organoids') == '2'\n# 3D image without labels\nassert img3d._digest_pyramid_level_argument(None) == '2'\nassert img3d._digest_pyramid_level_argument(1) == '1'\nassert img3d._digest_pyramid_level_argument('1', None) == '1'\n</code></pre>"},{"location":"testing/#tests.test_ome_zarr.test_extract_scale_spacings","title":"<code>test_extract_scale_spacings(img2d)</code>","text":"<p>Test <code>Image._extract_scale_spacings</code>.</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>def test_extract_scale_spacings(img2d: ome_zarr.Image):\n\"\"\"Test `Image._extract_scale_spacings`.\"\"\"\n# input with missing axes\nwith pytest.raises(Exception) as e_info:\nimg2d._extract_scale_spacings({})\n# example input\nassert img2d._extract_scale_spacings(img2d.multiscales_image['datasets'][0]) == [0, [1.0, 1.0, 0.1625, 0.1625]]\nassert img2d._extract_scale_spacings(img2d.multiscales_labels['organoids']['datasets'][1]) == [1, [1.0, 0.325, 0.325]]\n# synthetic input\nassert img2d._extract_scale_spacings(\n{'path': 11, 'coordinateTransformations': [{'scale': [1, 2.0, 3.25]}]}\n) == [11, [1.0, 2.0, 3.25]]\nassert img2d._extract_scale_spacings(\n{'path': 7, 'coordinateTransformations': [{'scale': [1, 2, 0.5]}]}\n) == [7, [1.0, 2.0, 0.5]]\n</code></pre>"},{"location":"testing/#tests.test_ome_zarr.test_find_path_of_highest_resolution_level","title":"<code>test_find_path_of_highest_resolution_level(img2d)</code>","text":"<p>Test <code>Image._find_path_of_highest_resolution_level</code>.</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>def test_find_path_of_highest_resolution_level(img2d: ome_zarr.Image):\n\"\"\"Test `Image._find_path_of_highest_resolution_level`.\"\"\"\n# non-existing label_name\nwith pytest.raises(Exception) as e_info:\nimg2d._find_path_of_highest_resolution_level(label_name='error')\n# example input\nassert img2d._find_path_of_highest_resolution_level(verbose=True) == '0'\nassert img2d._find_path_of_highest_resolution_level(label_name='organoids') == '0'\n</code></pre>"},{"location":"testing/#tests.test_ome_zarr.test_find_path_of_lowest_level","title":"<code>test_find_path_of_lowest_level(img2d)</code>","text":"<p>Test <code>Image._find_path_of_lowest_resolution_level</code>.</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>def test_find_path_of_lowest_level(img2d: ome_zarr.Image):\n\"\"\"Test `Image._find_path_of_lowest_resolution_level`.\"\"\"\n# non-existing label_name\nwith pytest.raises(Exception) as e_info:\nimg2d._find_path_of_lowest_resolution_level(label_name='error')\n# example input\nassert img2d._find_path_of_lowest_resolution_level(verbose=True) == '2'\nassert img2d._find_path_of_lowest_resolution_level(label_name='organoids') == '2'\n# synthetic input\nassert img2d._extract_paths_by_decreasing_resolution(\n[{'path': 0, 'coordinateTransformations': [{'scale': [0.2, 0.2, 0.2]}]},\n{'path': 1, 'coordinateTransformations': [{'scale': [0.1, 0.4, 0.1]}]}\n]) == ['1', '0']\nassert img2d._extract_paths_by_decreasing_resolution(\n[{'path': 0, 'coordinateTransformations': [{'scale': [0.1, 0.1]}]},\n{'path': 1, 'coordinateTransformations': [{'scale': [0.1, 0.2]}]}\n]) == ['0', '1']\n</code></pre>"},{"location":"testing/#tests.test_ome_zarr.test_get_array_by_coordinate","title":"<code>test_get_array_by_coordinate(img2d, img3d)</code>","text":"<p>Test <code>ome_zarr.Image</code> object get_array_by_coordinate() method.</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>def test_get_array_by_coordinate(img2d: ome_zarr.Image, img3d: ome_zarr.Image):\n\"\"\"Test `ome_zarr.Image` object get_array_by_coordinate() method.\"\"\"\n# invalid input\nwith pytest.raises(Exception) as e_info: # unknown label\nimg2d.get_array_by_coordinate('error')\nwith pytest.raises(Exception) as e_info: # missing coordinates\nimg2d.get_array_by_coordinate(upper_left_yx=(5, 10))\nwith pytest.raises(Exception) as e_info: # wrong dimensions\nimg2d.get_array_by_coordinate(upper_left_yx=(5, 10, 10), size_yx=(1, 1, 1))\nwith pytest.raises(Exception) as e_info: # unknown pyramid level\nimg2d.get_array_by_coordinate(upper_left_yx=(5, 10), lower_right_yx=(20, 50), pyramid_level = 7)\nwith pytest.raises(Exception) as e_info: # unknown coord pyramid level\nimg2d.get_array_by_coordinate(upper_left_yx=(5, 10), lower_right_yx=(20, 50), pyramid_level_coord = 7, coordinate_unit = 'pixel')\nwith pytest.raises(Exception) as e_info: # unknown coordinate unit\nimg2d.get_array_by_coordinate(upper_left_yx=(5, 10), lower_right_yx=(20, 50), coordinate_unit = 'error')\n# 2D image\nassert img2d.get_array_by_coordinate() == img2d.array_dict['2']\nimg0a = img2d.get_array_by_coordinate(\nupper_left_yx=None,\nlower_right_yx=None,\nsize_yx=None,\npyramid_level=2,\nas_NumPy=False)\nimg0b = img2d.get_array_by_coordinate(\nupper_left_yx=(0, 0),\nlower_right_yx=(269, 319),\nsize_yx=None,\npyramid_level=2,\nas_NumPy=True)\nassert isinstance(img0a, zarr.Array)\nassert isinstance(img0b, np.ndarray)\nassert img0a.shape == (2, 1, 270, 320)\nassert (np.array(img0a) == img0b).all()\nimg1a = img3d.get_array_by_coordinate(\nupper_left_yx=(22, 20),\nlower_right_yx=(44, 40),\nsize_yx=None,\ncoordinate_unit='pixel',\npyramid_level=1,\npyramid_level_coord=0,\nas_NumPy=True)\nimg1b = img3d.get_array_by_coordinate(\nupper_left_yx=(11, 10),\nlower_right_yx=None,\nsize_yx=(11, 10),\ncoordinate_unit='pixel',\npyramid_level=1,\nas_NumPy=True)\nimg1c = img3d.get_array_by_coordinate(\nupper_left_yx=None,\nlower_right_yx=(22, 20),\nsize_yx=(11, 10),\ncoordinate_unit='pixel',\npyramid_level=1,\nas_NumPy=True)\nassert isinstance(img1a, np.ndarray)\nassert isinstance(img1b, np.ndarray)\nassert isinstance(img1c, np.ndarray)\nassert img1a.shape == (2, 3, 11, 10)\nassert img1b.shape == img1a.shape\nassert img1c.shape == img1a.shape\nassert (img1b == img1a).all()\nassert (img1c == img1a).all()\nimg2a = img2d.get_array_by_coordinate(\nlabel_name='organoids',\nupper_left_yx=(0, 0),\nlower_right_yx=(11, 10),\nsize_yx=None,\ncoordinate_unit='micrometer',\npyramid_level=0,\nas_NumPy=True)\nimg2b = img2d.get_array_by_coordinate(\nlabel_name='organoids',\nupper_left_yx=None,\nlower_right_yx=(11, 10),\nsize_yx=(11, 10),\ncoordinate_unit='micrometer',\npyramid_level=0,\nas_NumPy=True)\nassert isinstance(img2a, np.ndarray)\nassert isinstance(img2b, np.ndarray)\nexpected_shape = np.divide(\n[1, 11, 10], # size z, y, x in micrometer\nimg2d.get_scale(0, 'organoids'))\nexpected_shape = tuple([int(round(x)) for x in expected_shape])\nassert img2a.shape == expected_shape\nassert img2b.shape == img2a.shape\nassert (img1b == img1a).all()\nassert (img1c == img1a).all()\n</code></pre>"},{"location":"testing/#tests.test_ome_zarr.test_get_array_pair_by_coordinate","title":"<code>test_get_array_pair_by_coordinate(tmpdir)</code>","text":"<p>Test <code>ome_zarr.Image</code> object get_array_pair_by_coordinate() method.</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>def test_get_array_pair_by_coordinate(tmpdir: str):\n\"\"\"Test `ome_zarr.Image` object get_array_pair_by_coordinate() method.\"\"\"\n# using pyramid_level corresponding to a lower resolution intensity image\n#     than any available label resolutions\n# ... copy zarr fileset\nassert tmpdir.check()\nshutil.copytree('tests/example_data/plate_ones_mip.zarr/B/03/0',\nstr(tmpdir) + '/example_img')\nassert tmpdir.join('/example_img/1').check()\n# ... remove pyramid level 2 from label organoids\nshutil.rmtree(str(tmpdir) + '/example_img/labels/organoids/2')\nzattr_file = str(tmpdir) + '/example_img/labels/organoids/.zattrs'\nwith open(zattr_file) as f:\nzattr = json.load(f)\nzattr['multiscales'][0]['datasets'] = zattr['multiscales'][0]['datasets'][:2]\nwith open(zattr_file, \"w\") as jsonfile:\njson.dump(zattr, jsonfile, indent=4)\n# ... extract array pair\nimgtmp = ome_zarr.Image(str(tmpdir) + '/example_img')\nwith pytest.raises(Exception) as e_info:\nimgtmp.get_array_pair_by_coordinate(pyramid_level='2', label_name='organoids')\n# ... clean up\nshutil.rmtree(str(tmpdir) + '/example_img')\n# expected return values with multiple label_name values\n# ... copy zarr fileset\nassert tmpdir.check()\nshutil.copytree('tests/example_data/plate_ones_mip.zarr/B/03/0',\nstr(tmpdir) + '/example_img')\nassert tmpdir.join('/example_img/1').check()\nshutil.copytree(str(tmpdir) + '/example_img/labels/organoids',\nstr(tmpdir) + '/example_img/labels/cells')\n# ... initialize Image object\nimg2d = ome_zarr.Image(str(tmpdir) + '/example_img')\n# ... extract array pair\nimg, lab = img2d.get_array_pair_by_coordinate(label_name=['organoids', 'cells'])\nassert isinstance(img, np.ndarray)\nassert isinstance(lab, dict)\nassert list(lab.keys()) == ['organoids', 'cells']\nassert isinstance(lab['organoids'], np.ndarray)\nassert isinstance(lab['cells'], np.ndarray)\n# ... clean up\nshutil.rmtree(str(tmpdir) + '/example_img')\n</code></pre>"},{"location":"testing/#tests.test_ome_zarr.test_get_bounding_box_for_label_value","title":"<code>test_get_bounding_box_for_label_value(img2d)</code>","text":"<p>Test <code>Image.get_bounding_box_for_label_value</code>.</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>def test_get_bounding_box_for_label_value(img2d: ome_zarr.Image):\n\"\"\"Test `Image.get_bounding_box_for_label_value`.\"\"\"\n# available label values\nassert img2d.get_bounding_box_for_label_value(label_value=0, label_name='organoids', label_pyramid_level='2', label_name_output='organoids', pyramid_level_output='2') == ((0, 0, 0), (1, 270, 320))\nassert img2d.get_bounding_box_for_label_value(label_value=1, label_name='organoids', label_pyramid_level='0', label_name_output='organoids', pyramid_level_output='0') == ((0, 200, 100), (1, 401, 301))\nassert img2d.get_bounding_box_for_label_value(label_value=2, label_name='organoids', label_pyramid_level='0', label_name_output='organoids', pyramid_level_output='0') == ((0, 600, 0), (1, 1001, 401))\nassert img2d.get_bounding_box_for_label_value(label_value=3, label_name='organoids', label_pyramid_level='0', label_name_output='organoids', pyramid_level_output='0') == ((0, 400, 400), (1, 1001, 1001))\nwith pytest.raises(Exception) as e_info:\nimg2d.get_bounding_box_for_label_value(label_value=4, label_name='organoids', label_pyramid_level='0', label_name_output='organoids', pyramid_level_output='0')\n</code></pre>"},{"location":"testing/#tests.test_ome_zarr.test_get_channels","title":"<code>test_get_channels(img3d)</code>","text":"<p>Test <code>get_channels()</code> method of <code>ome_zarr.Image</code> object.</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>def test_get_channels(img3d: ome_zarr.Image):\n\"\"\"Test `get_channels()` method of `ome_zarr.Image` object.\"\"\"\nassert isinstance(img3d.get_channels(), list)\nassert all([isinstance(x, dict) for x in img3d.get_channels()])\nassert all(['label' in x for x in img3d.get_channels()])\n</code></pre>"},{"location":"testing/#tests.test_ome_zarr.test_get_label_names","title":"<code>test_get_label_names(img2d)</code>","text":"<p>Test <code>get_label_names()</code> method of <code>ome_zarr.Image</code> object.</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>def test_get_label_names(img2d: ome_zarr.Image):\n\"\"\"Test `get_label_names()` method of `ome_zarr.Image` object.\"\"\"\nassert img2d.get_label_names() == ['organoids']\nassert img2d.get_label_names() == img2d.label_names\n</code></pre>"},{"location":"testing/#tests.test_ome_zarr.test_get_path","title":"<code>test_get_path(img2d)</code>","text":"<p>Test <code>get_path()</code> method of <code>ome_zarr.Image</code> object.</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>def test_get_path(img2d: ome_zarr.Image):\n\"\"\"Test `get_path()` method of `ome_zarr.Image` object.\"\"\"\nassert img2d.get_path().replace(\"\\\\\", \"/\") == 'tests/example_data/plate_ones_mip.zarr/B/03/0'\nassert img2d.get_path() == img2d.path\n</code></pre>"},{"location":"testing/#tests.test_ome_zarr.test_get_pyramid_levels","title":"<code>test_get_pyramid_levels(img2d, img3d)</code>","text":"<p>Test <code>get_pyramid_levels()</code> method of <code>ome_zarr.Image</code> object.</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>def test_get_pyramid_levels(img2d: ome_zarr.Image, img3d: ome_zarr.Image):\n\"\"\"Test `get_pyramid_levels()` method of `ome_zarr.Image` object.\"\"\"\nassert img2d.get_pyramid_levels() == ['0', '1', '2']\nassert img2d.get_pyramid_levels(None) == ['0', '1', '2']\nassert img2d.get_pyramid_levels('organoids') == ['0', '1', '2']\nassert img3d.get_pyramid_levels() == ['0', '1', '2']\n</code></pre>"},{"location":"testing/#tests.test_ome_zarr.test_get_scale","title":"<code>test_get_scale(img2d, img3d)</code>","text":"<p>Test <code>ome_zarr.Image</code> object get_scale() method.</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>def test_get_scale(img2d: ome_zarr.Image, img3d: ome_zarr.Image):\n\"\"\"Test `ome_zarr.Image` object get_scale() method.\"\"\"\n# invalid input\nwith pytest.raises(Exception) as e_info:\nimg2d.get_scale()\nwith pytest.raises(Exception) as e_info:\nimg2d.get_scale(7)\nwith pytest.raises(Exception) as e_info:\nimg2d.get_scale(1, 'error')\n# 2D image with labels\nassert img2d.get_scale(0) == [1.0, 1.0, 0.1625, 0.1625]\nassert img2d.get_scale('1') == [1.0, 1.0, 0.325, 0.325]\nassert img2d.get_scale(2) == [1.0, 1.0, 0.65, 0.65]\nassert img2d.get_scale(0, 'organoids') == [1.0, 0.1625, 0.1625]\nassert img2d.get_scale('1', 'organoids') == [1.0, 0.325, 0.325]\nassert img2d.get_scale(2, 'organoids') == [1.0, 0.65, 0.65]\nassert img2d.get_scale(2, 'organoids', True) == [1.0, 0.65, 0.65]\n# 3D image\nassert img3d.get_scale(0) == [1.0, 1.0, 0.1625, 0.1625]\nassert img3d.get_scale('1') == [1.0, 1.0, 0.325, 0.325]\nassert img3d.get_scale(2) == [1.0, 1.0, 0.65, 0.65]\nassert img3d.get_scale(2, spatial_axes_only=True) == [1.0, 0.65, 0.65]\n</code></pre>"},{"location":"testing/#tests.test_ome_zarr.test_get_table","title":"<code>test_get_table(img2d)</code>","text":"<p>Test <code>Image.get_table()</code>.</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>def test_get_table(img2d: ome_zarr.Image):\n\"\"\"Test `Image.get_table()`.\"\"\"\n# invalid input\nwith pytest.warns(UserWarning):\nassert img2d.get_table('error') is None\n# table as AnnData\nres1 = img2d.get_table(table_name='FOV_ROI_table',\nas_AnnData=True)\nassert isinstance(res1, ad.AnnData)\nassert res1.shape == (4, 8)\n# table as pandas.DataFrame\nres2 = img2d.get_table(table_name='FOV_ROI_table',\nas_AnnData=False)\nassert isinstance(res2, pd.DataFrame)\nassert res2.shape == (4, 8)\n</code></pre>"},{"location":"testing/#tests.test_ome_zarr.test_get_table_names","title":"<code>test_get_table_names(img3d)</code>","text":"<p>Test <code>get_table_names()</code> method of <code>ome_zarr.Image</code> object.</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>def test_get_table_names(img3d: ome_zarr.Image):\n\"\"\"Test `get_table_names()` method of `ome_zarr.Image` object.\"\"\"\nassert img3d.get_table_names() == ['FOV_ROI_table']\nassert img3d.get_table_names() == img3d.table_names\n</code></pre>"},{"location":"testing/#tests.test_ome_zarr.test_image_str","title":"<code>test_image_str(img2d, img3d)</code>","text":"<p>Test <code>ome_zarr.Image</code> object string representation.</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>def test_image_str(img2d: ome_zarr.Image, img3d: ome_zarr.Image):\n\"\"\"Test `ome_zarr.Image` object string representation.\"\"\"\nassert str(img2d) == repr(img2d)\nassert str(img3d) == repr(img3d)\n</code></pre>"},{"location":"testing/#tests.test_ome_zarr.test_imagelist_get_layout","title":"<code>test_imagelist_get_layout(imgL2)</code>","text":"<p>Test <code>ome_zarr.ImageList.get_layout</code>.</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>def test_imagelist_get_layout(imgL2: ome_zarr.ImageList):\n\"\"\"Test `ome_zarr.ImageList.get_layout`.\"\"\"\nassert imgL2.get_layout().to_dict() == imgL2.layout.to_dict()\nassert isinstance(imgL2.get_layout(), pd.DataFrame)\nassert len(imgL2) == imgL2.get_layout().shape[0]\n</code></pre>"},{"location":"testing/#tests.test_ome_zarr.test_imagelist_get_names","title":"<code>test_imagelist_get_names(imgL2)</code>","text":"<p>Test <code>ome_zarr.ImageList.get_names</code>.</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>def test_imagelist_get_names(imgL2: ome_zarr.ImageList):\n\"\"\"Test `ome_zarr.ImageList.get_names`.\"\"\"\nassert imgL2.get_names() == imgL2.names\nassert len(imgL2) == len(imgL2.get_names())\n</code></pre>"},{"location":"testing/#tests.test_ome_zarr.test_imagelist_get_paths","title":"<code>test_imagelist_get_paths(imgL2)</code>","text":"<p>Test <code>ome_zarr.ImageList.get_paths</code>.</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>def test_imagelist_get_paths(imgL2: ome_zarr.ImageList):\n\"\"\"Test `ome_zarr.ImageList.get_paths`.\"\"\"\nassert imgL2.get_paths() == imgL2.paths\nassert len(imgL2) == len(imgL2.get_paths())\n</code></pre>"},{"location":"testing/#tests.test_ome_zarr.test_imagelist_getattr","title":"<code>test_imagelist_getattr(imgL)</code>","text":"<p>Test <code>ome_zarr.ImageList</code> getting attributes of contained Image objects.</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>def test_imagelist_getattr(imgL: ome_zarr.ImageList):\n\"\"\"Test `ome_zarr.ImageList` getting attributes of contained Image objects.\"\"\"\n# non-existing attribute\nwith pytest.raises(Exception) as e_info:\nimgL.get_nonexisting\nwith pytest.raises(Exception) as e_info:\nimgL.get_nonexisting()\n# simple attributes\nassert isinstance(imgL.name, list)\nassert imgL.name == imgL.get_names()\nassert imgL.path == imgL.get_paths()\n# callable attributes\nassert imgL.get_scale('0') == [img.get_scale('0') for img in imgL.images]\nassert imgL.get_table_names() == [img.get_table_names() for img in imgL.images]\n</code></pre>"},{"location":"testing/#tests.test_ome_zarr.test_imagelist_getitem","title":"<code>test_imagelist_getitem(imgL)</code>","text":"<p>Test <code>ome_zarr.ImageList</code> subsetting.</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>def test_imagelist_getitem(imgL: ome_zarr.ImageList):\n\"\"\"Test `ome_zarr.ImageList` subsetting.\"\"\"\nassert isinstance(imgL[0], ome_zarr.Image)\nnm = imgL.names[0]\nassert isinstance(imgL[nm], ome_zarr.Image)\nassert imgL[0] == imgL[nm]\nassert str(imgL) == str(imgL[[0]])\nassert str(imgL) == str(imgL[[nm]])\nimgL2 = imgL[[0, 0]]\nassert isinstance(imgL2, ome_zarr.ImageList)\nassert len(imgL2) == 2\nassert imgL2.get_names() == [nm, nm]\nwith pytest.raises(Exception) as e_info:\nimgL2[nm]\nwith pytest.raises(Exception) as e_info:\nimgL2[[nm, nm]]\nimgLnolayout = imgL\nimgLnolayout.layout = None\nimgL3 = imgLnolayout[[0, 0]]\nassert len(imgL3) == 2\nassert isinstance(imgL3.layout, pd.DataFrame)\n</code></pre>"},{"location":"testing/#tests.test_ome_zarr.test_imagelist_plot","title":"<code>test_imagelist_plot(imgL2, tmpdir)</code>","text":"<p>Test <code>ome_zarr.ImageList.plot</code>.</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>def test_imagelist_plot(imgL2: ome_zarr.ImageList, tmpdir: str):\n\"\"\"Test `ome_zarr.ImageList.plot`.\"\"\"\nimgL3 = imgL2\nimgL3.layout.loc[:, 'row_index'] = [1, 1]\nimgL3.layout.loc[:, 'column_index'] = [1, 1]\nwith pytest.raises(Exception) as e_info:\nimgL3.plot()\nimgL2.set_layout(nrow=3)\nmatplotlib.use('Agg')  # Use the 'Agg' backend, which doesn't need a display\nwith warnings.catch_warnings():\n# suppress warning due to cannot show FigureCanvas\nwarnings.simplefilter('ignore')\n# basic plot (no argument)\nimgL2.plot()\n# with known arguments\nimgL2.plot(fig_title = \"test\",\nfig_width_inch=6,\nfig_height_inch=4,\nfig_dpi=100,\nfig_style='brightfield',\nverbose=True)\n# with unknown arguments\nimgL2.plot(label_name = \"organoids\",\naxis_style='frame')\nplt.savefig(tmpdir.join('output.png'))\nassert True # check if the plotting ran through\n</code></pre>"},{"location":"testing/#tests.test_ome_zarr.test_imagelist_set_layout","title":"<code>test_imagelist_set_layout(imgL2)</code>","text":"<p>Test <code>ome_zarr.ImageList.set_layout</code>.</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>def test_imagelist_set_layout(imgL2: ome_zarr.ImageList):\n\"\"\"Test `ome_zarr.ImageList.set_layout`.\"\"\"\ndf = copy.deepcopy(imgL2.get_layout())\nassert isinstance(df, pd.DataFrame)\nassert df.columns.to_list() == ['row_index', 'column_index']\nwith pytest.raises(Exception) as e_info:\nimgL2.set_layout(df.iloc[[0]])\ndf['row_index'] = [4, 5]\nimgL2.set_layout(layout=df)\nassert imgL2.get_layout().to_dict() == df.to_dict()\nimgL2.set_layout(nrow=7)\nassert imgL2.nrow == 7\nimgL2.set_layout(ncol=4, by_row=True)\nassert imgL2.ncol == 4\nimgL2.set_layout(nrow = 2, reset_names=True)\nassert imgL2.get_names() == ['1_1', '2_1']\nwith pytest.warns(UserWarning):\nimgL2.set_layout(layout='grid', nrow=2)\nassert isinstance(imgL2.get_layout(), pd.DataFrame)\nwith pytest.raises(Exception) as e_info:\nimgL2.set_layout(layout='error')\n</code></pre>"},{"location":"testing/#tests.test_ome_zarr.test_imagelist_str","title":"<code>test_imagelist_str(imgL)</code>","text":"<p>Test <code>ome_zarr.ImageList</code> object string representation.</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>def test_imagelist_str(imgL: ome_zarr.ImageList):\n\"\"\"Test `ome_zarr.ImageList` object string representation.\"\"\"\nassert str(imgL) == repr(imgL)\nassert str(imgL).startswith('ImageList of 1 image')\nimgLmod = imgL\nimgLmod.names = [''.join(imgL.names * 50)]\nimgLmod.paths = ['/'.join(imgL.paths * 5)]\nassert str(imgLmod) == repr(imgLmod)\n</code></pre>"},{"location":"testing/#tests.test_ome_zarr.test_import_plate","title":"<code>test_import_plate(tmpdir)</code>","text":"<p>Test <code>import_plate</code> function.</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>def test_import_plate(tmpdir: str):\n\"\"\"Test `import_plate` function.\"\"\"\nwith pytest.raises(Exception) as e_info:\nome_zarr.import_plate()\nwith pytest.raises(Exception) as e_info:\nome_zarr.import_plate('tests/example_data')\nimgL = ome_zarr.import_plate('tests/example_data/plate_ones_mip.zarr')\nassert isinstance(imgL, ome_zarr.ImageList)\nassert len(imgL) == 1\nassert imgL.names == ['B03']\nassert [x.replace(\"\\\\\", \"/\") for x in imgL.paths] == ['tests/example_data/plate_ones_mip.zarr/B/03/0']\nassert imgL.nrow == 2\nassert imgL.ncol == 3\nassert imgL.layout.to_dict() == {'row_index': {0: 2}, 'column_index': {0: 3}}\nshutil.copytree('tests/example_data/plate_ones_mip.zarr',\nstr(tmpdir) + '/example_img')\nassert tmpdir.join('/example_img/.zattrs').check()\nshutil.move(str(tmpdir) + '/example_img/B/03',\nstr(tmpdir) + '/example_img/B/10')\nwith pytest.raises(Exception) as e_info:\nwith pytest.warns(UserWarning):\nimgL2 = ome_zarr.import_plate(str(tmpdir) + '/example_img')\n# add B10 to omero attributes\nzattr_file = str(tmpdir) + '/example_img/.zattrs'\nwith open(zattr_file) as f:\nzattr = json.load(f)\nzattr['plate']['columns'].append({'name': '10'})\nzattr['plate']['wells'].append({'columnIndex': 1, 'path': 'B/10', 'rowIndex': 0})\nwith open(zattr_file, \"w\") as jsonfile:\njson.dump(zattr, jsonfile, indent=4)\nwith pytest.warns(UserWarning):\nimgL2 = ome_zarr.import_plate(str(tmpdir) + '/example_img')\nassert imgL2.nrow == 8\nassert imgL2.ncol == 12\nshutil.copytree('tests/example_data/plate_ones_mip.zarr',\nstr(tmpdir) + '/example_img_multi')\nassert tmpdir.join('/example_img_multi/.zattrs').check()\nshutil.copytree(str(tmpdir) + '/example_img_multi/B/03',\nstr(tmpdir) + '/example_img_multi/C/02')\nshutil.copytree(str(tmpdir) + '/example_img_multi/B/03',\nstr(tmpdir) + '/example_img_multi/G/06')\nimgL3 = ome_zarr.import_plate(str(tmpdir) + '/example_img_multi', \nverbose=True)\nassert len(imgL3) == 1\nassert imgL3.names == ['B03']\n# add additional images to metadata\nzattr_file = str(tmpdir) + '/example_img_multi/.zattrs'\nwith open(zattr_file) as f:\nzattr = json.load(f)\nzattr['plate']['columns'].append({'name': '02'})\nzattr['plate']['rows'].append({'name': 'C'})\nzattr['plate']['wells'].append({'columnIndex': 1, 'path': 'C/02', 'rowIndex': 1})\nzattr['plate']['columns'].append({'name': '06'})\nzattr['plate']['rows'].append({'name': 'G'})\nzattr['plate']['wells'].append({'columnIndex': 2, 'path': 'G/06', 'rowIndex': 2})\nwith open(zattr_file, \"w\") as jsonfile:\njson.dump(zattr, jsonfile, indent=4)\nimgL3 = ome_zarr.import_plate(str(tmpdir) + '/example_img_multi')\nassert imgL3.nrow == 8\nassert imgL3.ncol == 12\nassert imgL3.layout.row_index.tolist() == [2, 3, 7]\nassert imgL3.layout.column_index.tolist() == [3, 2, 6]\nassert imgL3['B03'].get_path().replace(\"\\\\\", \"/\") == str(tmpdir).replace(\"\\\\\", \"/\") + '/example_img_multi/B/03/0'\nassert imgL3['C02'].get_path().replace(\"\\\\\", \"/\") == str(tmpdir).replace(\"\\\\\", \"/\") + '/example_img_multi/C/02/0'\nassert imgL3['G06'].get_path().replace(\"\\\\\", \"/\") == str(tmpdir).replace(\"\\\\\", \"/\") + '/example_img_multi/G/06/0'\nassert [x.replace(\"\\\\\", \"/\") for x in imgL3.paths] == [str(tmpdir).replace(\"\\\\\", \"/\") + '/example_img_multi/B/03/0', str(tmpdir).replace(\"\\\\\", \"/\") + '/example_img_multi/C/02/0', str(tmpdir).replace(\"\\\\\", \"/\") + '/example_img_multi/G/06/0']\nassert imgL3.names == ['B03', 'C02', 'G06']\n</code></pre>"},{"location":"testing/#tests.test_ome_zarr.test_load_axes_unit","title":"<code>test_load_axes_unit(img2d)</code>","text":"<p>Test <code>Image._load_axes_unit</code>.</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>def test_load_axes_unit(img2d: ome_zarr.Image):\n\"\"\"Test `Image._load_axes_unit`.\"\"\"\n# missing unit\nmultiscale_dict = copy.deepcopy(img2d.multiscales_image)\ndel multiscale_dict['axes'][1]['unit']\ndel multiscale_dict['axes'][2]['unit']\ndel multiscale_dict['axes'][3]['unit']\nassert img2d._load_axes_unit(multiscale_dict) == 'pixel'\n# unsupported unit\nmultiscale_dict = copy.deepcopy(img2d.multiscales_image)\nmultiscale_dict['axes'][2]['unit'] = 'parsec'\nwith pytest.raises(Exception) as e_info:\nimg2d._load_axes_unit(multiscale_dict)\n# test loading\n# ... inensity image\nout_axes_unit_image = img2d._load_axes_unit(img2d.multiscales_image, \nverbose=True)\nassert out_axes_unit_image == 'micrometer'\n# ... labels\nout_axes_unit_labels = {x: img2d._load_axes_unit(img2d.multiscales_labels[x]) for x in img2d.label_names}\nassert 'organoids' in out_axes_unit_labels\nassert out_axes_unit_labels['organoids'] == 'micrometer'\n</code></pre>"},{"location":"testing/#tests.test_ome_zarr.test_load_channel_info","title":"<code>test_load_channel_info(img3d, img2d, img4d)</code>","text":"<p>Test <code>Image._load_channel_info</code>.</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>def test_load_channel_info(img3d: ome_zarr.Image, img2d: ome_zarr.Image, img4d: ome_zarr.Image):\n\"\"\"Test `Image._load_channel_info`.\"\"\"\n# input with missing axes\nwith pytest.raises(Exception) as e_info:\nimg3d._load_channel_info({})\n# example input\nassert img2d._load_channel_info(img2d.multiscales_image) == 'czyx'\nassert img3d._load_channel_info(img3d.multiscales_image) == 'czyx'\nassert img4d._load_channel_info(img4d.multiscales_image) == 'tczyx'\n# synthetic input\nassert img2d._load_channel_info(\n{'axes': [{'name': 'day', 'type': 'time'},\n{'name': 'c', 'type': 'channel'},\n{'name': 'y', 'type': 'space'},\n{'name': 'x', 'type': 'space'}]}) == 'tcyx'\nassert img2d._load_channel_info(\n{'axes': [{'name': 'c', 'type': 'channel'},\n{'name': 'y', 'type': 'space'},\n{'name': 'x', 'type': 'space'}]}) == 'cyx'\nassert img2d._load_channel_info(\n{'axes': [{'name': 'y', 'type': 'space'},\n{'name': 'x', 'type': 'space'}]}) == 'yx'\n</code></pre>"},{"location":"testing/#tests.test_ome_zarr.test_load_multiscale_info","title":"<code>test_load_multiscale_info(img2d, img3dv3, tmpdir)</code>","text":"<p>Test <code>Image._load_multiscale_info</code>.</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>def test_load_multiscale_info(img2d: ome_zarr.Image, img3dv3: ome_zarr.Image, tmpdir: str):\n\"\"\"Test `Image._load_multiscale_info`.\"\"\"\n# missing multiscales attributes\n# ... copy zarr fileset\nassert tmpdir.check()\nshutil.copytree('tests/example_data/plate_ones_mip.zarr/B/03/0',\nstr(tmpdir) + '/example_img')\nassert tmpdir.join('/example_img/.zattrs').check()\n# ... copy original .zattrs\nzattr_file = str(tmpdir) + '/example_img/.zattrs'\nshutil.copyfile(zattr_file, str(tmpdir) + 'zattr.orig')\n# ... remove multiscales attributes from copy\nwith open(zattr_file) as f:\nzattr = json.load(f)\ndel zattr['multiscales']\nwith open(zattr_file, \"w\") as jsonfile:\njson.dump(zattr, jsonfile, indent=4)\n# ... test loading\nwith pytest.raises(Exception) as e_info:\nome_zarr.Image(str(tmpdir) + '/example_img')\n# ... restore original .zattrs\nshutil.move(str(tmpdir) + 'zattr.orig', zattr_file)\n# missing label multiscales attrs\nassert tmpdir.join('/example_img/labels/organoids/.zattrs').check()\n# ... copy original .zattrs\nzattr_file = str(tmpdir) + '/example_img/labels/organoids/.zattrs'\nshutil.copyfile(zattr_file, str(tmpdir) + 'zattr.orig')\n# ... remove multiscales attributes from copy\nwith open(zattr_file) as f:\nzattr = json.load(f)\ndel zattr['multiscales']\nwith open(zattr_file, \"w\") as jsonfile:\njson.dump(zattr, jsonfile, indent=4)\n# ... test loading\nwith pytest.raises(Exception) as e_info:\nome_zarr.Image(str(tmpdir) + '/example_img')\n# ... restore original .zattrs\nshutil.move(str(tmpdir) + 'zattr.orig', zattr_file)\n# multiple multiscales dictionaries\nassert tmpdir.join('/example_img/.zattrs').check()\n# ... copy original .zattrs\nzattr_file = str(tmpdir) + '/example_img/.zattrs'\nshutil.copyfile(zattr_file, str(tmpdir) + 'zattr.orig')\n# ... duplicate multiscales attributes in copy\nwith open(zattr_file) as f:\nzattr = json.load(f)\nzattr['multiscales'].append(zattr['multiscales'][0])\nwith open(zattr_file, \"w\") as jsonfile:\njson.dump(zattr, jsonfile, indent=4)\n# ... test loading\nwith pytest.warns(UserWarning):\nome_zarr.Image(str(tmpdir) + '/example_img')\n# ... restore original .zattrs\nshutil.move(str(tmpdir) + 'zattr.orig', zattr_file)\n# missing axes in multiscales attrs\nassert tmpdir.join('/example_img/.zattrs').check()\n# ... copy original .zattrs\nzattr_file = str(tmpdir) + '/example_img/.zattrs'\nshutil.copyfile(zattr_file, str(tmpdir) + 'zattr.orig')\n# ... remove axes multiscales attributes in copy\nwith open(zattr_file) as f:\nzattr = json.load(f)\ndel zattr['multiscales'][0]['axes']\nwith open(zattr_file, \"w\") as jsonfile:\njson.dump(zattr, jsonfile, indent=4)\n# ... test loading\nwith pytest.raises(Exception) as e_info:\nome_zarr.Image(str(tmpdir) + '/example_img')\n# ... restore original .zattrs\nshutil.move(str(tmpdir) + 'zattr.orig', zattr_file)\n# missing multiscales attributes, Zarr v3\n# ... copy zarr fileset\nassert tmpdir.check()\nshutil.copytree('tests/example_data_zarr3/6001240_labels_v0.5.zarr',\nstr(tmpdir) + '/example_img_v3')\nassert tmpdir.join('/example_img_v3/zarr.json').check()\n# ... copy original zarr.json\nzjson_file = str(tmpdir) + '/example_img_v3/zarr.json'\nshutil.copyfile(zjson_file, str(tmpdir) + 'zjson.orig')\n# ... remove multiscales attributes from copy\nwith open(zjson_file) as f:\nzattr = json.load(f)\ndel zattr['attributes']['ome']['multiscales']\nwith open(zjson_file, \"w\") as jsonfile:\njson.dump(zattr, jsonfile, indent=4)\n# ... test loading\nwith pytest.raises(Exception) as e_info:\nome_zarr.Image(str(tmpdir) + '/example_img_v3')\n# ... restore original zarr.json\nshutil.move(str(tmpdir) + 'zjson.orig', zjson_file)\n# multiple multiscales dictionaries, Zarr v3\nassert tmpdir.join('/example_img_v3/zarr.json').check()\n# ... copy original zarr.json\nzjson_file = str(tmpdir) + '/example_img_v3/zarr.json'\nshutil.copyfile(zjson_file, str(tmpdir) + 'zjson.orig')\n# ... duplicate multiscales attributes in copy\nwith open(zjson_file) as f:\nzattr = json.load(f)\nzattr['attributes']['ome']['multiscales'].append(zattr['attributes']['ome']['multiscales'][0])\nwith open(zjson_file, \"w\") as jsonfile:\njson.dump(zattr, jsonfile, indent=4)\n# ... test loading\nwith pytest.warns(UserWarning):\nome_zarr.Image(str(tmpdir) + '/example_img_v3')\n# ... restore original zarr.json\nshutil.move(str(tmpdir) + 'zjson.orig', zjson_file)\n# test loading\n# ... intensity image\nout_multiscales_image = img2d._load_multiscale_info(img2d.zarr_group, False)\nassert isinstance(out_multiscales_image, dict)\nassert 'axes' in out_multiscales_image\nassert 'datasets' in out_multiscales_image\nassert isinstance(out_multiscales_image['axes'], list)\nassert isinstance(out_multiscales_image['datasets'], list)\n# ... labels\nout_multiscales_labels = {x: img2d._load_multiscale_info(img2d.zarr_group[\"labels\"][x], False) for x in img2d.label_names}\nassert 'organoids' in out_multiscales_labels\nassert isinstance(out_multiscales_labels['organoids'], dict)\nassert 'axes' in out_multiscales_labels['organoids']\nassert 'datasets' in out_multiscales_labels['organoids']\nassert isinstance(out_multiscales_labels['organoids']['axes'], list)\nassert isinstance(out_multiscales_labels['organoids']['datasets'], list)\n# ... Zarr v3 intensity image\nout_multiscales_image = img3dv3._load_multiscale_info(img3dv3.zarr_group, False)\nassert isinstance(out_multiscales_image, dict)\nassert 'axes' in out_multiscales_image\nassert 'datasets' in out_multiscales_image\nassert isinstance(out_multiscales_image['axes'], list)\nassert isinstance(out_multiscales_image['datasets'], list)\n# ... Zarr v3 labels\nout_multiscales_labels = {x: img3dv3._load_multiscale_info(img3dv3.zarr_group[\"labels\"][x], False) for x in img3dv3.label_names}\nassert '0' in out_multiscales_labels\nassert isinstance(out_multiscales_labels['0'], dict)\nassert 'axes' in out_multiscales_labels['0']\nassert 'datasets' in out_multiscales_labels['0']\nassert isinstance(out_multiscales_labels['0']['axes'], list)\nassert isinstance(out_multiscales_labels['0']['datasets'], list)\n</code></pre>"},{"location":"testing/#tests.test_ome_zarr.test_plot","title":"<code>test_plot(img2d, img4d, img3dv3, tmpdir)</code>","text":"<p>Test <code>Image.plot()</code>.</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>def test_plot(img2d: ome_zarr.Image, img4d: ome_zarr.Image, img3dv3: ome_zarr.Image, tmpdir: str):\n\"\"\"Test `Image.plot()`.\"\"\"\nmatplotlib.use('Agg')  # Use the 'Agg' backend, which doesn't need a display\nwith warnings.catch_warnings():\n# suppress warning due to cannot show FigureCanvas\nwarnings.simplefilter('ignore')\n# using channels_labels\nimg2d.plot(label_name=None,\npyramid_level=None,\npyramid_level_coord=None,\nchannels_labels=['some-label-1'],\nchannel_colors=['white'],\nchannel_ranges=[[0.01, 0.99]],\nz_projection_method='maximum',\nscalebar_micrometer=50,\nshow_scalebar_label=True)\n# unknown channel label\nwith pytest.raises(Exception) as e_info:\nimg2d.plot(channels_labels=['error'],\npyramid_level_coord=2)\n# both channels and channels_labels given\nwith pytest.warns(UserWarning):\nimg2d.plot(channels=[0],\nchannels_labels=['some-label-2'],\nscalebar_micrometer=50,\nshow_scalebar_label=False)\n# automatically extract channel colors and ranges\nimg2d.plot(channels=[0])\n# using label_name\nimg2d.plot(label_name='organoids',\nchannels=[0],\nchannel_colors=['white'],\nchannel_ranges=[[0.01, 0.99]])\nimg2d.plot(label_name=['non-existent', 'also-non-existent', 'organoids'],\nchannels=[0],\nchannel_colors=['white'],\nchannel_ranges=[[0.01, 0.99]])\nimg2d.plot(label_name=['non-existent', 'also-non-existent'],\nchannels=[0],\nchannel_colors=['white'],\nchannel_ranges=[[0.01, 0.99]])\n# automatically extract coordinates for label_value\nwith pytest.warns(UserWarning):\nimg2d.plot(upper_left_yx=(0, 0),\nlower_right_yx=(100, 100),label_name='organoids',\nlabel_value=3,\nextend_pixels=8)\n# ... select label_pyramid_level\nimg2d.plot(label_name='organoids',\nlabel_value=3,\nlabel_pyramid_level='0',\nrestrict_to_label_values=[3])\nwith pytest.raises(Exception) as e_info:\nimg2d.plot(upper_left_yx=(0, 0),\nlabel_value=3,\nlabel_pyramid_level='does-not-exist',\nrestrict_to_label_values=[3])\n# ... restrict plotting to label_value\nimg2d.plot(label_name='organoids',\nlabel_value=3,\nrestrict_to_label_values=[3])\n# ... restrict plotting to non-existent label_value\nimg2d.plot(label_name='organoids',\nlabel_value=3,\nrestrict_to_label_values=99)\n# ... non-existent label_value\nwith pytest.raises(Exception) as e_info:\nimg2d.plot(label_name='organoids',\nlabel_value=99)\n# using label_name without matching pyramid level\n# ... copy zarr fileset\nassert tmpdir.check()\nshutil.copytree('tests/example_data/plate_ones_mip.zarr/B/03/0',\nstr(tmpdir) + '/example_img')\nassert tmpdir.join('/example_img/1').check()\n# ... remove pyramid levels 1 and 2 from image\nshutil.rmtree(str(tmpdir) + '/example_img/1')\nshutil.rmtree(str(tmpdir) + '/example_img/2')\nzattr_file = str(tmpdir) + '/example_img/.zattrs'\nwith open(zattr_file) as f:\nzattr = json.load(f)\nzattr['multiscales'][0]['datasets'] = [zattr['multiscales'][0]['datasets'][0]]\nwith open(zattr_file, \"w\") as jsonfile:\njson.dump(zattr, jsonfile, indent=4)\n# ... remove pyramid levels 0 and 1 from label organoids\nshutil.rmtree(str(tmpdir) + '/example_img/labels/organoids/0')\nshutil.rmtree(str(tmpdir) + '/example_img/labels/organoids/1')\nzattr_file = str(tmpdir) + '/example_img/labels/organoids/.zattrs'\nwith open(zattr_file) as f:\nzattr = json.load(f)\nzattr['multiscales'][0]['datasets'] = [zattr['multiscales'][0]['datasets'][2]]\nwith open(zattr_file, \"w\") as jsonfile:\njson.dump(zattr, jsonfile, indent=4)\n# ... plot\nimgtmp = ome_zarr.Image(str(tmpdir) + '/example_img')\nimgtmp.plot(label_name='organoids')\n# ... clean up\nshutil.rmtree(str(tmpdir) + '/example_img')\n### TODO: problematic case where pyramid_level_coord is not None\n###       and pyramid_level is not parallel in image and label\n###       what does pyramid_level_coord refer to?\n###       solution: remove pyramid_level_coord argument?\n###       not needed: can use coordinate_unit=\"micrometer\"\n# 4d dataset\nimg4d.plot(label_name='embryo',\npyramid_level=None,\npyramid_level_coord=None,\nchannels_labels=['channel_0'],\nchannel_colors=['white'],\nchannel_ranges=[[0.01, 0.99]],\nz_projection_method='maximum',\ntime_index = 0,\nscalebar_micrometer=50,\nshow_scalebar_label=True)\n# v3 dataset\nimg3dv3.plot(label_name='0',\npyramid_level=None,\npyramid_level_coord=None,\nchannels_labels=['channel-1'],\nchannel_colors=['white'],\nchannel_ranges=[[0.01, 0.99]],\nz_projection_method='maximum',\nscalebar_micrometer=50,\nshow_scalebar_label=True)\n# ... try to select multiple timepoints (error)\nwith pytest.raises(Exception) as e_info:\nimg4d.plot(label_name='embryo',\npyramid_level=None,\npyramid_level_coord=None,\nchannels_labels=['channel_0'],\nchannel_colors=['white'],\nchannel_ranges=[[0.01, 0.99]],\nz_projection_method='maximum',\ntime_index = [0, 1],\nscalebar_micrometer=50,\nshow_scalebar_label=True)\n# ... try to select too large timepoint (error)\nwith pytest.raises(Exception) as e_info:\nimg4d.plot(label_name='embryo',\npyramid_level=None,\npyramid_level_coord=None,\nchannels_labels=['channel_0'],\nchannel_colors=['white'],\nchannel_ranges=[[0.01, 0.99]],\nz_projection_method='maximum',\ntime_index = 10,\nscalebar_micrometer=50,\nshow_scalebar_label=True)\nplt.savefig(tmpdir.join('output.png'))\nassert True # check if the plotting ran through\n</code></pre>"},{"location":"testing/#tests.test_ome_zarr.test_tree","title":"<code>test_tree(img2d)</code>","text":"<p>Test <code>Image.tree()</code>.</p> Source code in <code>tests/test_ome_zarr.py</code> <pre><code>def test_tree(img2d: ome_zarr.Image):\n\"\"\"Test `Image.tree()`.\"\"\"\nres1 = img2d.tree()\nassert print(res1) == None\n</code></pre>"},{"location":"testing/#plotting","title":"plotting","text":""},{"location":"testing/#tests.test_plotting.npa3d","title":"<code>npa3d()</code>","text":"<p>A 3D <code>numpy.array</code> with shape (3,4,5)</p> Source code in <code>tests/test_plotting.py</code> <pre><code>@pytest.fixture\ndef npa3d() -&gt; np.ndarray:\n\"\"\"A 3D `numpy.array` with shape (3,4,5)\"\"\"\nnp.random.seed(42)\nreturn np.random.randint(0, 16, size=(3, 4, 5))\n</code></pre>"},{"location":"testing/#tests.test_plotting.npa4d","title":"<code>npa4d()</code>","text":"<p>A 4D <code>numpy.array</code> with shape (2,3,4,5)</p> Source code in <code>tests/test_plotting.py</code> <pre><code>@pytest.fixture\ndef npa4d() -&gt; np.ndarray:\n\"\"\"A 4D `numpy.array` with shape (2,3,4,5)\"\"\"\nnp.random.seed(42)\nreturn np.random.randint(0, 2**16, size=(2, 3, 4, 5))\n</code></pre>"},{"location":"testing/#tests.test_plotting.test_convert_to_rgb","title":"<code>test_convert_to_rgb(npa3d)</code>","text":"<p>Test convert_to_rgb.</p> Source code in <code>tests/test_plotting.py</code> <pre><code>def test_convert_to_rgb(npa3d: np.ndarray):\n\"\"\"Test convert_to_rgb.\"\"\"\nrng = np.quantile(npa3d[1], [0.01, 0.5])\nrgb = convert_to_rgb(im=npa3d[[0,1]],\nchannel_colors=['yellow', 'red'],\nchannel_ranges=[[0.01, 0.5], rng],\nverbose=True)\nassert isinstance(rgb, np.ndarray)\nassert rgb.shape == (npa3d.shape[1], npa3d.shape[2], 3)\nassert rgb.dtype == np.uint8\nassert np.max(rgb) == 255\nda = dask.array.from_array(npa3d)\nrgb = convert_to_rgb(im=da[[0,1]],\nchannel_colors=['yellow', 'red'],\nchannel_ranges=[[0.01, 0.5], rng])\nassert isinstance(rgb, np.ndarray)\nassert rgb.shape == (npa3d.shape[1], npa3d.shape[2], 3)\nassert rgb.dtype == np.uint8\nassert np.max(rgb) == 255\n</code></pre>"},{"location":"testing/#tests.test_plotting.test_get_shuffled_cmap","title":"<code>test_get_shuffled_cmap()</code>","text":"<p>Test get_shuffled_cmap.</p> Source code in <code>tests/test_plotting.py</code> <pre><code>def test_get_shuffled_cmap():\n\"\"\"Test get_shuffled_cmap.\"\"\"\ncm = get_shuffled_cmap()\nassert isinstance(cm, mcolors.ListedColormap)\n</code></pre>"},{"location":"testing/#tests.test_plotting.test_pad_image","title":"<code>test_pad_image(npa3d)</code>","text":"<p>Test pad_image.</p> Source code in <code>tests/test_plotting.py</code> <pre><code>def test_pad_image(npa3d: np.ndarray):\n\"\"\"Test pad_image.\"\"\"\npad = (0, 20, 30)\nout = tuple(pad[i] + npa3d.shape[i] for i in range(3))\nimpad = pad_image(im = npa3d, output_shape=out)\nassert impad.shape == out\nassert (impad[:, slice(10, 10 + npa3d.shape[1]), slice(15, 15 + npa3d.shape[2])] == npa3d).all()\n</code></pre>"},{"location":"testing/#tests.test_plotting.test_plot_image","title":"<code>test_plot_image(npa4d, npa3d, tmpdir)</code>","text":"<p>Test plot_image.</p> Source code in <code>tests/test_plotting.py</code> <pre><code>def test_plot_image(npa4d: np.ndarray, npa3d: np.ndarray, tmpdir: str):\n\"\"\"Test plot_image.\"\"\"\nwith pytest.raises(Exception) as e_info:\nplot_image(im=npa4d, msk=None,\nchannels=[1],\nchannel_colors=['white'],\nchannel_ranges=[[0.01, 0.99]],\ntitle='test', call_show=False,\nscalebar_pixel=100,\nscalebar_position='error')\nwith pytest.raises(Exception) as e_info:\nplot_image(im=npa4d, msk=None,\nchannels=[0, 1],\nchannel_colors=['white'],\nchannel_ranges=[[0.01, 0.99]],\ntitle='test')\nwith pytest.raises(Exception) as e_info:\nplot_image(im=npa4d, msk=None,\nchannels=[0, 1],\nchannel_colors=['viridis', 'inferno'],\nchannel_ranges=[[0.01, 0.99]],\ntitle='test')\nwith pytest.raises(Exception) as e_info:\nplot_image(im=npa4d, msk=None,\nchannels=[1],\nchannel_colors=['white'],\nchannel_ranges=[[0.01, 0.99]],\ntitle='test', call_show=False,\naxis_style='error')\nmatplotlib.use('Agg')  # Use the 'Agg' backend, which doesn't need a display\nwith warnings.catch_warnings():\nwarnings.simplefilter('ignore') # suppress warning due to cannot show FigureCanvas \n# scalebar_position\nfor pos in ['topleft', 'bottomleft', 'topright', 'bottomright']:\nplot_image(im=npa4d, msk=None,\nchannels=[1],\nchannel_colors=['white'],\nchannel_ranges=[[0.01, 0.99]],\ntitle='test', title_fontsize='xx-large', call_show=False,\nscalebar_pixel=100, scalebar_fontsize=10,\nscalebar_position=pos,\nscalebar_label='test')\n# axis_style and image_transform\nfor st in ['none', 'pixel', 'frame', 'micrometer']:\nplot_image(im=npa4d, msk=None,\nchannels=[1],\nchannel_colors=['white'],\nchannel_ranges=[[0.01, 0.99]],\ntitle='test', call_show=False,\nimage_transform=np.log1p,\naxis_style=st,\nspacing_yx=[0.325, 0.325],\nverbose=True)\n# single channel with colormap\nplot_image(im=npa4d, msk=None,\nchannels=[1],\nchannel_colors=['inferno'],\nchannel_ranges=[[0.01, 0.99]],\ntitle='test', call_show=False,\nverbose=True)\n# image with masks\nplot_image(im=npa4d, msk=npa3d,\nchannels=[1],\nchannel_colors=['white'],\nchannel_ranges=[[0.01, 0.99]],\ntitle='test', call_show=True)\nplot_image(im=npa4d, msk=npa3d,\nrestrict_to_label_values=[1],\npad_to_yx=[1000,1000],\nchannels=[1],\nchannel_colors=['white'],\nchannel_ranges=[[0.01, 0.99]],\ntitle='test', call_show=True,\nverbose=True)\nplot_image(im=npa4d, msk=npa3d,\nchannels=[1],\nchannel_colors=['white'],\nchannel_ranges=[[0.01, 0.99]],\nshow_label_values=True,\nlabel_text_colour='red', label_fontsize=12,\ntitle='test', call_show=True)\n# brightfield image\nplot_image(im=npa4d[slice(0,1)],\ncall_show=True,\nfig_style='brightfield',\nverbose=True)\n# 2D image\nplot_image(im=npa4d[0, 0],\ncall_show=True)\nplt.savefig(tmpdir.join('output.png'))\nassert True # check if the plotting ran through\n</code></pre>"},{"location":"testing/#tests.test_plotting.test_zproject","title":"<code>test_zproject(npa3d, npa4d)</code>","text":"<p>Test zproject.</p> Source code in <code>tests/test_plotting.py</code> <pre><code>def test_zproject(npa3d: np.ndarray, npa4d: np.ndarray):\n\"\"\"Test zproject.\"\"\"\nwith pytest.raises(Exception) as e_info:\nzproject(im=npa3d, axis=1, method='error')\nr3d0max = zproject(im=npa3d, axis=0, method='maximum',\nkeepdims=True, img_bit=16)\nr3d0min = zproject(im=npa3d, axis=0, method='minimum',\nkeepdims=True, img_bit=16)\nr3d0sum = zproject(im=npa3d, axis=0, method='sum',\nkeepdims=True, img_bit=16)\nr3d0avg = zproject(im=npa3d, axis=0, method='average',\nkeepdims=True, img_bit=16)\nr4d1sum_noclip = zproject(im=npa4d, axis=1, method='sum',\nkeepdims=True, img_bit=32)\nr4d1avg_reddim = zproject(im=npa4d, axis=1, method='average',\nkeepdims=False, img_bit=16)\nassert isinstance(r3d0max, np.ndarray)\nassert r3d0max.shape == (1,4,5)\nassert r3d0min.shape == r3d0max.shape\nassert r3d0sum.shape == r3d0max.shape\nassert r3d0avg.shape == r3d0max.shape\nassert r4d1sum_noclip.shape == (2,1,4,5)\nassert r4d1avg_reddim.shape == (2,4,5)\nassert (r3d0max == np.max(npa3d, axis=0, keepdims=True)).all()\nassert (r3d0min == np.min(npa3d, axis=0, keepdims=True)).all()\nassert (r3d0sum == np.clip(np.sum(npa3d, axis=0, keepdims=True), 0, 2**16)).all()\nassert (r3d0avg == np.mean(npa3d, axis=0, keepdims=True)).all()\nassert (r4d1sum_noclip == np.sum(npa4d, axis=1, keepdims=True)).all()\nassert (r4d1avg_reddim == np.mean(npa4d, axis=1, keepdims=False)).all()\n</code></pre>"},{"location":"testing/#hcs_wrappers","title":"hcs_wrappers","text":""},{"location":"testing/#tests.test_hcs_wrappers.plate_2d","title":"<code>plate_2d()</code>","text":"<p>A <code>hcs_wrappers.FractalZarr</code> object representing a 2D ome-zarr fileset</p> Source code in <code>tests/test_hcs_wrappers.py</code> <pre><code>@pytest.fixture\ndef plate_2d():\n\"\"\"A `hcs_wrappers.FractalZarr` object representing a 2D ome-zarr fileset\"\"\"\nreturn hcs_wrappers.FractalZarr('tests/example_data/plate_ones_mip.zarr', name=\"test\")\n</code></pre>"},{"location":"testing/#tests.test_hcs_wrappers.plate_3d","title":"<code>plate_3d()</code>","text":"<p>A <code>hcs_wrappers.FractalZarr</code> object representing a 3D ome-zarr fileset</p> Source code in <code>tests/test_hcs_wrappers.py</code> <pre><code>@pytest.fixture\ndef plate_3d():\n\"\"\"A `hcs_wrappers.FractalZarr` object representing a 3D ome-zarr fileset\"\"\"\nreturn hcs_wrappers.FractalZarr('tests/example_data/plate_ones.zarr')\n</code></pre>"},{"location":"testing/#tests.test_hcs_wrappers.plate_set1","title":"<code>plate_set1()</code>","text":"<p>A <code>hcs_wrappers.FractalZarrSet</code> object representing a two ome-zarr filesets</p> Source code in <code>tests/test_hcs_wrappers.py</code> <pre><code>@pytest.fixture\ndef plate_set1():\n\"\"\"A `hcs_wrappers.FractalZarrSet` object representing a two ome-zarr filesets\"\"\"\nreturn hcs_wrappers.FractalZarrSet('tests/example_data')\n</code></pre>"},{"location":"testing/#tests.test_hcs_wrappers.plate_set2","title":"<code>plate_set2()</code>","text":"<p>A <code>hcs_wrappers.FractalZarrSet</code> object representing a two ome-zarr filesets</p> Source code in <code>tests/test_hcs_wrappers.py</code> <pre><code>@pytest.fixture\ndef plate_set2():\n\"\"\"A `hcs_wrappers.FractalZarrSet` object representing a two ome-zarr filesets\"\"\"\nreturn hcs_wrappers.FractalZarrSet('tests/example_data', name=\"test\")\n</code></pre>"},{"location":"testing/#tests.test_hcs_wrappers.test_calc_average_FOV","title":"<code>test_calc_average_FOV(tmpdir, plate_3d)</code>","text":"<p>Test <code>FractalZarr.calc_average_FOV().</code></p> Source code in <code>tests/test_hcs_wrappers.py</code> <pre><code>def test_calc_average_FOV(tmpdir: str, plate_3d: hcs_wrappers.FractalZarr):\n\"\"\"Test `FractalZarr.calc_average_FOV().`\"\"\"\n# test exceptions\n# ... copy zarr fileset\nassert tmpdir.check()\nshutil.copytree('tests/example_data', str(tmpdir) + '/example_data')\nassert tmpdir.join('/example_data/plate_ones.zarr/B/03/0/tables/FOV_ROI_table').check()\n# ... remove tables\nshutil.rmtree(str(tmpdir) + '/example_data/plate_ones.zarr/B/03/0/tables')\n# ... test calculation\nplate_tmp = hcs_wrappers.FractalZarr(str(tmpdir) + '/example_data/plate_ones.zarr')\nwith pytest.raises(Exception) as e_info:\nplate_tmp.calc_average_FOV()\n# test expected results\navg0 = plate_3d.calc_average_FOV(pyramid_level=0)\navg1 = plate_3d.calc_average_FOV(pyramid_level=1)\navg2 = plate_3d.calc_average_FOV(pyramid_level=2)\nassert isinstance(avg0, np.ndarray)\nassert isinstance(avg1, np.ndarray)\nassert isinstance(avg2, np.ndarray)\nassert avg0.shape == (3, 540, 640)\nassert avg1.shape == (3, 270, 320)\nassert avg2.shape == (3, 135, 160)\n</code></pre>"},{"location":"testing/#tests.test_hcs_wrappers.test_constructor_2d","title":"<code>test_constructor_2d(plate_2d)</code>","text":"<p>Test the <code>FractalZarr</code> constructor (2D).</p> Source code in <code>tests/test_hcs_wrappers.py</code> <pre><code>def test_constructor_2d(plate_2d: hcs_wrappers.FractalZarr):\n\"\"\"Test the `FractalZarr` constructor (2D).\"\"\"\nassert isinstance(plate_2d, hcs_wrappers.FractalZarr)\nassert plate_2d.name == 'test'\nassert isinstance(plate_2d._FractalZarr__top, zarr.Group)\nassert plate_2d.columns == [{'name': '03'}]\nassert plate_2d.rows == [{'name': 'B'}]\nassert len(plate_2d.wells) == 1\nassert len(plate_2d.channels) == 2\nassert isinstance(plate_2d.channels[0], dict)\nassert isinstance(plate_2d.multiscales_images, dict)\nassert 'datasets' in plate_2d.multiscales_images['0']\nassert len(plate_2d.multiscales_images['0']['datasets']) == 3\nassert plate_2d.level_paths_images['0'] == list(range(3))\nassert plate_2d.level_zyx_spacing_images['0'] == [[1.0, 0.1625, 0.1625], [1.0, 0.325, 0.325], [1.0, 0.65, 0.65]]\nassert list(plate_2d.level_zyx_scalefactor['0']) == [1., 2., 2.]\nassert plate_2d.label_names == ['organoids']\nassert plate_2d.table_names == ['FOV_ROI_table']\n</code></pre>"},{"location":"testing/#tests.test_hcs_wrappers.test_constructor_3d","title":"<code>test_constructor_3d(plate_3d)</code>","text":"<p>Test the <code>FractalZarr</code> constructor (3D).</p> Source code in <code>tests/test_hcs_wrappers.py</code> <pre><code>def test_constructor_3d(plate_3d: hcs_wrappers.FractalZarr):\n\"\"\"Test the `FractalZarr` constructor (3D).\"\"\"\n# exceptions\nwith pytest.raises(Exception) as e_info:\nhcs_wrappers.FractalZarr('does-not-exist')\nwith pytest.raises(Exception) as e_info:\nhcs_wrappers.FractalZarr('tests/example_data/plate_ones_mip.zarr/B')\n# expected values\nassert isinstance(plate_3d, hcs_wrappers.FractalZarr)\nassert plate_3d.name == 'plate_ones.zarr'\nassert isinstance(plate_3d._FractalZarr__top, zarr.Group)\nassert plate_3d.columns == [{'name': '03'}]\nassert plate_3d.rows == [{'name': 'B'}]\nassert len(plate_3d.wells) == 1\nassert len(plate_3d.channels) == 2\nassert isinstance(plate_3d.channels[0], dict)\nassert isinstance(plate_3d.multiscales_images, dict)\nassert 'datasets' in plate_3d.multiscales_images['0']\nassert len(plate_3d.multiscales_images['0']['datasets']) == 3\nassert plate_3d.level_paths_images['0'] == list(range(3))\nassert plate_3d.level_zyx_spacing_images['0'] == [[1.0, 0.1625, 0.1625], [1.0, 0.325, 0.325], [1.0, 0.65, 0.65]]\nassert list(plate_3d.level_zyx_scalefactor['0']) == [1., 2., 2.]\nassert plate_3d.label_names == []\nassert plate_3d.table_names == ['FOV_ROI_table']\n</code></pre>"},{"location":"testing/#tests.test_hcs_wrappers.test_constructor_set","title":"<code>test_constructor_set(plate_set1, plate_set2, tmpdir)</code>","text":"<p>Test <code>FractalZarrSet</code> object constructor.</p> Source code in <code>tests/test_hcs_wrappers.py</code> <pre><code>def test_constructor_set(plate_set1: hcs_wrappers.FractalZarrSet,\nplate_set2: hcs_wrappers.FractalZarrSet,\ntmpdir: str):\n\"\"\"Test `FractalZarrSet` object constructor.\"\"\"\n# exceptions\nwith pytest.raises(Exception) as e_info:\nhcs_wrappers.FractalZarrSet('error')\nwith pytest.raises(Exception) as e_info:\nhcs_wrappers.FractalZarrSet(tmpdir)\n# expected values    \nassert isinstance(plate_set1, hcs_wrappers.FractalZarrSet)\nassert plate_set1.path == 'tests/example_data'\nassert plate_set1.name == 'example_data'\nassert plate_set2.name == 'test'\nassert plate_set1.zarr_mip_idx == 0\nassert plate_set1.zarr_3d_idx == 1\n</code></pre>"},{"location":"testing/#tests.test_hcs_wrappers.test_coordinate_conversions","title":"<code>test_coordinate_conversions(plate_3d, plate_2d)</code>","text":"<p>Test <code>FractalZarr.convert_*</code> coordinate conversions.</p> Source code in <code>tests/test_hcs_wrappers.py</code> <pre><code>def test_coordinate_conversions(plate_3d: hcs_wrappers.FractalZarr, plate_2d: hcs_wrappers.FractalZarr):\n\"\"\"Test `FractalZarr.convert_*` coordinate conversions.\"\"\"\n# test exceptions\nwith pytest.raises(Exception) as e_info:\nplate_3d.convert_micrometer_to_pixel('error')\nwith pytest.raises(Exception) as e_info:\nplate_3d.convert_pixel_to_micrometer('error')\nwith pytest.raises(Exception) as e_info:\nplate_3d.convert_pixel_to_pixel('error', 0, 0)\nwith pytest.raises(Exception) as e_info:\nplate_2d.convert_micrometer_to_pixel(zyx=(1,2,3), pyramid_level=0,\npyramid_ref=('label', 'does-not-exist'))\n# test expected results\n# ... image coordinates\nzyx_um_orig = (30, 40, 50)\nzyx_px_0 = plate_3d.convert_micrometer_to_pixel(zyx=zyx_um_orig, pyramid_level=0,\npyramid_ref=('image', '0'))\nzyx_px_1 = plate_3d.convert_micrometer_to_pixel(zyx=zyx_um_orig, pyramid_level=1)\nzyx_px_2 = plate_3d.convert_micrometer_to_pixel(zyx=zyx_um_orig, pyramid_level=2)\nzyx_um_from1 = plate_3d.convert_pixel_to_micrometer(zyx=zyx_px_1, pyramid_level=1)\nzyx_um_from2 = plate_3d.convert_pixel_to_micrometer(zyx=zyx_px_2, pyramid_level=2)\nzyx_px_0_from1 = plate_3d.convert_pixel_to_pixel(zyx=zyx_px_1, pyramid_level_from=1, pyramid_level_to=0)\nzyx_px_2_from1 = plate_3d.convert_pixel_to_pixel(zyx=zyx_px_1, pyramid_level_from=1, pyramid_level_to=2)\nassert isinstance(zyx_px_1, tuple)\nassert all([isinstance(v, np.int_) for v in zyx_px_1])\nassert len(zyx_px_1) == 3\nassert zyx_px_1 == (30, 123, 154)\nassert zyx_um_from1 == zyx_um_orig\nassert zyx_um_from2 == zyx_um_orig\nassert zyx_px_0_from1 == zyx_px_0\nassert zyx_px_2_from1 == zyx_px_2\n# ... label coordinates\nref = ('label', 'organoids')\nzyx_px_0 = plate_2d.convert_micrometer_to_pixel(zyx=zyx_um_orig, pyramid_level=0,\npyramid_ref=ref)\nzyx_px_1 = plate_2d.convert_micrometer_to_pixel(zyx=zyx_um_orig, pyramid_level=1, pyramid_ref=ref)\nzyx_px_2 = plate_2d.convert_micrometer_to_pixel(zyx=zyx_um_orig, pyramid_level=2, pyramid_ref=ref)\nzyx_um_from1 = plate_2d.convert_pixel_to_micrometer(zyx=zyx_px_1, pyramid_level=1, pyramid_ref=ref)\nzyx_um_from2 = plate_2d.convert_pixel_to_micrometer(zyx=zyx_px_2, pyramid_level=2, pyramid_ref=ref)\nzyx_px_0_from1 = plate_2d.convert_pixel_to_pixel(zyx=zyx_px_1, pyramid_level_from=1, pyramid_level_to=0, \npyramid_ref_from=ref, pyramid_ref_to=ref)\nzyx_px_2_from1 = plate_2d.convert_pixel_to_pixel(zyx=zyx_px_1, pyramid_level_from=1, pyramid_level_to=2, \npyramid_ref_from=ref, pyramid_ref_to=ref)\nassert isinstance(zyx_px_1, tuple)\nassert all([isinstance(v, np.int_) for v in zyx_px_1])\nassert len(zyx_px_1) == 3\nassert zyx_px_1 == (30, 123, 154)\nassert zyx_um_from1 == zyx_um_orig\nassert zyx_um_from2 == zyx_um_orig\nassert zyx_px_0_from1 == zyx_px_0\nassert zyx_px_2_from1 == zyx_px_2\n</code></pre>"},{"location":"testing/#tests.test_hcs_wrappers.test_digest_include_wells_argument","title":"<code>test_digest_include_wells_argument(plate_3d)</code>","text":"<p>Test <code>FractalZarr._digest_include_wells_argument</code>.</p> Source code in <code>tests/test_hcs_wrappers.py</code> <pre><code>def test_digest_include_wells_argument(plate_3d: hcs_wrappers.FractalZarr):\n\"\"\"Test `FractalZarr._digest_include_wells_argument`.\"\"\"\nassert plate_3d._digest_include_wells_argument([]) == ['B/03']\nassert plate_3d._digest_include_wells_argument(['B03']) == ['B/03']\nassert plate_3d._digest_include_wells_argument('B03') == ['B/03']\n</code></pre>"},{"location":"testing/#tests.test_hcs_wrappers.test_digest_pyramid_level_argument","title":"<code>test_digest_pyramid_level_argument(plate_3d, plate_2d)</code>","text":"<p>Test <code>FractalZarr._digest_pyramid_level_argument</code>.</p> Source code in <code>tests/test_hcs_wrappers.py</code> <pre><code>def test_digest_pyramid_level_argument(plate_3d: hcs_wrappers.FractalZarr, plate_2d: hcs_wrappers.FractalZarr):\n\"\"\"Test `FractalZarr._digest_pyramid_level_argument`.\"\"\"\nassert plate_3d._digest_pyramid_level_argument(None) == 2\nassert plate_3d._digest_pyramid_level_argument(1) == 1\nassert plate_3d._digest_pyramid_level_argument(1, ('image', '0')) == 1\nassert plate_2d._digest_pyramid_level_argument(1, ('label', 'organoids')) == 1\nassert plate_2d._digest_pyramid_level_argument(None, ('label', 'organoids')) == 2\n</code></pre>"},{"location":"testing/#tests.test_hcs_wrappers.test_digest_well_argument","title":"<code>test_digest_well_argument(plate_3d)</code>","text":"<p>Test <code>FractalZarr._digest_well_argument</code>.</p> Source code in <code>tests/test_hcs_wrappers.py</code> <pre><code>def test_digest_well_argument(plate_3d: hcs_wrappers.FractalZarr):\n\"\"\"Test `FractalZarr._digest_well_argument`.\"\"\"\nassert plate_3d._digest_well_argument(None) == 'B/03'\nassert plate_3d._digest_well_argument('B03') == 'B/03'\nassert plate_3d._digest_well_argument('B03', as_path=False) == 'B03'\n</code></pre>"},{"location":"testing/#tests.test_hcs_wrappers.test_get_channels","title":"<code>test_get_channels(plate_2d, plate_3d)</code>","text":"<p>Test <code>FractalZarr.get_channels().</code></p> Source code in <code>tests/test_hcs_wrappers.py</code> <pre><code>def test_get_channels(plate_2d: hcs_wrappers.FractalZarr, plate_3d: hcs_wrappers.FractalZarr):\n\"\"\"Test `FractalZarr.get_channels().`\"\"\"\nchannels_expected = [{'wavelength_id': 'A01_C01', 'label': 'some-label-1',\n'window': {'min': '0', 'max': '10', 'start': '0', 'end': '10'},\n'color': '00FFFF'},\n{'wavelength_id': 'A01_C02', 'label': 'some-label-2',\n'window': {'min': '0', 'max': '10', 'start': '0', 'end': '10'},\n'color': '00FFFF'}]\nassert plate_2d.get_channels() == plate_2d.channels\nassert plate_2d.get_channels() == channels_expected\nassert plate_3d.get_channels() == plate_3d.channels\nassert plate_3d.get_channels() == channels_expected\n</code></pre>"},{"location":"testing/#tests.test_hcs_wrappers.test_get_image_ROI_3d","title":"<code>test_get_image_ROI_3d(plate_3d)</code>","text":"<p>Test <code>FractalZarr.get_image_ROI()</code>.</p> Source code in <code>tests/test_hcs_wrappers.py</code> <pre><code>def test_get_image_ROI_3d(plate_3d: hcs_wrappers.FractalZarr):\n\"\"\"Test `FractalZarr.get_image_ROI()`.\"\"\"\nimg0a = plate_3d.get_image_ROI(well=None, pyramid_level=2,\nupper_left_yx=None,\nlower_right_yx=None,\nsize_yx=None,\nas_NumPy=False)\nimg0b = plate_3d.get_image_ROI(well='B03', pyramid_level=2,\nupper_left_yx=(0, 0),\nlower_right_yx=(269, 319),\nsize_yx=None,\nas_NumPy=True)\nassert isinstance(img0a, dask.array.Array)\nassert isinstance(img0b, np.ndarray)\nassert img0a.shape == (2, 3, 270, 320)\nassert (np.array(img0a) == img0b).all()\nwith pytest.raises(Exception) as e_info:\nplate_3d.get_image_ROI(well='B03', pyramid_level=1,\nupper_left_yx=(11, 10),\nlower_right_yx=None, size_yx=None)\nimg1a = plate_3d.get_image_ROI(well='B03', pyramid_level=1,\npyramid_level_coord=0,\nupper_left_yx=(22, 20),\nlower_right_yx=(44, 40),\nsize_yx=None,\nas_NumPy=True)\nimg1b = plate_3d.get_image_ROI(well='B03', pyramid_level=1,\nupper_left_yx=(11, 10),\nlower_right_yx=None,\nsize_yx=(11, 10),\nas_NumPy=True)\nimg1c = plate_3d.get_image_ROI(well='B03', pyramid_level=1,\nupper_left_yx=None,\nlower_right_yx=(22, 20),\nsize_yx=(11, 10),\nas_NumPy=True)\nassert isinstance(img1a, np.ndarray)\nassert isinstance(img1b, np.ndarray)\nassert isinstance(img1c, np.ndarray)\nassert img1a.shape == (2, 3, 12, 11)\nassert img1b.shape == img1a.shape\nassert img1c.shape == img1a.shape\nassert (img1b == img1a).all()\nassert (img1c == img1a).all()\n</code></pre>"},{"location":"testing/#tests.test_hcs_wrappers.test_get_image_grid_ROIs_3d","title":"<code>test_get_image_grid_ROIs_3d(plate_3d)</code>","text":"<p>Test <code>FractalZarr.get_image_grid_ROIs().</code></p> Source code in <code>tests/test_hcs_wrappers.py</code> <pre><code>def test_get_image_grid_ROIs_3d(plate_3d: hcs_wrappers.FractalZarr):\n\"\"\"Test `FractalZarr.get_image_grid_ROIs().`\"\"\"\n# exceptions\nwith pytest.raises(Exception) as e_info:\nplate_3d.get_image_grid_ROIs(num_x=2, num_y=2, num_select=5)\nwith pytest.raises(Exception) as e_info:\nplate_3d.get_image_grid_ROIs(pyramid_level=2, sample_method='error')\n# sample_method = 'random'                        \ncoord_1a, img_1a = plate_3d.get_image_grid_ROIs(well='B03', pyramid_level=2,\nnum_x=3, num_y=1, num_select=1,\nsample_method='random', seed=1)\ncoord_1b, img_1b = plate_3d.get_image_grid_ROIs(well='B03', pyramid_level=2,\nnum_x=3, num_y=1, num_select=1,\nsample_method='random', seed=1)\ncoord_2, img_2 = plate_3d.get_image_grid_ROIs(well='B03', pyramid_level=2,\nnum_x=3, num_y=1, num_select=1,\nsample_method='random', seed=11)\ncoord_3, img_3 = plate_3d.get_image_grid_ROIs(well='B03', pyramid_level=2,\nnum_x=8, num_y=8,\nnum_select=3,\nsample_method='random', seed=3,\nas_NumPy=True)\nassert len(coord_1a) == 1\nassert coord_1a == coord_1b\nassert len(coord_2) == 1\nassert coord_1a != coord_2\nassert all([isinstance(x, dask.array.Array) for x in img_1a])\nassert all(x.shape == (2, 3, 270, 106) for x in img_1a)\nassert all(x.shape == (2, 3, 270, 106) for x in img_1b)\nassert all(x.shape == (2, 3, 270, 106) for x in img_2)\nassert len(coord_3) == 3\nassert all([isinstance(x, np.ndarray) for x in img_3])\nassert all(x.shape == (2, 3, 33, 40) for x in img_3)\n# sample_method = 'sum'\ncoord_4, img_4 = plate_3d.get_image_grid_ROIs(well='B03', pyramid_level=2,\nnum_x=3, num_y=1, num_select=3,\nsample_method='sum')\nassert len(coord_4) == 3\nassert all([isinstance(x, dask.array.Array) for x in img_4])\nassert all(x.shape == (2, 3, 270, 106) for x in img_4)\n# sample_method = 'var'\ncoord_5, img_5 = plate_3d.get_image_grid_ROIs(well='B03', pyramid_level=2,\nnum_x=3, num_y=1, num_select=3,\nsample_method='var')\nassert len(coord_5) == 3\nassert all([isinstance(x, dask.array.Array) for x in img_5])\nassert all(x.shape == (2, 3, 270, 106) for x in img_5)\n</code></pre>"},{"location":"testing/#tests.test_hcs_wrappers.test_get_image_table_idx","title":"<code>test_get_image_table_idx(plate_2d)</code>","text":"<p>Test <code>FractalZarr.get_image_table_idx()</code>.</p> Source code in <code>tests/test_hcs_wrappers.py</code> <pre><code>def test_get_image_table_idx(plate_2d: hcs_wrappers.FractalZarr):\n\"\"\"Test `FractalZarr.get_image_table_idx()`.\"\"\"\nwith pytest.raises(Exception) as e_info:\nplate_2d.get_image_table_idx(table_name='does-not-exist', table_idx=0)\nimg = plate_2d.get_image_table_idx(table_name='FOV_ROI_table',\ntable_idx=0, well='B03', pyramid_level=2,\nas_NumPy=False)\nassert isinstance(img, dask.array.Array)\nassert img.shape == (2, 1, 136, 161)\n</code></pre>"},{"location":"testing/#tests.test_hcs_wrappers.test_get_label_ROI_2d","title":"<code>test_get_label_ROI_2d(plate_2d)</code>","text":"<p>Test <code>FractalZarr.get_label_ROI()</code>.</p> Source code in <code>tests/test_hcs_wrappers.py</code> <pre><code>def test_get_label_ROI_2d(plate_2d: hcs_wrappers.FractalZarr):\n\"\"\"Test `FractalZarr.get_label_ROI()`.\"\"\"\nmsk0a = plate_2d.get_label_ROI(label_name='organoids',\nwell=None, pyramid_level=2,\nupper_left_yx=None,\nlower_right_yx=None,\nsize_yx=None,\nas_NumPy=False)\nmsk0b = plate_2d.get_label_ROI(label_name='organoids',\nwell='B03', pyramid_level=2,\nupper_left_yx=(0, 0),\nlower_right_yx=(269, 319),\nsize_yx=None,\nas_NumPy=True)\nassert isinstance(msk0a, dask.array.Array)\nassert isinstance(msk0b, np.ndarray)\nassert msk0a.shape == (1, 270, 320)\nassert (np.array(msk0a) == msk0b).all()\nwith pytest.raises(Exception) as e_info:\nplate_2d.get_label_ROI(label_name='organoids',\nwell='B03', pyramid_level=1,\nupper_left_yx=(11, 10),\nlower_right_yx=None, size_yx=None)\nwith pytest.raises(Exception) as e_info:\nplate_2d.get_label_ROI(label_name='does-not-exist',\nwell='B03', pyramid_level=1,\nupper_left_yx=(11, 10),\nsize_yx=(10, 10))\nmsk1a = plate_2d.get_label_ROI(label_name='organoids',\nwell='B03', pyramid_level=1,\npyramid_level_coord=0,\nupper_left_yx=(22, 20),\nlower_right_yx=(44, 40),\nsize_yx=None,\nas_NumPy=True)\nmsk1b = plate_2d.get_label_ROI(label_name='organoids',\nwell='B03', pyramid_level=1,\nupper_left_yx=(11, 10),\nlower_right_yx=None,\nsize_yx=(11, 10),\nas_NumPy=True)\nmsk1c = plate_2d.get_label_ROI(label_name='organoids',\nwell='B03', pyramid_level=1,\nupper_left_yx=None,\nlower_right_yx=(22, 20),\nsize_yx=(11, 10),\nas_NumPy=True)\nassert isinstance(msk1a, np.ndarray)\nassert isinstance(msk1b, np.ndarray)\nassert isinstance(msk1c, np.ndarray)\nassert msk1a.shape == (1, 12, 11)\nassert msk1b.shape == msk1a.shape\nassert msk1c.shape == msk1a.shape\nassert (msk1b == msk1a).all()\nassert (msk1c == msk1a).all()\n</code></pre>"},{"location":"testing/#tests.test_hcs_wrappers.test_get_label_names","title":"<code>test_get_label_names(plate_2d, plate_3d)</code>","text":"<p>Test <code>FractalZarr.get_label_names().</code></p> Source code in <code>tests/test_hcs_wrappers.py</code> <pre><code>def test_get_label_names(plate_2d: hcs_wrappers.FractalZarr, plate_3d: hcs_wrappers.FractalZarr):\n\"\"\"Test `FractalZarr.get_label_names().`\"\"\"\nassert plate_2d.get_label_names() == ['organoids']\nassert plate_3d.get_label_names() == []\n</code></pre>"},{"location":"testing/#tests.test_hcs_wrappers.test_get_label_table_idx","title":"<code>test_get_label_table_idx(plate_2d)</code>","text":"<p>Test <code>FractalZarr.get_table_table_idx()</code>.</p> Source code in <code>tests/test_hcs_wrappers.py</code> <pre><code>def test_get_label_table_idx(plate_2d: hcs_wrappers.FractalZarr):\n\"\"\"Test `FractalZarr.get_table_table_idx()`.\"\"\"\nwith pytest.raises(Exception) as e_info:\nplate_2d.get_label_table_idx(label_name='organoids', table_name='does-not-exist', table_idx=0)\nwith pytest.raises(Exception) as e_info:\nplate_2d.get_label_table_idx(label_name='does-not-exist', table_name='FOV_ROI_table', table_idx=0)\nmsk = plate_2d.get_label_table_idx(label_name='organoids', table_name='FOV_ROI_table',\ntable_idx=0, well='B03', pyramid_level=2,\nas_NumPy=False)\nassert isinstance(msk, dask.array.Array)\nassert msk.shape == (1, 136, 161)\n</code></pre>"},{"location":"testing/#tests.test_hcs_wrappers.test_get_path","title":"<code>test_get_path(plate_2d, plate_3d)</code>","text":"<p>Test <code>FractalZarr.get_path().</code></p> Source code in <code>tests/test_hcs_wrappers.py</code> <pre><code>def test_get_path(plate_2d: hcs_wrappers.FractalZarr, plate_3d: hcs_wrappers.FractalZarr):\n\"\"\"Test `FractalZarr.get_path().`\"\"\"\nassert plate_2d.get_path() == plate_2d.path\nassert plate_2d.get_path() == 'tests/example_data/plate_ones_mip.zarr'\nassert plate_3d.get_path() == plate_3d.path\nassert plate_3d.get_path() == 'tests/example_data/plate_ones.zarr'\n</code></pre>"},{"location":"testing/#tests.test_hcs_wrappers.test_get_table","title":"<code>test_get_table(plate_2d)</code>","text":"<p>Test <code>FractalZarr.get_table</code>.</p> Source code in <code>tests/test_hcs_wrappers.py</code> <pre><code>def test_get_table(plate_2d: hcs_wrappers.FractalZarr):\n\"\"\"Test `FractalZarr.get_table`.\"\"\"\nempty = plate_2d.get_table('does not exist')\ndf = plate_2d.get_table('FOV_ROI_table')\nann = plate_2d.get_table('FOV_ROI_table', as_AnnData=True)\nassert empty is None\nassert isinstance(df, pd.DataFrame)\nassert df.shape == (4, 9)\nassert isinstance(ann, ad.AnnData)\nassert ann.shape == (4, 8)\nassert 'well' in ann.obs\ndf2 = plate_2d.get_table('FOV_ROI_table', include_wells=['B03'], as_AnnData=False)\n# make windows paths normal\ndf2.loc[:, 'well'] = df2['well'].str.replace(\"\\\\\", \"\")\nassert df.equals(df2)\n</code></pre>"},{"location":"testing/#tests.test_hcs_wrappers.test_get_table_names","title":"<code>test_get_table_names(plate_2d, plate_3d)</code>","text":"<p>Test <code>FractalZarr.get_table_names().</code></p> Source code in <code>tests/test_hcs_wrappers.py</code> <pre><code>def test_get_table_names(plate_2d: hcs_wrappers.FractalZarr, plate_3d: hcs_wrappers.FractalZarr):\n\"\"\"Test `FractalZarr.get_table_names().`\"\"\"\nassert plate_2d.get_table_names() == plate_2d.table_names\nassert plate_3d.get_table_names() == plate_3d.table_names\n</code></pre>"},{"location":"testing/#tests.test_hcs_wrappers.test_get_wells","title":"<code>test_get_wells(plate_2d, plate_3d)</code>","text":"<p>Test <code>FractalZarr.get_wells().</code></p> Source code in <code>tests/test_hcs_wrappers.py</code> <pre><code>def test_get_wells(plate_2d: hcs_wrappers.FractalZarr, plate_3d: hcs_wrappers.FractalZarr):\n\"\"\"Test `FractalZarr.get_wells().`\"\"\"\nwells_expected = [{'columnIndex': 0, 'path': 'B/03', 'rowIndex': 0}]\nwells_expected_simple = ['B03']\nassert plate_2d.get_wells() == plate_2d.wells\nassert plate_2d.get_wells() == wells_expected\nassert plate_3d.get_wells() == plate_3d.wells\nassert plate_3d.get_wells() == wells_expected\nassert plate_2d.get_wells(simplify=True) == wells_expected_simple\nassert plate_3d.get_wells(simplify=True) == wells_expected_simple\n</code></pre>"},{"location":"testing/#tests.test_hcs_wrappers.test_missing_channel_attrs","title":"<code>test_missing_channel_attrs(tmpdir)</code>","text":"<p>Test <code>FractalZarr</code> missing channel attributes.</p> Source code in <code>tests/test_hcs_wrappers.py</code> <pre><code>def test_missing_channel_attrs(tmpdir: str):\n\"\"\"Test `FractalZarr` missing channel attributes.\"\"\"\n# copy zarr fileset\nassert tmpdir.check()\nshutil.copytree('tests/example_data', str(tmpdir) + '/example_data')\nassert tmpdir.join('/example_data/plate_ones_mip.zarr/B/03/0/.zattrs').check()\n# remove omero attributes from copy\nzattr_file = str(tmpdir) + '/example_data/plate_ones_mip.zarr/B/03/0/.zattrs'\nwith open(zattr_file) as f:\nzattr = json.load(f)\ndel zattr['omero']\nwith open(zattr_file, \"w\") as jsonfile:\njson.dump(zattr, jsonfile, indent=4)\n# test loading\nwith pytest.raises(Exception) as e_info:\nhcs_wrappers.FractalZarr(str(tmpdir) + '/example_data/plate_ones_mip.zarr')\n</code></pre>"},{"location":"testing/#tests.test_hcs_wrappers.test_missing_image_multiscales_attrs","title":"<code>test_missing_image_multiscales_attrs(tmpdir)</code>","text":"<p>Test <code>FractalZarr</code> missing multiscales attributes.</p> Source code in <code>tests/test_hcs_wrappers.py</code> <pre><code>def test_missing_image_multiscales_attrs(tmpdir: str):\n\"\"\"Test `FractalZarr` missing multiscales attributes.\"\"\"\n# copy zarr fileset\nassert tmpdir.check()\nshutil.copytree('tests/example_data', str(tmpdir) + '/example_data')\nassert tmpdir.join('/example_data/plate_ones_mip.zarr/B/03/0/.zattrs').check()\n# remove multiscales attributes from copy\nzattr_file = str(tmpdir) + '/example_data/plate_ones_mip.zarr/B/03/0/.zattrs'\nwith open(zattr_file) as f:\nzattr = json.load(f)\ndel zattr['multiscales']\nwith open(zattr_file, \"w\") as jsonfile:\njson.dump(zattr, jsonfile, indent=4)\n# test loading\nwith pytest.raises(Exception) as e_info:\nhcs_wrappers.FractalZarr(str(tmpdir) + '/example_data/plate_ones_mip.zarr')\n</code></pre>"},{"location":"testing/#tests.test_hcs_wrappers.test_missing_label_multiscales_attrs","title":"<code>test_missing_label_multiscales_attrs(tmpdir)</code>","text":"<p>Test <code>FractalZarr</code> missing multiscales attributes.</p> Source code in <code>tests/test_hcs_wrappers.py</code> <pre><code>def test_missing_label_multiscales_attrs(tmpdir: str):\n\"\"\"Test `FractalZarr` missing multiscales attributes.\"\"\"\n# copy zarr fileset\nassert tmpdir.check()\nshutil.copytree('tests/example_data', str(tmpdir) + '/example_data')\nassert tmpdir.join('/example_data/plate_ones_mip.zarr/B/03/0/labels/organoids/.zattrs').check()\n# remove multiscales attributes from copy\nzattr_file = str(tmpdir) + '/example_data/plate_ones_mip.zarr/B/03/0/labels/organoids/.zattrs'\nwith open(zattr_file) as f:\nzattr = json.load(f)\ndel zattr['multiscales']\nwith open(zattr_file, \"w\") as jsonfile:\njson.dump(zattr, jsonfile, indent=4)\n# test loading\nwith pytest.raises(Exception) as e_info:\nhcs_wrappers.FractalZarr(str(tmpdir) + '/example_data/plate_ones_mip.zarr')\n</code></pre>"},{"location":"testing/#tests.test_hcs_wrappers.test_missing_tables","title":"<code>test_missing_tables(tmpdir)</code>","text":"<p>Test <code>FractalZarr</code> missing tables.</p> Source code in <code>tests/test_hcs_wrappers.py</code> <pre><code>def test_missing_tables(tmpdir: str):\n\"\"\"Test `FractalZarr` missing tables.\"\"\"\n# copy zarr fileset\nassert tmpdir.check()\nshutil.copytree('tests/example_data', str(tmpdir) + '/example_data')\nassert tmpdir.join('/example_data/plate_ones_mip.zarr/B/03/0/.zattrs').check()\n# remove tables\nshutil.rmtree(str(tmpdir) + '/example_data/plate_ones_mip.zarr/B/03/0/tables')\n# test loading\nplate = hcs_wrappers.FractalZarr(str(tmpdir) + '/example_data/plate_ones_mip.zarr')\nassert plate.table_names == []\n</code></pre>"},{"location":"testing/#tests.test_hcs_wrappers.test_plate_str","title":"<code>test_plate_str(plate_2d, plate_3d)</code>","text":"<p>Test <code>FractalZarr</code> object string representation.</p> Source code in <code>tests/test_hcs_wrappers.py</code> <pre><code>def test_plate_str(plate_2d: hcs_wrappers.FractalZarr, plate_3d: hcs_wrappers.FractalZarr):\n\"\"\"Test `FractalZarr` object string representation.\"\"\"\nassert str(plate_2d) == repr(plate_2d)\nassert str(plate_3d) == repr(plate_3d)\n</code></pre>"},{"location":"testing/#tests.test_hcs_wrappers.test_plateset_get_element","title":"<code>test_plateset_get_element(plate_set1)</code>","text":"<p>Test <code>FractFmiZarr.get_element()</code>.</p> Source code in <code>tests/test_hcs_wrappers.py</code> <pre><code>def test_plateset_get_element(plate_set1: hcs_wrappers.FractalZarrSet):\n\"\"\"Test `FractFmiZarr.get_element()`.\"\"\"\nassert len(plate_set1) == 2\nassert plate_set1[0] == plate_set1.zarr[0]\nassert plate_set1[plate_set1.zarr_names[1]] == plate_set1.zarr[1]\n</code></pre>"},{"location":"testing/#tests.test_hcs_wrappers.test_plateset_str","title":"<code>test_plateset_str(plate_set1)</code>","text":"<p>Test <code>FractalZarrSet</code> object string representation.</p> Source code in <code>tests/test_hcs_wrappers.py</code> <pre><code>def test_plateset_str(plate_set1: hcs_wrappers.FractalZarrSet):\n\"\"\"Test `FractalZarrSet` object string representation.\"\"\"\nassert str(plate_set1) == repr(plate_set1)\n</code></pre>"},{"location":"testing/#tests.test_hcs_wrappers.test_plot_plate","title":"<code>test_plot_plate(plate_2d, tmpdir)</code>","text":"<p>Test plot_plate.</p> Source code in <code>tests/test_hcs_wrappers.py</code> <pre><code>def test_plot_plate(plate_2d: hcs_wrappers.FractalZarr, tmpdir: str):\n\"\"\"Test plot_plate.\"\"\"\nmatplotlib.use('Agg')  # Use the 'Agg' backend, which doesn't need a display\nwith warnings.catch_warnings():\nwarnings.simplefilter('ignore') # suppress warning due to cannot show FigureCanvas \n# without mask\nplate_2d.plot_plate(image_name='0',\nlabel_name=None,\npyramid_level=None,\nchannels=[0],\nchannel_colors=['white'],\nchannel_ranges=[[0.01, 0.99]],\nz_projection_method='maximum',\nplate_layout='6well')\n# with mask\nplate_2d.plot_plate(image_name='0',\nlabel_name='organoids',\npyramid_level=None,\nchannels=[0],\nchannel_colors=['white'],\nchannel_ranges=[[0.01, 0.99]],\nz_projection_method='maximum',\nplate_layout='6well')\n# fig_style='brightfield'\nplate_2d.plot_plate(image_name='0',\nlabel_name='organoids',\npyramid_level=None,\nfig_style='brightfield',\nplate_layout='6well')\nplt.savefig(tmpdir.join('output.png'))\nassert True # check if the plotting ran through\n</code></pre>"},{"location":"testing/#tests.test_hcs_wrappers.test_plot_well","title":"<code>test_plot_well(plate_2d, tmpdir)</code>","text":"<p>Test plot_plate.</p> Source code in <code>tests/test_hcs_wrappers.py</code> <pre><code>def test_plot_well(plate_2d: hcs_wrappers.FractalZarr, tmpdir: str):\n\"\"\"Test plot_plate.\"\"\"\nmatplotlib.use('Agg')  # Use the 'Agg' backend, which doesn't need a display\nwith warnings.catch_warnings():\nwarnings.simplefilter('ignore') # suppress warning due to cannot show FigureCanvas \nplate_2d.plot_well(well='B03',\nimage_name='0',\nlabel_name=None,\npyramid_level=None,\npyramid_level_coord=None,\nchannels=[0],\nchannel_colors=['white'],\nchannel_ranges=[[0.01, 0.99]],\nz_projection_method='maximum',\nscalebar_micrometer=50,\nscalebar_label=True)\nplate_2d.plot_well(well='B03',\nimage_name='0',\nlabel_name='organoids',\npyramid_level=None,\npyramid_level_coord=None,\nchannels=[0],\nchannel_colors=['white'],\nchannel_ranges=[[0.01, 0.99]],\nz_projection_method='maximum')\nplt.savefig(tmpdir.join('output.png'))\nassert True # check if the plotting ran through\n</code></pre>"},{"location":"utils/","title":"Utility functions for <code>ez_zarr</code>","text":"<p>Utility functions for <code>ez_zarr</code>.</p>"},{"location":"utils/#src.ez_zarr.utils.convert_coordinates","title":"<code>convert_coordinates(coords_from, scale_from, scale_to)</code>","text":"<p>Convert coordinates between scales.</p> <p>Parameters:</p> Name Type Description Default <code>coords_from</code> <code>tuple</code> <p>The coordinates to be converted.</p> required <code>scale_from</code> <code>list[float]</code> <p>The scale that the coordinates refer to. Needs to be parallel to <code>coords_from</code>.</p> required <code>scale_to</code> <code>list[float]</code> <p>The scale that the coordinates should be converted to.</p> required <p>Returns:</p> Type Description <code>Union[int, float]</code> <p>A tuple of the same length as <code>coords_from</code> with coordinates in</p> <code>...</code> <p>the new scale.</p> <p>Examples:</p> <p>Convert a point (10, 30) from [1, 1] to [2, 3]:</p> <pre><code>&gt;&gt;&gt; from ez_zarr.utils import convert_coordinates\n&gt;&gt;&gt; y, x = convert_coordinates((10,30), [1, 1], [2, 3])\n</code></pre> Source code in <code>src/ez_zarr/utils.py</code> <pre><code>def convert_coordinates(coords_from: tuple[Union[int, float], ...],\nscale_from: list[float],\nscale_to: list[float]) -&gt; tuple[Union[int, float], ...]:\n\"\"\"\n    Convert coordinates between scales.\n    Parameters:\n        coords_from (tuple): The coordinates to be converted.\n        scale_from (list[float]): The scale that the coordinates refer to.\n            Needs to be parallel to `coords_from`.\n        scale_to (list[float]): The scale that the coordinates should be\n            converted to.\n    Returns:\n        A tuple of the same length as `coords_from` with coordinates in\n        the new scale.\n    Examples:\n        Convert a point (10, 30) from [1, 1] to [2, 3]:\n        &gt;&gt;&gt; from ez_zarr.utils import convert_coordinates\n        &gt;&gt;&gt; y, x = convert_coordinates((10,30), [1, 1], [2, 3])\n    \"\"\"\n# digest arguments\nassert len(coords_from) == len(scale_from)\nassert len(coords_from) == len(scale_to)\n# convert and return\ncoords_to = np.divide(np.multiply(coords_from, scale_from), scale_to)\nreturn(tuple(coords_to))\n</code></pre>"},{"location":"utils/#src.ez_zarr.utils.rescale_image","title":"<code>rescale_image(im, scale_from, scale_to, im_type='intensity', number_nonspatial_axes=0, verbose=False)</code>","text":"<p>Rescale an image (2 to 5-dimensional arrays, possibly with non-spatial axes).</p> <p>Parameters:</p> Name Type Description Default <code>im</code> <code>ndarray</code> <p>The image to be rescaled.</p> required <code>scale_from</code> <code>list[float]</code> <p>The scale that the image refers to. Needs to be parallel to <code>im</code>.</p> required <code>scale_to</code> <code>list[float]</code> <p>The scale that the image should be converted to. Needs to be of the same length as <code>scale_from</code>. The scaling factors are calculated as the ratio between <code>scale_from</code> and <code>scale_to</code>.</p> required <code>im_type</code> <code>str</code> <p>The type of the image. Can be 'intensity' (default) or 'label'. An intensity image is rescaled with anti-aliasing, while a label image is rescaled without, so that the resulting image only contains values (labels) also contained in the input.</p> <code>'intensity'</code> <code>number_nonspatial_axes</code> <code>int</code> <p>Number of first axes that refer to non-spatial dimensions, such as time or channel. Rescaling is performed only on the spatial axes, separately for each value or combination of values of the non-spatial axes.</p> <code>0</code> <code>verbose</code> <code>bool</code> <p>Whether to print out information messages.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The rescaled image as a <code>numpy.ndarray</code>.</p> <p>Examples:</p> <p>Rescale a 4D image (channels, z, y, x):</p> <pre><code>&gt;&gt;&gt; im_large = np.random.rand(4, 100, 100)\n&gt;&gt;&gt; im_small = rescale_image(im_large, [1, 0.3, 0.3], [1, 0.6, 0.6], number_nonspatial_axes=1)\n&gt;&gt;&gt; im_small.shape # returns (4, 50, 50)\n</code></pre> Source code in <code>src/ez_zarr/utils.py</code> <pre><code>def rescale_image(im: np.ndarray,\nscale_from: list[float],\nscale_to: list[float],\nim_type: str='intensity',\nnumber_nonspatial_axes: int=0,\nverbose: bool=False) -&gt; np.ndarray:\n\"\"\"\n    Rescale an image (2 to 5-dimensional arrays, possibly with non-spatial axes).\n    Parameters:\n        im (numpy.ndarray): The image to be rescaled.\n        scale_from (list[float]): The scale that the image refers to.\n            Needs to be parallel to `im`.\n        scale_to (list[float]): The scale that the image should be\n            converted to. Needs to be of the same length as `scale_from`.\n            The scaling factors are calculated as the ratio between\n            `scale_from` and `scale_to`.\n        im_type (str): The type of the image. Can be\n            'intensity' (default) or 'label'. An intensity image is\n            rescaled with anti-aliasing, while a label image is rescaled\n            without, so that the resulting image only contains values\n            (labels) also contained in the input.\n        number_nonspatial_axes (int): Number of first axes that refer to\n            non-spatial dimensions, such as time or channel. Rescaling is\n            performed only on the spatial axes, separately for each value\n            or combination of values of the non-spatial axes.\n        verbose (bool): Whether to print out information messages.\n    Returns:\n        The rescaled image as a `numpy.ndarray`.\n    Examples:\n        Rescale a 4D image (channels, z, y, x):\n        &gt;&gt;&gt; im_large = np.random.rand(4, 100, 100)\n        &gt;&gt;&gt; im_small = rescale_image(im_large, [1, 0.3, 0.3], [1, 0.6, 0.6], number_nonspatial_axes=1)\n        &gt;&gt;&gt; im_small.shape # returns (4, 50, 50)\n    \"\"\"\n# setup for rescale\nnon_spatial_axes, reshaped_im, interpolation_order, do_anti_aliasing = _setup_for_resizing(\nim=im,\nscale_from=scale_from,\nscale_to=scale_to,\nim_type=im_type,\nnumber_nonspatial_axes=number_nonspatial_axes,\nverbose=verbose)\n# Calculate the rescaling factors\nscale_factors = [from_ / to for from_, to in zip(scale_from, scale_to)]\n# Rescale the spatial dimensions separately for each non-spatial element\nrescaled_im = np.stack([rescale(image=reshaped_im[i],\nscale=scale_factors[number_nonspatial_axes:],\norder=interpolation_order,\npreserve_range=True,\nanti_aliasing=do_anti_aliasing)\nfor i in range(reshaped_im.shape[0])])\n# REMARK: is it necessary to rescale the label differently, like this:\n# ms_small = np.zeros_like(im_small[0,:,:,:], dtype=np.int32)\n# for l in filter(None, np.unique(ms)):\n#     ms_small[rescale(image=ms==l, scale=scale_factor, order=0, anti_aliasing=False)] = l\n# Reshape the rescaled array to its original shape\nrescaled_im = rescaled_im.reshape(*[[im.shape[i] for i in non_spatial_axes] +\nlist(rescaled_im.shape[1:])])\nreturn rescaled_im\n</code></pre>"},{"location":"utils/#src.ez_zarr.utils.resize_image","title":"<code>resize_image(im, output_shape, im_type='intensity', number_nonspatial_axes=0, verbose=False)</code>","text":"<p>Resize an image (2 to 5-dimensional arrays, possibly with non-spatial axes).</p> <p>Parameters:</p> Name Type Description Default <code>im</code> <code>ndarray</code> <p>The image to be rescaled.</p> required <code>output_shape</code> <code>tuple[int]</code> <p>The shape of the output image. This must be parallel to the shape of the input image.</p> required <code>im_type</code> <code>str</code> <p>The type of the image. Can be 'intensity' (default) or 'label'. An intensity image is rescaled with anti-aliasing, while a label image is rescaled without, so that the resulting image only contains values (labels) also contained in the input.</p> <code>'intensity'</code> <code>number_nonspatial_axes</code> <code>int</code> <p>Number of first axes that refer to non-spatial dimensions, such as time or channel. Rescaling is performed only on the spatial axes, separately for each value or combination of values of the non-spatial axes.</p> <code>0</code> <code>verbose</code> <code>bool</code> <p>Whether to print out information messages.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The rescaled image as a <code>numpy.ndarray</code>.</p> <p>Examples:</p> <p>Resize a 4D image (channels, z, y, x):</p> <pre><code>&gt;&gt;&gt; im_large = np.random.rand(4, 100, 100)\n&gt;&gt;&gt; im_small = resize_image(im_large, (4, 50, 50), number_nonspatial_axes=1)\n&gt;&gt;&gt; im_small.shape # returns (4, 50, 50)\n</code></pre> Source code in <code>src/ez_zarr/utils.py</code> <pre><code>def resize_image(im: np.ndarray,\noutput_shape: tuple[int],\nim_type: str='intensity',\nnumber_nonspatial_axes: int=0,\nverbose: bool=False) -&gt; np.ndarray:\n\"\"\"\n    Resize an image (2 to 5-dimensional arrays, possibly with non-spatial axes).\n    Parameters:\n        im (numpy.ndarray): The image to be rescaled.\n        output_shape (tuple[int]): The shape of the output image. This must\n            be parallel to the shape of the input image.\n        im_type (str): The type of the image. Can be\n            'intensity' (default) or 'label'. An intensity image is\n            rescaled with anti-aliasing, while a label image is rescaled\n            without, so that the resulting image only contains values\n            (labels) also contained in the input.\n        number_nonspatial_axes (int): Number of first axes that refer to\n            non-spatial dimensions, such as time or channel. Rescaling is\n            performed only on the spatial axes, separately for each value\n            or combination of values of the non-spatial axes.\n        verbose (bool): Whether to print out information messages.\n    Returns:\n        The rescaled image as a `numpy.ndarray`.\n    Examples:\n        Resize a 4D image (channels, z, y, x):\n        &gt;&gt;&gt; im_large = np.random.rand(4, 100, 100)\n        &gt;&gt;&gt; im_small = resize_image(im_large, (4, 50, 50), number_nonspatial_axes=1)\n        &gt;&gt;&gt; im_small.shape # returns (4, 50, 50)\n    \"\"\"\n# setup for rescale\nnon_spatial_axes, reshaped_im, interpolation_order, do_anti_aliasing = _setup_for_resizing(\nim=im,\noutput_shape=output_shape,\nim_type=im_type,\nnumber_nonspatial_axes=number_nonspatial_axes,\nverbose=verbose)\n# Rescale the spatial dimensions separately for each non-spatial element\nresized_im = np.stack([resize(image=reshaped_im[i],\noutput_shape=output_shape[number_nonspatial_axes:],\norder=interpolation_order,\npreserve_range=True,\nanti_aliasing=do_anti_aliasing)\nfor i in range(reshaped_im.shape[0])])\n# REMARK: is it necessary to rescale the label differently, like this:\n# ms_small = np.zeros_like(im_small[0,:,:,:], dtype=np.int32)\n# for l in filter(None, np.unique(ms)):\n#     ms_small[rescale(image=ms==l, scale=scale_factor, order=0, anti_aliasing=False)] = l\n# Reshape the resized array to its original shape\nresized_im = resized_im.reshape(*[[im.shape[i] for i in non_spatial_axes] +\nlist(resized_im.shape[1:])])\nreturn resized_im\n</code></pre>"}]}